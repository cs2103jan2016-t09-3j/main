# A0124697U
###### \src\tnote\logic\CommandAdd.java
``` java
package tnote.logic;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertTrue;
import java.util.logging.Logger;
import tnote.util.log.TNoteLogger;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.Iterator;

import tnote.object.RecurringTaskFile;
import tnote.object.TaskFile;
import tnote.storage.TNotesStorage;
import tnote.util.exceptions.TaskExistsException;
import tnote.util.exceptions.TimeClashException;

/**
 * This class maintains the logic of how a task is added based on sorted String
 * inputs in an ArrayList
 * 
 * It modifies an instance of a created TaskFile object according to information
 * provided. It then calls storage to store the task , before returning the
 * TaskFile object back to UI
 * 
 * @author A0124697U
 *
 */
public class CommandAdd {
	private static final String TIME_CLASH_MSG = "There is a time clash";

	private static final String ARRAYLISTCHECK = "addcheck ";

	private static final String MESSAGE_LOG_ERROR = "Error adding to Storage";

	private static final int DEFAULT_DAY_DURATION = 12;
	private static final int DEFAULT_WEEK_DURATION = 10;
	private static final int DEFAULT_FORTNIGHT_DURATION = 4;
	private static final int DEFAULT_MONTH_DURATION = 2;

	private static final int INDEX_FOUR = 4;
	private static final int DEFAULT_DURATION = 8;
	private static final int INDEX_TWO = 2;
	private static final int INDEX_THREE = 3;
	private static final int INDEX_ONE = 1;
	private static final int ZERO_INDEX = 0;
	private static final String DAY_SHORTFORM = "EEE";
	private static final String PARSER_DATE_FORMAT = "yyyy-MM-dd";

	private static final String STRING_COLON = ":";
	private static final String STRING_DASH = "-";

	private static final String MONTH = "month";
	private static final String FORTNIGHT = "fortnight";
	private static final String WEEK = "week";
	private static final String DAY = "day";
	private static final String TOMORROW = "tomorrow";
	private static final String TODAY = "today";

	private static final String FOR = " for ";
	private static final String IT_RECURS_EVERY = " It recurs every ";

	private static final String SUNDAY = "sunday";
	private static final String SATURDAY = "saturday";
	private static final String FRIDAY = "friday";
	private static final String THURSDAY = "thursday";
	private static final String WEDNESDAY = "wednesday";
	private static final String TUESDAY = "tuesday";
	private static final String MONDAY = "monday";

	private static final String KEYWORD_FOR = "for";
	private static final String EVERY = "every";
	private static final String IMPORTANT = "important";

	private TNotesStorage storage;

	private static final Logger logger = Logger.getGlobal();

	private DateFormat df = new SimpleDateFormat(PARSER_DATE_FORMAT);

	protected CommandAdd() throws Exception {
		storage = TNotesStorage.getInstance();
	}

	/**
	 * 
	 * Method that creates a TaskFile object from a variation of inputs and adds
	 * it to storage.
	 * 
	 * @param fromParser
	 *            - ArrayList of sorted inputs from the parser
	 * @return - the newly added TaskFile object
	 * @throws Exception
	 */
	protected TaskFile addTask(ArrayList<String> fromParser) throws Exception {

		logger.info(ARRAYLISTCHECK + fromParser.toString());

		ArrayList<String> stringList = storage.readFromMasterFile();
		TaskFile currentFile = new TaskFile();

		String importance = new String();
		String recurArgument = new String();
		String recurDuration = new String();
		String recurNumDuration = new String();
		Calendar cal = Calendar.getInstance();

		assertNotEquals(ZERO_INDEX, fromParser.size());
		currentFile.setName(fromParser.remove(ZERO_INDEX).trim());

		if (fromParser.contains(IMPORTANT))
			importanceFlag(fromParser, currentFile);

		if (fromParser.contains(EVERY)) {
			int indexOfRecurKeyWord = fromParser.indexOf(EVERY);
			recurArgument = fromParser.remove(indexOfRecurKeyWord + INDEX_ONE).toLowerCase();
			fromParser.remove(EVERY);
			if ((fromParser.size() > indexOfRecurKeyWord)
					&& (fromParser.get(indexOfRecurKeyWord).equals(KEYWORD_FOR))) {
				fromParser.remove(KEYWORD_FOR);
				recurNumDuration = fromParser.remove(indexOfRecurKeyWord);
				recurDuration = fromParser.remove(indexOfRecurKeyWord);
			}
			currentFile.setIsRecurr(true);
		}
		if (fromParser.contains(TODAY)) {
			String date = df.format(cal.getTime());
			fromParser.set(fromParser.indexOf(TODAY), date);
		}

		if (fromParser.contains(TOMORROW)) {
			String date = df.format(cal.getTime()).toLowerCase();
			cal.add(Calendar.DATE, INDEX_ONE);
			date = df.format(cal.getTime()).toLowerCase();
			fromParser.set(fromParser.indexOf(TOMORROW), date);
		}

		for (int i = ZERO_INDEX; i < fromParser.size(); i++) {
			String day = fromParser.get(i).toLowerCase();
			if (day.equals(MONDAY) || (day.equals(TUESDAY)) || (day.equals(WEDNESDAY)) || (day.equals(THURSDAY))
					|| (day.equals(FRIDAY)) || (day.equals(SATURDAY)) || (day.equals(SUNDAY))) {
				String date = compareDates(day);
				fromParser.set(i, date);
			}
		}
		logger.info(ARRAYLISTCHECK + fromParser.toString());

		Iterator<String> aListIterator = fromParser.iterator();
		while (aListIterator.hasNext()) {
			String details = aListIterator.next();
			if (!details.contains(STRING_COLON) && !details.contains(STRING_DASH)) {
				currentFile.setDetails(details + ".");
				aListIterator.remove();
			}
		}

		currentFile = dateFormatter(fromParser, currentFile, recurArgument, cal);
		currentFile.setUpTaskFile();

		if (currentFile.getIsMeeting()) {
			meetingClash(stringList, currentFile);
		}
		if (currentFile.getIsRecurring()) {
			return addRecuringTask(currentFile, recurArgument, recurDuration, recurNumDuration, cal);
		}
		if (storage.addTask(currentFile)) {

			return currentFile;
		} else {
			logger.warning(MESSAGE_LOG_ERROR);
			throw new TaskExistsException();
		}

	}

	/**
	 * Method to check if the to be created object is important
	 * 
	 * @param fromParser
	 *            - ArrayList of string inputs from parser
	 * @param currentFile
	 *            - currently modified taskFile object.
	 */
	private void importanceFlag(ArrayList<String> fromParser, TaskFile currentFile) {
		{
			fromParser.remove(fromParser.indexOf(IMPORTANT));
			currentFile.setImportance(true);
		}
	}

	/**
	 * Method to check if the TaskFile object clashes with any task.
	 * 
	 * @param stringList
	 *            - the current list of names inside the storage
	 * @param currentFile
	 *            - the TaskFile object that is currently being added
	 * @throws Exception
	 * @throws TimeClashException
	 */
	private void meetingClash(ArrayList<String> stringList, TaskFile currentFile) throws Exception, TimeClashException {
		{
			for (String savedTaskName : stringList) {
				logger.info(savedTaskName);
				TaskFile savedTask = storage.getTaskFileByName(savedTaskName);
				if (savedTask.getIsMeeting()) {
					if (hasTimingClash(currentFile, savedTask)) {
						throw new TimeClashException(TIME_CLASH_MSG, currentFile.getName(), savedTask.getName());
					}
				}
			}
		}
	}

	/**
	 * Method specifically for adding recurring task, called by a flag in the
	 * addTask method
	 * 
	 * @param currentFile
	 *            - the TaskFile object with the amended timings and names.
	 * @param recurArgument
	 *            - keyword of what it recurs on
	 * @param recurDuration
	 *            - recurring variable that determines the type
	 * @param recurNumDuration
	 *            - how long it recurs for in numbers
	 * @param cal
	 *            - calendar object
	 * @return - a TaskFile object that is recurring, along with the recurring
	 *         dates.
	 * @throws ParseException
	 * @throws NumberFormatException
	 * @throws Exception
	 */
	private TaskFile addRecuringTask(TaskFile currentFile, String recurArgument, String recurDuration,
			String recurNumDuration , Calendar cal
) throws ParseException, NumberFormatException, Exception {
		{
			String taskDetails = currentFile.getDetails();
			taskDetails += IT_RECURS_EVERY + recurArgument;

			if (!recurDuration.isEmpty() && !recurNumDuration.isEmpty()) {
				taskDetails += FOR + recurNumDuration + " " + recurDuration;
			}

			logger.info(taskDetails);
			currentFile.setDetails(taskDetails);

			ArrayList<String> dateList = new ArrayList<String>();
			ArrayList<String> endDateList = new ArrayList<String>();
			Calendar startCal = (Calendar) currentFile.getStartCal().clone();
			Calendar endCal = Calendar.getInstance();

			if (currentFile.getIsMeeting()) {
				endCal.setTime(df.parse(currentFile.getEndDate()));
			}

			if (recurArgument.equals(DAY)) {
				if (recurDuration.contains(DAY)) {
					for (int i = ZERO_INDEX; i < Integer.parseInt(recurNumDuration); i++) {
						dateList.add(df.format(startCal.getTime()));
						startCal.add(Calendar.DATE, INDEX_ONE);

						if (currentFile.getIsMeeting()) {
							endDateList.add(df.format(endCal.getTime()));
							endCal.add(Calendar.DATE, INDEX_ONE);
						}
					}
				} else if (recurDuration.contains(WEEK)) {
					for (int i = ZERO_INDEX; i < (Integer.parseInt(recurNumDuration) * 7); i++) {
						dateList.add(df.format(startCal.getTime()));
						startCal.add(Calendar.DATE, INDEX_ONE);

						if (currentFile.getIsMeeting()) {
							endDateList.add(df.format(endCal.getTime()));
							endCal.add(Calendar.DATE, INDEX_ONE);
						}
					}
				} else if (recurDuration.contains(FORTNIGHT)) {
					for (int i = ZERO_INDEX; i < (Integer.parseInt(recurNumDuration) * 14); i++) {
						dateList.add(df.format(startCal.getTime()));
						startCal.add(Calendar.DATE, INDEX_ONE);

						if (currentFile.getIsMeeting()) {
							endDateList.add(df.format(endCal.getTime()));
							endCal.add(Calendar.DATE, INDEX_ONE);
						}
					}
				} else if (recurDuration.contains(MONTH)) {
					for (int i = ZERO_INDEX; i < (Integer.parseInt(recurNumDuration) * 30); i++) {
						dateList.add(df.format(startCal.getTime()));
						startCal.add(Calendar.DATE, INDEX_ONE);

						if (currentFile.getIsMeeting()) {
							endDateList.add(df.format(endCal.getTime()));
							endCal.add(Calendar.DATE, INDEX_ONE);
						}
					}
				} else {
					for (int i = ZERO_INDEX; i < DEFAULT_DAY_DURATION; i++) {
						dateList.add(df.format(startCal.getTime()));
						startCal.add(Calendar.DATE, INDEX_ONE);

						if (currentFile.getIsMeeting()) {
							endDateList.add(df.format(endCal.getTime()));
							endCal.add(Calendar.DATE, INDEX_ONE);
						}
					}
				}
			} else if (recurArgument.equals(WEEK)) {
				if (recurDuration.contains(WEEK)) {
					for (int i = ZERO_INDEX; i < (Integer.parseInt(recurNumDuration)); i++) {
						dateList.add(df.format(startCal.getTime()));
						startCal.add(Calendar.WEEK_OF_YEAR, INDEX_ONE);

						if (currentFile.getIsMeeting()) {
							endDateList.add(df.format(endCal.getTime()));
							endCal.add(Calendar.WEEK_OF_YEAR, INDEX_ONE);
						}
					}
				} else if (recurDuration.contains(FORTNIGHT)) {
					for (int i = ZERO_INDEX; i < (Integer.parseInt(recurNumDuration) * INDEX_TWO); i++) {
						dateList.add(df.format(startCal.getTime()));
						startCal.add(Calendar.WEEK_OF_YEAR, INDEX_ONE);

						if (currentFile.getIsMeeting()) {
							endDateList.add(df.format(endCal.getTime()));
							endCal.add(Calendar.WEEK_OF_YEAR, INDEX_ONE);
						}
					}
				} else if (recurDuration.contains(MONTH)) {
					for (int i = ZERO_INDEX; i < (Integer.parseInt(recurNumDuration) * INDEX_FOUR); i++) {
						dateList.add(df.format(startCal.getTime()));
						startCal.add(Calendar.WEEK_OF_YEAR, INDEX_ONE);

						if (currentFile.getIsMeeting()) {
							endDateList.add(df.format(endCal.getTime()));
							endCal.add(Calendar.WEEK_OF_YEAR, INDEX_ONE);
						}
					}
				} else {
					for (int i = ZERO_INDEX; i < DEFAULT_WEEK_DURATION; i++) {
						dateList.add(df.format(startCal.getTime()));
						startCal.add(Calendar.WEEK_OF_YEAR, INDEX_ONE);

						if (currentFile.getIsMeeting()) {
							endDateList.add(df.format(endCal.getTime()));
							endCal.add(Calendar.WEEK_OF_YEAR, INDEX_ONE);
						}
					}
				}

			} else if (recurArgument.equals(FORTNIGHT)) {
				if (recurDuration.contains(FORTNIGHT)) {
					for (int i = ZERO_INDEX; i < (Integer.parseInt(recurNumDuration)); i++) {
						dateList.add(df.format(startCal.getTime()));
						startCal.add(Calendar.WEEK_OF_YEAR, INDEX_TWO);

						if (currentFile.getIsMeeting()) {
							endDateList.add(df.format(endCal.getTime()));
							endCal.add(Calendar.WEEK_OF_YEAR, INDEX_TWO);
						}
					}
				} else if (recurDuration.contains(MONTH)) {
					for (int i = ZERO_INDEX; i < (Integer.parseInt(recurNumDuration) * INDEX_TWO); i++) {
						dateList.add(df.format(startCal.getTime()));
						startCal.add(Calendar.WEEK_OF_YEAR, INDEX_TWO);

						if (currentFile.getIsMeeting()) {
							endDateList.add(df.format(endCal.getTime()));
							endCal.add(Calendar.WEEK_OF_YEAR, INDEX_TWO);
						}
					}
				} else {
					for (int i = ZERO_INDEX; i < DEFAULT_FORTNIGHT_DURATION; i++) {
						dateList.add(df.format(startCal.getTime()));
						startCal.add(Calendar.WEEK_OF_YEAR, INDEX_TWO);

						if (currentFile.getIsMeeting()) {
							endDateList.add(df.format(endCal.getTime()));
							endCal.add(Calendar.WEEK_OF_YEAR, INDEX_ONE);
						}
					}
				}
			} else if (recurArgument.equals(MONTH)) {
				if (recurDuration.contains(MONTH)) {
					for (int i = ZERO_INDEX; i < (Integer.parseInt(recurNumDuration)); i++) {
						dateList.add(df.format(startCal.getTime()));
						startCal.add(Calendar.MONTH, INDEX_ONE);

						if (currentFile.getIsMeeting()) {
							endDateList.add(df.format(endCal.getTime()));
							endCal.add(Calendar.MONTH, INDEX_ONE);
						}
					}
				} else {
					for (int i = ZERO_INDEX; i < DEFAULT_MONTH_DURATION; i++) {
						dateList.add(df.format(startCal.getTime()));
						startCal.add(Calendar.MONTH, INDEX_ONE);

						if (currentFile.getIsMeeting()) {
							endDateList.add(df.format(endCal.getTime()));
							endCal.add(Calendar.MONTH, INDEX_ONE);
						}
					}
				}
			} else {
				recurArgument.contains(DAY);
				String date = compareDates(recurArgument);
				currentFile.setStartDate(date);
				Date dateToStart = df.parse(date);
				startCal.setTime(dateToStart);

				if (recurDuration.contains(WEEK)) {
					for (int i = ZERO_INDEX; i < (Integer.parseInt(recurNumDuration)); i++) {
						dateList.add(df.format(startCal.getTime()));
						startCal.add(Calendar.WEEK_OF_YEAR, INDEX_ONE);

						if (currentFile.getIsMeeting()) {
							endDateList.add(df.format(endCal.getTime()));
							endCal.add(Calendar.WEEK_OF_YEAR, INDEX_ONE);
						}
					}
				} else if (recurDuration.contains(FORTNIGHT)) {
					for (int i = ZERO_INDEX; i < (Integer.parseInt(recurNumDuration) * INDEX_TWO); i++) {
						dateList.add(df.format(startCal.getTime()));
						startCal.add(Calendar.WEEK_OF_YEAR, INDEX_ONE);

						if (currentFile.getIsMeeting()) {
							endDateList.add(df.format(endCal.getTime()));
							endCal.add(Calendar.WEEK_OF_YEAR, INDEX_ONE);
						}
					}
				} else if (recurDuration.contains(MONTH)) {
					for (int i = ZERO_INDEX; i < (Integer.parseInt(recurNumDuration) * INDEX_FOUR); i++) {
						dateList.add(df.format(startCal.getTime()));
						startCal.add(Calendar.WEEK_OF_YEAR, INDEX_ONE);

						if (currentFile.getIsMeeting()) {
							endDateList.add(df.format(endCal.getTime()));
							endCal.add(Calendar.WEEK_OF_YEAR, INDEX_ONE);
						}
					}
				} else {
					for (int i = ZERO_INDEX; i < DEFAULT_DURATION; i++) {
						dateList.add(df.format(startCal.getTime()));
						startCal.add(Calendar.WEEK_OF_YEAR, INDEX_ONE);

						if (currentFile.getIsMeeting()) {
							endDateList.add(df.format(endCal.getTime()));
							endCal.add(Calendar.WEEK_OF_YEAR, INDEX_ONE);
						}
					}
				}
			}

			RecurringTaskFile recurTask = new RecurringTaskFile(currentFile);
			recurTask.addRecurringStartDate(dateList);
			recurTask.addRecurringEndDate(endDateList);

			storage.addRecurringTask(recurTask);

			return currentFile;
		}
	}

	/**
	 * Method to format dates accordingly
	 * 
	 * @param fromParser
	 *            - the current ArrayList of inputs from the parser, after all
	 *            the sorting
	 * 
	 * @param currentFile
	 *            - the current modified TaskFile object
	 * @param recurArgument
	 *            - the day input for the task, if there exist one.
	 * @param cal
	 *            - calendar object.
	 */
	private TaskFile dateFormatter(ArrayList<String> fromParser, TaskFile currentFile, String recurArgument,
			Calendar cal) {
		switch (fromParser.size()) {
		case INDEX_ONE:

			if (fromParser.get(ZERO_INDEX).contains(STRING_DASH)) {
				currentFile.setStartDate(fromParser.get(ZERO_INDEX));
			} else {
				assertTrue(fromParser.get(ZERO_INDEX).contains(STRING_COLON));
				currentFile.setStartTime(fromParser.get(ZERO_INDEX));

			}
			break;
		case INDEX_TWO:
			if (fromParser.get(ZERO_INDEX).contains(STRING_DASH)) {
				currentFile.setStartDate(fromParser.get(ZERO_INDEX));

				if (fromParser.get(INDEX_ONE).contains(STRING_DASH)) {
					currentFile.setEndDate(fromParser.get(INDEX_ONE));
				} else {
					assertTrue(fromParser.get(INDEX_ONE).contains(STRING_COLON));
					currentFile.setStartTime(fromParser.get(INDEX_ONE));
				}

			} else if (fromParser.get(ZERO_INDEX).contains(STRING_COLON)) {
				currentFile.setStartTime(fromParser.get(ZERO_INDEX));

				if (fromParser.get(INDEX_ONE).contains(STRING_DASH)) {
					currentFile.setEndDate(fromParser.get(INDEX_ONE));
				} else {
					assertTrue(fromParser.get(INDEX_ONE).contains(STRING_COLON));
					currentFile.setEndTime(fromParser.get(INDEX_ONE));
				}

			}
			break;
		case INDEX_THREE:
			if (fromParser.get(ZERO_INDEX).contains(STRING_DASH)) {
				currentFile.setStartDate(fromParser.get(ZERO_INDEX));

				if (fromParser.get(INDEX_ONE).contains(STRING_COLON)) {
					currentFile.setStartTime(fromParser.get(INDEX_ONE));

					if (fromParser.get(INDEX_TWO).contains(STRING_DASH)) {
						currentFile.setEndDate(fromParser.get(INDEX_TWO));
					} else {
						assertTrue(fromParser.get(INDEX_TWO).contains(STRING_COLON));
						currentFile.setEndTime(fromParser.get(INDEX_TWO));
					}

				} else {

					assertTrue(fromParser.get(INDEX_ONE).contains(STRING_DASH));
					currentFile.setEndDate(fromParser.get(INDEX_ONE));

					assertTrue(fromParser.get(INDEX_TWO).contains(STRING_COLON));
					currentFile.setEndTime(fromParser.get(INDEX_TWO));
				}

			} else {

				assertTrue(fromParser.get(ZERO_INDEX).contains(STRING_COLON));
				currentFile.setStartTime(fromParser.get(ZERO_INDEX));

				assertTrue(fromParser.get(INDEX_ONE).contains(STRING_DASH));
				currentFile.setEndDate(fromParser.get(INDEX_ONE));

				assertTrue(fromParser.get(INDEX_TWO).contains(STRING_COLON));
				currentFile.setEndTime(fromParser.get(INDEX_TWO));
			}
			break;

		case INDEX_FOUR:

			assertTrue(fromParser.get(ZERO_INDEX).contains(STRING_DASH));
			currentFile.setStartDate(fromParser.get(ZERO_INDEX));

			assertTrue(fromParser.get(INDEX_ONE).contains(STRING_COLON));
			currentFile.setStartTime(fromParser.get(INDEX_ONE));

			assertTrue(fromParser.get(INDEX_TWO).contains(STRING_DASH));
			currentFile.setEndDate(fromParser.get(INDEX_TWO));

			assertTrue(fromParser.get(INDEX_THREE).contains(STRING_COLON));
			currentFile.setEndTime(fromParser.get(INDEX_THREE));

			break;

		default:
			assertEquals(ZERO_INDEX, fromParser.size());
			if (!recurArgument.isEmpty()) {
				String date;
				if (recurArgument.equals(DAY)) {
					date = df.format(cal.getTime());
				} else if (recurArgument.contains(DAY)) {
					date = compareDates(recurArgument);
				} else {
					date = df.format(cal.getTime());
				}
				currentFile.setStartDate(date);

			}
		}
		return currentFile;
	}

	/**
	 * Method to get a specific date from a certain String word
	 * 
	 * @param dates
	 *            - a specific day, Monday,Tuesday, etc
	 * @return - a string of the day in DD-MM-YYYY format
	 */
	private String compareDates(String dates) {
		Calendar cal = Calendar.getInstance();
		DateFormat shortForm = new SimpleDateFormat(DAY_SHORTFORM);
		String date = shortForm.format(cal.getTime()).toLowerCase();

		while (!dates.contains(date)) {
			cal.add(Calendar.DATE, INDEX_ONE);
			date = shortForm.format(cal.getTime()).toLowerCase();
		}
		return df.format(cal.getTime());
	}

	/**
	 * Method to check if the timings of the 2 TaskFile objects clash
	 * 
	 * @param currentFile
	 *            - the current task that is to be added
	 * @param savedTask
	 *            - the task already in storage
	 * @return - returns true if no clash, returns flash if there is a clash
	 */
	private boolean hasTimingClash(TaskFile currentFile, TaskFile savedTask) {
		return ((currentFile.getStartCal().before(savedTask.getEndCal())
				&& currentFile.getEndCal().after(savedTask.getEndCal()))
				|| (currentFile.getStartCal().after(savedTask.getStartCal())
						&& currentFile.getEndCal().before(savedTask.getEndCal()))
				|| (currentFile.getStartCal().after(savedTask.getStartCal())
						&& currentFile.getStartCal().before(savedTask.getEndCal()))
				|| (currentFile.getEndCal().after(savedTask.getStartCal())
						&& currentFile.getEndCal().before(savedTask.getEndCal())));
	}
}
```
###### \src\tnote\logic\CommandAddTest.java
``` java
package tnote.logic;

import static org.junit.Assert.*;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import tnote.object.RecurringTaskFile;
import tnote.object.TaskFile;
import tnote.storage.TNotesStorage;

public class CommandAddTest {
	CommandAdd cmdAdd;
	DateFormat df = new SimpleDateFormat("yyyy-MM-dd");
	Calendar cal = Calendar.getInstance();
	TNotesStorage storage;

	@Before
	public void setUp() throws Exception {
		TNotesStorage storage = TNotesStorage.getInstance();
		cmdAdd = new CommandAdd();
		System.out.println(storage.clearFiles());
		storage.setUpStorage();
	}

	@After
	public void tearDown() throws Exception {
		TNotesStorage storage = TNotesStorage.getInstance();
		System.out.println(storage.clearFiles());
	}

	@Test
	public void addFloatingTaskTest() throws Exception {
		ArrayList<String> aList = new ArrayList<String>();
		ArrayList<String> bList = new ArrayList<String>();

		aList.add("Chemistry Test");
		bList.add("Math Test");

		TaskFile currentTask = cmdAdd.addTask(aList);
		TaskFile newTask = cmdAdd.addTask(bList);

		assertEquals("Chemistry Test", currentTask.getName());
		assertEquals(currentTask.getDetails(), newTask.getDetails());
		assertFalse(currentTask.getIsRecurring());
		assertFalse(currentTask.getImportance());

	}

	@Test
	public void addNormalTaskTest() throws Exception {
		ArrayList<String> aList = new ArrayList<String>();
		ArrayList<String> bList = new ArrayList<String>();

		aList.add("write report");
		aList.add("today");
		aList.add("22:00pm");
		aList.add("details");
		aList.add("write about feelings");

		TaskFile firstTask = cmdAdd.addTask(aList);
		assertEquals("22:00pm", firstTask.getStartTime());

		String date = df.format(cal.getTime()).toLowerCase();

		assertEquals(date, firstTask.getStartDate());
		assertEquals("write about feelings.", firstTask.getDetails());
		assertFalse(firstTask.getIsRecurring());
		assertFalse(firstTask.getImportance());
		assertFalse(firstTask.getIsMeeting());

		bList.add("attend lecture");
		bList.add("wednesday");
		bList.add("14:00pm");
		bList.add("16:00pm");
		bList.add("important");

		String dates = aList.get(1);
		TaskFile secondTask = cmdAdd.addTask(bList);
		assertEquals("14:00pm", secondTask.getStartTime());
		assertEquals("16:00pm", secondTask.getEndTime());

		assertEquals("2016-04-13", secondTask.getStartDate());
		assertFalse(secondTask.getIsDone());
		assertFalse(secondTask.getIsDeadline());
		assertTrue(secondTask.getImportance());

	}

	@Test
	public void addNormalTaskTest2() throws Exception {
		ArrayList<String> aList = new ArrayList<String>();
		ArrayList<String> bList = new ArrayList<String>();

		aList.add("write report");
		aList.add("2016-04-20");
		aList.add("22:00");
		aList.add("2016-04-21");
		aList.add("23:00");
		aList.add("important");

		TaskFile firstTask = cmdAdd.addTask(aList);
		assertEquals("22:00", firstTask.getStartTime());

		assertEquals("2016-04-20", firstTask.getStartDate());
		assertNotEquals("write about feelings.", firstTask.getDetails());
		assertFalse(firstTask.getIsRecurring());
		assertTrue(firstTask.getImportance());
		assertTrue(firstTask.getIsMeeting());



	}

	@Test
	public void addRecurringTaskDayTest() throws Exception {
		TNotesStorage storage = TNotesStorage.getInstance();
		ArrayList<String> aList = new ArrayList<String>();

		aList.add("attend tuition");
		aList.add("2016-04-15");
		aList.add("16:00");
		aList.add("18:00");
		aList.add("every");
		aList.add("day");

		TaskFile currentTask = cmdAdd.addTask(aList);
		assertEquals("2016-04-15", currentTask.getStartDate());
		assertEquals("attend tuition", currentTask.getName());
		assertEquals(" It recurs every day", currentTask.getDetails());
		assertTrue(currentTask.getIsRecurring());
		assertFalse(currentTask.getImportance());

		ArrayList<String> dateList = new ArrayList<String>();
		ArrayList<String> endDateList = new ArrayList<String>();
		dateList.add("2016-04-15");
		dateList.add("2016-04-16");
		dateList.add("2016-04-17");
		dateList.add("2016-04-18");
		dateList.add("2016-04-19");
		dateList.add("2016-04-20");
		dateList.add("2016-04-21");
		dateList.add("2016-04-22");
		dateList.add("2016-04-23");
		dateList.add("2016-04-24");
		dateList.add("2016-04-25");
		dateList.add("2016-04-26");

		endDateList.add("2016-04-15");
		endDateList.add("2016-04-16");
		endDateList.add("2016-04-17");
		endDateList.add("2016-04-18");
		endDateList.add("2016-04-19");
		endDateList.add("2016-04-20");
		endDateList.add("2016-04-21");
		endDateList.add("2016-04-22");
		endDateList.add("2016-04-23");
		endDateList.add("2016-04-24");
		endDateList.add("2016-04-25");
		endDateList.add("2016-04-26");

		assertEquals(dateList, storage.getRecurTaskStartDateList("attend tuition"));
		assertEquals(endDateList, storage.getRecurTaskEndDateList("attend tuition"));

	}
	@Test
	public void addRecurringTaskDayTest2() throws Exception {
		TNotesStorage storage = TNotesStorage.getInstance();
		ArrayList<String> aList = new ArrayList<String>();
		ArrayList<String> bList = new ArrayList<String>();

		aList.add("tuition");
		aList.add("2016-04-15");
		aList.add("20:00");
		aList.add("21:00");
		aList.add("every");
		aList.add("day");
		aList.add("for");
		aList.add("1");
		aList.add("week");

		TaskFile currentTask = cmdAdd.addTask(aList);
		assertEquals("2016-04-15", currentTask.getStartDate());
		assertEquals("tuition", currentTask.getName());
		assertEquals(" It recurs every day for 1 week", currentTask.getDetails());
		assertTrue(currentTask.getIsRecurring());
		assertFalse(currentTask.getImportance());

		ArrayList<String> dateList = new ArrayList<String>();
		ArrayList<String> endDateList = new ArrayList<String>();
		dateList.add("2016-04-15");
		dateList.add("2016-04-16");
		dateList.add("2016-04-17");
		dateList.add("2016-04-18");
		dateList.add("2016-04-19");
		dateList.add("2016-04-20");
		dateList.add("2016-04-21");

		endDateList.add("2016-04-15");
		endDateList.add("2016-04-16");
		endDateList.add("2016-04-17");
		endDateList.add("2016-04-18");
		endDateList.add("2016-04-19");
		endDateList.add("2016-04-20");
		endDateList.add("2016-04-21");

		assertEquals(dateList, storage.getRecurTaskStartDateList("tuition"));
		assertEquals(endDateList, storage.getRecurTaskEndDateList("tuition"));
		
		bList.add("attend");
		bList.add("2016-04-15");
		bList.add("21:00");
		bList.add("22:00");
		bList.add("every");
		bList.add("day");
		bList.add("for");
		bList.add("1");
		bList.add("month");

		TaskFile secondTask = cmdAdd.addTask(bList);
		
		dateList.add("2016-04-15");
		dateList.add("2016-04-16");
		dateList.add("2016-04-17");
		dateList.add("2016-04-18");
		dateList.add("2016-04-19");
		dateList.add("2016-04-20");
		dateList.add("2016-04-21");
		dateList.add("2016-04-22");
		dateList.add("2016-04-23");
		dateList.add("2016-04-24");
		dateList.add("2016-04-25");
		dateList.add("2016-04-26");
		dateList.add("2016-04-27");
		dateList.add("2016-04-28");
		dateList.add("2016-04-29");
		dateList.add("2016-04-30");
		dateList.add("2016-05-01");
		dateList.add("2016-05-02");
		dateList.add("2016-05-03");
		dateList.add("2016-05-04");
		dateList.add("2016-05-05");
		dateList.add("2016-05-06");
		dateList.add("2016-05-07");
		dateList.add("2016-05-08");
		dateList.add("2016-05-09");
		dateList.add("2016-05-10");
		dateList.add("2016-05-11");
		dateList.add("2016-05-12");
		dateList.add("2016-05-13");
		dateList.add("2016-05-14");
		
		endDateList.add("2016-04-15");
		endDateList.add("2016-04-16");
		endDateList.add("2016-04-17");
		endDateList.add("2016-04-18");
		endDateList.add("2016-04-19");
		endDateList.add("2016-04-20");
		endDateList.add("2016-04-21");
		endDateList.add("2016-04-22");
		endDateList.add("2016-04-23");
		endDateList.add("2016-04-24");
		endDateList.add("2016-04-25");
		endDateList.add("2016-04-26");
		endDateList.add("2016-04-27");
		endDateList.add("2016-04-28");
		endDateList.add("2016-04-29");
		endDateList.add("2016-04-30");
		endDateList.add("2016-05-01");
		endDateList.add("2016-05-02");
		endDateList.add("2016-05-03");
		endDateList.add("2016-05-04");
		endDateList.add("2016-05-05");
		endDateList.add("2016-05-06");
		endDateList.add("2016-05-07");
		endDateList.add("2016-05-08");
		endDateList.add("2016-05-09");
		endDateList.add("2016-05-10");
		endDateList.add("2016-05-11");
		endDateList.add("2016-05-12");
		endDateList.add("2016-05-13");
		endDateList.add("2016-05-14");
		
		assertNotEquals(dateList, storage.getRecurTaskStartDateList("attend"));
		assertNotEquals(endDateList, storage.getRecurTaskEndDateList("attend"));
	}

	@Test
	public void addRecurringTaskWeekTest() throws Exception {
		TNotesStorage storage = TNotesStorage.getInstance();
		ArrayList<String> aList = new ArrayList<String>();

		aList.add("do chores");
		aList.add("2016-04-16");
		aList.add("15:00");
		aList.add("16:00");
		aList.add("every");
		aList.add("week");
		aList.add("for");
		aList.add("3");
		aList.add("week");

		TaskFile currentTask = cmdAdd.addTask(aList);
		assertEquals("2016-04-16", currentTask.getStartDate());
		assertEquals("do chores", currentTask.getName());
		assertEquals(" It recurs every week for 3 week", currentTask.getDetails());
		assertTrue(currentTask.getIsRecurring());
		assertFalse(currentTask.getImportance());

		ArrayList<String> dateList = new ArrayList<String>();
		ArrayList<String> endDateList = new ArrayList<String>();
		dateList.add("2016-04-16");
		dateList.add("2016-04-23");
		dateList.add("2016-04-30");

		endDateList.add("2016-04-16");
		endDateList.add("2016-04-23");
		endDateList.add("2016-04-30");

		assertEquals(dateList, storage.getRecurTaskStartDateList("do chores"));
		assertEquals(endDateList, storage.getRecurTaskEndDateList("do chores"));

	}@Test
	public void addRecurringTaskWeekTest2() throws Exception {
		TNotesStorage storage = TNotesStorage.getInstance();
		ArrayList<String> aList = new ArrayList<String>();

		aList.add("papaya");
		aList.add("2016-04-16");
		aList.add("15:00");
		aList.add("16:00");
		aList.add("every");
		aList.add("week");
		aList.add("for");
		aList.add("1");
		aList.add("month");

		TaskFile currentTask = cmdAdd.addTask(aList);

		ArrayList<String> dateList = new ArrayList<String>();
		ArrayList<String> endDateList = new ArrayList<String>();
		dateList.add("2016-04-16");
		dateList.add("2016-04-23");
		dateList.add("2016-04-30");
		dateList.add("2016-05-07");

		endDateList.add("2016-04-16");
		endDateList.add("2016-04-23");
		endDateList.add("2016-04-30");
		endDateList.add("2016-05-07");

		assertEquals(dateList, storage.getRecurTaskStartDateList("papaya"));
		assertEquals(endDateList, storage.getRecurTaskEndDateList("papaya"));

	}

	@Test
	public void addRecurringTaskFortNightTest() throws Exception {
		TNotesStorage storage = TNotesStorage.getInstance();
		ArrayList<String> aList = new ArrayList<String>();

		aList.add("go home");
		aList.add("2016-04-17");
		aList.add("14:00");
		aList.add("15:00");
		aList.add("every");
		aList.add("fortnight");
		aList.add("for");
		aList.add("2");
		aList.add("fortnight");

		TaskFile currentTask = cmdAdd.addTask(aList);
		assertEquals("2016-04-17", currentTask.getStartDate());
		assertEquals("go home", currentTask.getName());
		assertEquals(" It recurs every fortnight for 2 fortnight", currentTask.getDetails());
		assertTrue(currentTask.getIsRecurring());
		assertFalse(currentTask.getImportance());

		ArrayList<String> dateList = new ArrayList<String>();
		ArrayList<String> endDateList = new ArrayList<String>();

		dateList.add("2016-04-17");
		dateList.add("2016-05-01");

		endDateList.add("2016-04-17");
		endDateList.add("2016-05-01");

		assertEquals(dateList, storage.getRecurTaskStartDateList("go home"));
		assertEquals(endDateList, storage.getRecurTaskEndDateList("go home"));

	}
	@Test
	public void addRecurringTaskFortNightTest2() throws Exception {
		TNotesStorage storage = TNotesStorage.getInstance();
		ArrayList<String> aList = new ArrayList<String>();

		aList.add("home");
		aList.add("2016-04-17");
		aList.add("8:00am");
		aList.add("9:00am");
		aList.add("every");
		aList.add("fortnight");
		aList.add("for");
		aList.add("1");
		aList.add("month");

		TaskFile currentTask = cmdAdd.addTask(aList);

		ArrayList<String> dateList = new ArrayList<String>();
		ArrayList<String> endDateList = new ArrayList<String>();

		dateList.add("2016-04-17");
		dateList.add("2016-05-01");

		endDateList.add("2016-04-17");
		endDateList.add("2016-05-01");

		assertEquals(dateList, storage.getRecurTaskStartDateList("home"));
		assertEquals(endDateList, storage.getRecurTaskEndDateList("home"));

	}

	@Test
	public void addRecurringTaskMonthTest() throws Exception {
		TNotesStorage storage = TNotesStorage.getInstance();
		ArrayList<String> aList = new ArrayList<String>();

		aList.add("fly kite");
		aList.add("2016-04-18");
		aList.add("16:00");
		aList.add("18:00");
		aList.add("every");
		aList.add("month");
		aList.add("for");
		aList.add("3");
		aList.add("months");

		TaskFile currentTask = cmdAdd.addTask(aList);
		assertEquals("2016-04-18", currentTask.getStartDate());
		assertEquals("fly kite", currentTask.getName());
		assertEquals(" It recurs every month for 3 months", currentTask.getDetails());
		assertTrue(currentTask.getIsRecurring());
		assertFalse(currentTask.getImportance());

		ArrayList<String> dateList = new ArrayList<String>();
		ArrayList<String> endDateList = new ArrayList<String>();

		dateList.add("2016-04-18");
		dateList.add("2016-05-18");
		dateList.add("2016-06-18");

		endDateList.add("2016-04-18");
		endDateList.add("2016-05-18");
		endDateList.add("2016-06-18");

		assertEquals(dateList, storage.getRecurTaskStartDateList("fly kite"));
		assertEquals(endDateList, storage.getRecurTaskEndDateList("fly kite"));

	}

	@Test
	public void addRecurringTaskForDayTest() throws Exception {
		TNotesStorage storage = TNotesStorage.getInstance();
		ArrayList<String> aList = new ArrayList<String>();

		aList.add("attend tuition");
		aList.add("2016-04-15");
		aList.add("16:00");
		aList.add("18:00");
		aList.add("every");
		aList.add("day");

		TaskFile currentTask = cmdAdd.addTask(aList);
		assertEquals("2016-04-15", currentTask.getStartDate());
		assertEquals("attend tuition", currentTask.getName());
		assertEquals(" It recurs every day", currentTask.getDetails());
		assertTrue(currentTask.getIsRecurring());
		assertFalse(currentTask.getImportance());

		ArrayList<String> dateList = new ArrayList<String>();
		ArrayList<String> endDateList = new ArrayList<String>();
		dateList.add("2016-04-15");
		dateList.add("2016-04-16");
		dateList.add("2016-04-17");
		dateList.add("2016-04-18");
		dateList.add("2016-04-19");
		dateList.add("2016-04-20");
		dateList.add("2016-04-21");
		dateList.add("2016-04-22");
		dateList.add("2016-04-23");
		dateList.add("2016-04-24");
		dateList.add("2016-04-25");
		dateList.add("2016-04-26");

		endDateList.add("2016-04-15");
		endDateList.add("2016-04-16");
		endDateList.add("2016-04-17");
		endDateList.add("2016-04-18");
		endDateList.add("2016-04-19");
		endDateList.add("2016-04-20");
		endDateList.add("2016-04-21");
		endDateList.add("2016-04-22");
		endDateList.add("2016-04-23");
		endDateList.add("2016-04-24");
		endDateList.add("2016-04-25");
		endDateList.add("2016-04-26");

		assertEquals(dateList, storage.getRecurTaskStartDateList("attend tuition"));
		assertEquals(endDateList, storage.getRecurTaskEndDateList("attend tuition"));

	}
	
	private String compareDates(String dates) {
		Calendar cal = Calendar.getInstance();
		DateFormat shortForm = new SimpleDateFormat("EEE");
		String date = shortForm.format(cal.getTime()).toLowerCase();

		while (!dates.contains(date)) {
			cal.add(Calendar.DATE, 1);
			date = shortForm.format(cal.getTime()).toLowerCase();
		}
		return df.format(cal.getTime());
	}

}
```
###### \src\tnote\logic\CommandDelete.java
``` java
package tnote.logic;

import java.util.logging.Logger;
import tnote.util.log.TNoteLogger;

import java.io.FileNotFoundException;
import java.util.ArrayList;

import tnote.object.TaskFile;
import tnote.storage.TNotesStorage;

/**
 * This class maintains the logic of how a task is deleted based on a String
 * input containing the task name in an ArrayList
 * 
 * it determines whether the task to be deleted is recurring or not,calls
 * storage to delete the task before returning the deleted TaskFile object back
 * to UI
 * 
 * @author A0124697U
 *
 */
public class CommandDelete {
	private static final int INDEX_TWO = 2;

	private TNotesStorage storage;

	private static final String MESSAGE_LOG_ERROR = "Warning";
	private static final String MESSAGE_INVALID_COMMAND = "invalid command";

	private static final Logger logger = Logger.getGlobal();

	protected CommandDelete() throws Exception {
		storage = TNotesStorage.getInstance();
	}

	/**
	 * Method to determine if deleting a recurring task or a normal task
	 * 
	 * @param fromParser
	 *            - ArrayList of String inputs from parser
	 * @return - TaskFile object that was deleted
	 * @throws Exception
	 */
	protected TaskFile delete(ArrayList<String> fromParser) throws Exception {
		TaskFile deletedTask = storage.getTaskFileByName(fromParser.get(0));
		if (deletedTask.getIsRecurring()) {
			return deleteRecurringTask(fromParser);
		} else {
			return deleteTask(fromParser);
		}
	}

	/**
	 * 
	 * @param fromParser
	 *            - the sorted inputs from the user
	 * @return - returns the deleted task, else returns null
	 * @throws Exception
	 */
	protected TaskFile deleteTask(ArrayList<String> fromParser) throws Exception {
	
		TaskFile taskToDelete = storage.getTaskFileByName(fromParser.get(0));

		if (taskToDelete.getIsRecurring()) {
			return deleteRecurringTask(fromParser);
		} else {
			TaskFile taskDeleted = storage.deleteTask(fromParser.get(0));
			if (taskDeleted != null) {
				return taskDeleted;
			} else {
				logger.warning(MESSAGE_LOG_ERROR);
				return null;
			}
		}
	}

	/**
	 * Method for deleting recurring task, called by a recurring flag check in
	 * delete task method
	 * 
	 * @param fromParser
	 *            - the sorted inputs from the user
	 * @return - returns the deleted task , or null
	 * @throws Exception
	 */
	protected TaskFile deleteRecurringTask(ArrayList<String> fromParser) throws Exception {
	
		TaskFile deletedTask = storage.deleteRecurringTask(fromParser.get(0));
		if (deletedTask != null) {
			return deletedTask;
		} else {
			logger.warning(MESSAGE_LOG_ERROR);
			return null;
		}
	}
}
```
###### \src\tnote\logic\CommandDeleteTest.java
``` java
package tnote.logic;

import static org.junit.Assert.*;

import java.io.FileNotFoundException;
import java.util.ArrayList;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import tnote.object.TaskFile;
import tnote.storage.TNotesStorage;

public class CommandDeleteTest {
	CommandAdd cmdAdd;
	CommandDelete cmdDel;

	@Before
	public void setUp() throws Exception {
		cmdDel = new CommandDelete();
		cmdAdd = new CommandAdd();
	}

	@After
	public void tearDown() throws Exception {
		TNotesStorage storage = TNotesStorage.getInstance();
		System.out.println(storage.clearFiles());
	}

	@Test
	public void deleteTask() throws Exception {
		ArrayList<String> aList = new ArrayList<String>();

		aList.add("banana");
		TaskFile addTask = cmdAdd.addTask(aList);
		
		aList.add("banana");
		TaskFile currentTask = cmdDel.delete(aList);

		assertEquals(addTask.getName(), currentTask.getName());
	}

	@Test
	public void deleteRecurring() throws Exception {
		ArrayList<String> aList = new ArrayList<String>();
		aList.add("attend tuition");
		aList.add("15-4-2016");
		aList.add("11:00am");
		aList.add("every");
		aList.add("day");

		TaskFile addTask = cmdAdd.addTask(aList);
		TaskFile currentTask = new TaskFile();
		aList.clear();
		aList.add("attend tuition");
		currentTask = cmdDel.delete(aList);
		assertEquals("15-4-2016", currentTask.getStartDate());
		assertEquals("11:00am", currentTask.getStartTime());
		assertTrue(currentTask.getIsRecurring());

	
	}
}
```
###### \src\tnote\logic\CommandEdit.java
``` java
package tnote.logic;

import java.util.logging.Logger;
import tnote.util.log.TNoteLogger;

import java.util.ArrayList;

import tnote.object.RecurringTaskFile;
import tnote.object.TaskFile;
import tnote.storage.TNotesStorage;

/**
 * This class maintains the logic of how a task is edited based on sorted String
 * inputs in an ArrayList, giving the name and what is to be edited
 * 
 * It differentiates between recurring task and non recurring task, and modifies
 * it based on the provided information
 * 
 * It calls storage to modify the information, returns the modified Task
 * 
 * @author A0124697U
 *
 */
public class CommandEdit {
	private static final int INDEX_TWO = 2;
	private static final int INDEX_ZERO = 0;
	private static final int INDEX_ONE = 1;

	private static final String STRING_YES = "yes";
	private static final String EDIT_TYPE_IMPORTANCE = "importance";
	private static final String EDIT_TYPE_IMPORTANT = "important";
	private static final String EDIT_TYPE_DETAILS = "details";
	private static final String EDIT_TYPE_ENDATE = "endDate";
	private static final String EDIT_TYPE_STARTDATE = "startDate";
	private static final String EDIT_TYPE_DATE = "date";
	private static final String EDIT_TYPE_ENDTIME = "endTime";
	private static final String EDIT_TYPE_STARTIME = "startTime";
	private static final String EDIT_TYPE_TIME = "time";
	private static final String EDIT_TYPE_NAME = "name";
	private static final String EDIT_TYPE_ADD_FAIL = "did not manage to add to storage";
	private static final String EDIT_TYPE_EDIT_FAIL = "did not edit";

	private static final String MESSAGE_LOG_ERROR = "Warning";

	private static final Logger logger = Logger.getGlobal();

	private TNotesStorage storage;

	protected CommandEdit() throws Exception {
		storage = TNotesStorage.getInstance();
	}

	/**
	 * Method to determine whether the task to be edited is a recurring task or
	 * a normal one
	 * 
	 * @param fromParser
	 *            - ArrayList of sorted inputs from Parser
	 * @return - TaskFile that was edited
	 * @throws Exception
	 */
	protected TaskFile edit(ArrayList<String> fromParser) throws Exception {
		TaskFile currentTask = storage.getTaskFileByName(fromParser.get(INDEX_ZERO).trim());

		if (currentTask.getIsRecurring()) {
			currentTask = editRecurringTask(fromParser);
		} else {
			currentTask = editTask(fromParser);
		}
		return currentTask;
	}

	/**
	 * Method to edit the task according to the the type of edit denoted
	 * 
	 * @param fromParser
	 *            - ArrayList of inputs, determining whats the type, the task
	 *            and what changes
	 * @return - the TaskFile object that was amended
	 * @throws Exception
	 */
	protected TaskFile editTask(ArrayList<String> fromParser) throws Exception {

		String type = fromParser.get(INDEX_ONE).trim();
		String title = fromParser.get(INDEX_ZERO).trim();
		String newText = fromParser.get(INDEX_TWO).trim();
		TaskFile oldFile = storage.getTaskFileByName(title);
		TaskFile currentFile = new TaskFile(oldFile);

		logger.info(fromParser.toString());

		if (currentFile.getIsRecurring()) {
			editRecurringTask(fromParser);

		} else if (type.equals(EDIT_TYPE_NAME)) {
			storage.deleteTask(title);
			currentFile.setName(newText);

			if (storage.addTask(currentFile)) {
				return currentFile;
			} else {
				System.out.println(EDIT_TYPE_ADD_FAIL);
			}
		} else if (type.equals(EDIT_TYPE_TIME) || type.equals(EDIT_TYPE_STARTIME)) {
			storage.deleteTask(title);
			currentFile.setStartTime(newText);
			currentFile.setUpTaskFile();
			if (storage.addTask(currentFile)) {
				return currentFile;
			} else {
				System.out.println(EDIT_TYPE_ADD_FAIL);
			}
		} else if (type.equals(EDIT_TYPE_ENDTIME)) {
			storage.deleteTask(title);
			currentFile.setEndTime(newText);
			currentFile.setUpTaskFile();
			if (storage.addTask(currentFile)) {
				return currentFile;
			} else {
				System.out.println(EDIT_TYPE_ADD_FAIL);
			}
		} else if (type.equals(EDIT_TYPE_DATE) || type.equals(EDIT_TYPE_STARTDATE)) {
			storage.deleteTask(title);
			currentFile.setStartDate(newText);
			if (storage.addTask(currentFile)) {
				return currentFile;
			} else {
				System.out.println(EDIT_TYPE_ADD_FAIL);
			}
		} else if (type.equals(EDIT_TYPE_ENDATE)) {
			storage.deleteTask(title);
			currentFile.setEndDate(newText);
			if (storage.addTask(currentFile)) {
				return currentFile;
			} else {
				System.out.println(EDIT_TYPE_ADD_FAIL);
			}
		} else if (type.equals(EDIT_TYPE_DETAILS)) {
			storage.deleteTask(title);
			currentFile.setDetails(newText);
			if (storage.addTask(currentFile)) {
				return currentFile;
			} else {
				System.out.println(EDIT_TYPE_ADD_FAIL);
			}
		} else if (type.equals(EDIT_TYPE_IMPORTANT) || type.equals(EDIT_TYPE_IMPORTANCE)) {
			storage.deleteTask(title);
			if (newText.equals(STRING_YES)) {
				currentFile.setImportance(true);
			} else {
				currentFile.setImportance(false);
			}
			if (storage.addTask(currentFile)) {
				return currentFile;
			} else {
				System.out.println(EDIT_TYPE_ADD_FAIL);
			}
		} else {
			System.out.println(EDIT_TYPE_EDIT_FAIL);
		}
		return currentFile;

	}

	/**
	 * Method for editing recurring Task, called by edit through a recurring
	 * flag check.
	 * 
	 * @param fromParser
	 *            - ArrayList of inputs, determining whats the type, the task
	 *            and what changes
	 * @return - the edited TaskFile object
	 * @throws Exception
	 */
	protected TaskFile editRecurringTask(ArrayList<String> fromParser) throws Exception {
		String type = fromParser.get(INDEX_ONE).trim();
		String title = fromParser.get(INDEX_ZERO).trim();
		String newText = fromParser.get(INDEX_TWO).trim();
		TaskFile oldFile = storage.getTaskFileByName(title);
		TaskFile currentFile = new TaskFile(oldFile);
		RecurringTaskFile recurTask = new RecurringTaskFile(currentFile);
		RecurringTaskFile recurTask1 = new RecurringTaskFile(currentFile);
		ArrayList<String> dateList = storage.getRecurTaskStartDateList(title);
		ArrayList<String> endDateList = new ArrayList<String>();
		recurTask.addRecurringStartDate(dateList);

		logger.info(fromParser.toString());

		if (currentFile.getIsMeeting()) {
			endDateList = storage.getRecurTaskEndDateList(title);
			recurTask.addRecurringEndDate(endDateList);
			recurTask1.addRecurringEndDate(endDateList);
		}

		if (type.equals(EDIT_TYPE_NAME)) {
			storage.deleteRecurringTask(title);
			recurTask.setName(newText);
			recurTask1.setName(newText);
			if (storage.addRecurringTask(recurTask)) {
				return recurTask1;
			} else {
				System.out.println(EDIT_TYPE_ADD_FAIL);
			}
		} else if (type.equals(EDIT_TYPE_TIME)) {
			storage.deleteRecurringTask(title);
			recurTask.setStartTime(newText);
			recurTask1.setStartTime(newText);

			if (storage.addRecurringTask(recurTask)) {
				return recurTask1;
			} else {
				logger.warning(MESSAGE_LOG_ERROR);
				throw new Exception(EDIT_TYPE_ADD_FAIL);
			}
		} else if (type.equals(EDIT_TYPE_STARTIME)) {
			storage.deleteRecurringTask(title);
			recurTask.setStartTime(newText);
			recurTask1.setStartTime(newText);

			if (storage.addRecurringTask(recurTask)) {
				return recurTask1;
			} else {
				logger.warning(MESSAGE_LOG_ERROR);
				throw new Exception(EDIT_TYPE_ADD_FAIL);
			}
		} else if (type.equals(EDIT_TYPE_ENDTIME)) {
			storage.deleteRecurringTask(title);
			recurTask.setEndTime(newText);
			recurTask1.setEndTime(newText);
			if (storage.addRecurringTask(recurTask)) {
				return recurTask1;
			} else {
				logger.warning(MESSAGE_LOG_ERROR);
				throw new Exception(EDIT_TYPE_ADD_FAIL);
			}
		} else if (type.equals(EDIT_TYPE_STARTDATE)) {
			storage.deleteRecurringTask(title);
			recurTask.setStartDate(newText);
			recurTask1.setStartDate(newText);
			if (storage.addRecurringTask(recurTask)) {
				return recurTask1;
			} else {
				logger.warning(MESSAGE_LOG_ERROR);
				throw new Exception(EDIT_TYPE_ADD_FAIL);
			}
		} else if (type.equals(EDIT_TYPE_ENDATE)) {
			storage.deleteRecurringTask(title);
			recurTask.setEndDate(newText);
			recurTask1.setEndDate(newText);
			if (storage.addRecurringTask(recurTask)) {
				return recurTask1;
			} else {
				logger.warning(MESSAGE_LOG_ERROR);
				throw new Exception(EDIT_TYPE_ADD_FAIL);
			}
		} else if (type.equals(EDIT_TYPE_DETAILS)) {
			storage.deleteRecurringTask(title);
			recurTask.setDetails(newText);
			recurTask1.setDetails(newText);
			if (storage.addRecurringTask(recurTask)) {
				return recurTask1;
			} else {
				logger.warning(MESSAGE_LOG_ERROR);
				throw new Exception(EDIT_TYPE_ADD_FAIL);
			}
		} else if (type.equals(EDIT_TYPE_IMPORTANT)) {
			storage.deleteRecurringTask(title);
			if (newText.equals(STRING_YES)) {
				recurTask.setImportance(true);
				recurTask1.setImportance(true);
			} else {
				recurTask.setImportance(false);
				recurTask1.setImportance(false);
			}
			if (storage.addRecurringTask(recurTask)) {
				return recurTask1;
			}
		} else
			throw new Exception(EDIT_TYPE_EDIT_FAIL);
		return recurTask1;
	}
}
```
###### \src\tnote\logic\CommandEditTest.java
``` java
package tnote.logic;

import static org.junit.Assert.*;

import java.util.ArrayList;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.Test;

import tnote.object.TaskFile;
import tnote.storage.TNotesStorage;

public class CommandEditTest {
	TNotesStorage storage;
	CommandEdit cmdEdit;
	CommandAdd cmdAdd;

	@Before
	public void setUp() throws Exception {
		storage = TNotesStorage.getInstance();
		cmdEdit = new CommandEdit();
		cmdAdd = new CommandAdd();
		storage.setUpStorage();
	}

	@After
	public void tearDown() throws Exception {
		TNotesStorage storage = TNotesStorage.getInstance();
		System.out.println(storage.clearFiles());
	}

	@Test
	public void editTaskTest() throws Exception {
		ArrayList<String> aList = new ArrayList<String>();
		ArrayList<String> bList = new ArrayList<String>();

		aList.add("write report");
		aList.add("today");
		aList.add("22:00pm");
		aList.add("details");
		aList.add("write about feelings");

		bList.add("write report");
		bList.add("name");
		bList.add("homework");

		TaskFile addTask = cmdAdd.addTask(aList);
		TaskFile editTask = cmdEdit.edit(bList);

		assertNotEquals(addTask.getName(), editTask.getName());
		assertEquals(addTask.getDetails(), editTask.getDetails());
		assertEquals(addTask.getStartTime(), editTask.getStartTime());
		assertEquals(addTask.getStartDate(), editTask.getStartDate());

		bList.clear();

		bList.add("homework");
		bList.add("details");
		bList.add("chemistry");
		
		editTask = cmdEdit.edit(bList);

		assertNotEquals(addTask.getDetails(), editTask.getDetails());
	}

	@Test
	public void editRecurringTaskTest() throws Exception {
		ArrayList<String> aList = new ArrayList<String>();
		ArrayList<String> bList = new ArrayList<String>();
		ArrayList<String> cList = new ArrayList<String>();

		aList.add("see doctor");
		aList.add("today");
		aList.add("20:00");
		aList.add("22:00");
		aList.add("every");
		aList.add("week");
		aList.add("for");
		aList.add("2");
		aList.add("weeks");

		bList.add("see doctor");
		bList.add("startTime");
		bList.add("21:00");

		TaskFile addTask = cmdAdd.addTask(aList);
		TaskFile editTask = cmdEdit.edit(bList);

		assertNotEquals(addTask.getStartTime(), editTask.getStartTime());
		assertEquals(addTask.getDetails(), editTask.getDetails());
		assertEquals(addTask.getStartDate(), editTask.getStartDate());;

		cList.add("see doctor");
		cList.add("endDate");
		cList.add("23:00pm");
		
		 editTask = cmdEdit.edit(cList);

		assertNotEquals(addTask.getEndDate(), editTask.getEndDate());
	}
	
}
```
###### \src\tnote\logic\CommandSearch.java
``` java
package tnote.logic;

import static org.junit.Assert.assertTrue;

import java.util.ArrayList;
import java.util.logging.Logger;

import tnote.object.TaskFile;
import tnote.storage.TNotesStorage;

/**
 * This class maintains the logic of how tasks are searched for based on String
 * inputs in an ArrayList
 * 
 * It searches for task with the same name or containing the letter and/or
 * phrase within the task name and returns the TaskFile object back
 * 
 * @author A0124697U
 *
 */
public class CommandSearch {

	private static final String ELEMENT_NOT_FOUND = "No element found";

	private static final int START_OF_STRING = 0;
	private static final int ARRAYLIST_INDEX = 1;

	private static final String STRING_UNDERSCORE = "_";

	private TNotesStorage storage;

	private static final Logger logger = Logger.getGlobal();

	protected CommandSearch() throws Exception {
		storage = TNotesStorage.getInstance();
	}

	/**
	 * Method to return a single task to view for UI
	 * 
	 * @param lineOfText
	 *            - name of the task
	 * @return - the task file object with the name of the parameter.
	 * @throws Exception
	 */
	protected TaskFile searchSingleTask(String lineOfText) throws Exception {

		ArrayList<String> masterList = storage.readFromMasterFile();
		TaskFile oldTask = new TaskFile();

		for (String text : masterList) {
			if (text.equals(lineOfText.trim())) {
				oldTask = storage.getTaskFileByName(text);
			}
		}
		return oldTask;
	}

	/**
	 * Method that searches for task that either contain the letter or phrase.
	 * Up to two search items can be entered
	 * 
	 * @param lineOfText
	 *            - name of the task
	 * @return - the task file objects that either contain the phrases, or start
	 *         with the letters
	 * @throws Exception
	 */
	protected ArrayList<TaskFile> searchTask(ArrayList<String> lineOfText) throws Exception {

		logger.info(lineOfText.toString());

		ArrayList<TaskFile> searchTaskList = new ArrayList<TaskFile>();
		ArrayList<String> masterList = storage.readFromMasterFile();

		for (int i = 0; i < lineOfText.size(); i++) {
			if (lineOfText.size() == ARRAYLIST_INDEX) {
				for (String text : masterList) {
					if (text.contains(lineOfText.get(i))) {
						searchTaskList.add(storage.getTaskFileByName(text));
					}
				}

			} else {
				if (lineOfText.get(i).length() < ARRAYLIST_INDEX) {
					logger.warning(ELEMENT_NOT_FOUND);
					throw new Exception(ELEMENT_NOT_FOUND);

				} else if (lineOfText.get(i).length() == ARRAYLIST_INDEX) {
					for (String text : masterList) {
						if (text.startsWith(lineOfText.get(i))) {
							TaskFile searchedTask = storage.getTaskFileByName(text);

							if (!searchTaskList.contains(searchedTask) && !searchedTask.getIsRecurring()) {
								searchTaskList.add(searchedTask);
							}
						}
					}
				} else {
					for (String text : masterList) {
						if (text.contains(lineOfText.get(i))) {
							TaskFile searchedTask = storage.getTaskFileByName(text);

							if (!searchTaskList.contains(searchedTask) && !searchedTask.getIsRecurring()) {
								searchTaskList.add(searchedTask);
							}
						}
					}
				}
			}
		}
		for (TaskFile newTask : searchTaskList) {
			if (newTask.getName().contains(STRING_UNDERSCORE)) {

				assertTrue(newTask.getName().contains(STRING_UNDERSCORE));

				String formatterName = newTask.getName().substring(START_OF_STRING,
						newTask.getName().indexOf(STRING_UNDERSCORE));
				newTask.setName(formatterName);
			}

			System.out.println(newTask.getName());

		}
		return searchTaskList;
	}
}
```
###### \src\tnote\logic\CommandSearchTest.java
``` java
package tnote.logic;

import static org.junit.Assert.*;

import java.util.ArrayList;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import tnote.object.TaskFile;
import tnote.storage.TNotesStorage;

public class CommandSearchTest {
	TNotesStorage storage;
	CommandAdd cmdAdd;
	CommandSearch cmdSearch;

	@Before
	public void setUp() throws Exception {
		storage = TNotesStorage.getInstance();
		cmdSearch = new CommandSearch();
		cmdAdd = new CommandAdd();
		storage.setUpStorage();
	}

	@After
	public void tearDown() throws Exception {
		TNotesStorage storage = TNotesStorage.getInstance();
		System.out.println(storage.clearFiles());
	}

	@Test
	public void searchTaskTest() throws Exception {
		ArrayList<String> aList = new ArrayList<String>();
		ArrayList<String> bList = new ArrayList<String>();
		ArrayList<String> cList = new ArrayList<String>();

		aList.add("write report");
		aList.add("today");
		aList.add("22:00pm");

		bList.add("report");
		bList.add("today");
		bList.add("23:00pm");

		cList.add("report");

		TaskFile firstTask = cmdAdd.addTask(aList);
		TaskFile secondTask = cmdAdd.addTask(bList);
		firstTask = cmdSearch.searchSingleTask(secondTask.getName());

		assertEquals(secondTask.getName(), firstTask.getName());
		
		ArrayList<TaskFile> taskList = cmdSearch.searchTask(cList);
		
		assertEquals(cList.get(0), taskList.get(1).getName());

	}

	@Test
	public void searchTaskTest2() throws Exception {
		ArrayList<String> aList = new ArrayList<String>();
		ArrayList<String> bList = new ArrayList<String>();
		ArrayList<String> cList = new ArrayList<String>();

		aList.add("banana");
		aList.add("today");
		aList.add("22:00pm");
		aList.add("every");
		aList.add("day");
		aList.add("for");
		aList.add("3");
		aList.add("day");

		bList.add("potato");
		bList.add("today");
		bList.add("23:00pm");

		cList.add("banana");
		cList.add("tato");
		cList.add("r");

		TaskFile firstTask = cmdAdd.addTask(aList);
		TaskFile secondTask = cmdAdd.addTask(bList);
		
		ArrayList<TaskFile> taskList = cmdSearch.searchTask(cList);
		
		assertEquals(cList.get(0), taskList.get(0).getName());
		assertEquals("banana", taskList.get(1).getName());

	}
}
```
###### \src\tnote\logic\CommandView.java
``` java
package tnote.logic;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.logging.Logger;

import tnote.object.TaskFile;
import tnote.storage.TNotesStorage;

/**
 * This class maintains the logic of how various task are viewed on the GUI
 * 
 * It filters out task according to their own information and returns a list of
 * tasks with the same information
 * 
 * @author A0124697U
 *
 */
public class CommandView {
	private static final int INDEX_THREE = 3;
	private static final String TOMORROW = "tomorrow";
	private static final int INDEX_ZERO = 0;
	private static final int INDEX_ONE = 1;
	private static final int INDEX_TWO = 2;
	private static final String NUMBERS = "[0-9]+";

	private static final String HISTROY = "history";

	private static final String STRING_UNDERSCORE = "_";
	private static final String STRING_DASH = "-";

	private static final String TYPE_IS_VIEW_TASK = "isViewTask";
	private static final String TYPE_IS_VIEW_HISTORY = "isViewHistory";
	private static final String TYPE_IS_VIEW_INDEX = "isViewIndex";
	private static final String TYPE_IS_VIEW_NOTES = "isViewNotes";
	private static final String TYPE_IS_VIEW_MANY_LIST = "isViewManyList";
	private static final String TYPE_IS_VIEW_DATE_LIST = "isViewDateList";
	private static final String STRING_FLOATING = "notes";

	private static final String SUNDAY = "sunday";
	private static final String SATURDAY = "saturday";
	private static final String FRIDAY = "friday";
	private static final String THURSDAY = "thursday";
	private static final String WEDNESDAY = "wednesday";
	private static final String TUESDAY = "tuesday";
	private static final String MONDAY = "monday";
	private static final String TODAY = "today";

	private TNotesStorage storage;

	private static final String PARSER_DATE_FORMAT = "yyyy-MM-dd";
	private static final String DAY_SHORTFORM = "EEE";

	private DateFormat df = new SimpleDateFormat(PARSER_DATE_FORMAT);
	private static final Logger logger = Logger.getGlobal();

	protected CommandView() throws Exception {
		storage = TNotesStorage.getInstance();
	}

	/**
	 * Method that creates a TaskFile object from a variation of inputs and adds
	 * it to storage.
	 * 
	 * @param dates
	 *            - a specific day, Monday,Tuesday, etc
	 * @return - a string of the day in DD-MM-YYYY
	 */
	private String compareDates(String dates) {
		Calendar cal = Calendar.getInstance();
		DateFormat shortForm = new SimpleDateFormat(DAY_SHORTFORM);
		String date = shortForm.format(cal.getTime()).toLowerCase();

		while (!dates.contains(date)) {
			cal.add(Calendar.DATE, INDEX_ONE);
			date = shortForm.format(cal.getTime()).toLowerCase();
		}
		logger.info(date);
		return df.format(cal.getTime());
	}

	/**
	 * Method checks if the string matches any number
	 * 
	 * @param nextString
	 *            - the String which contains number
	 * @return - True if the string holds numbers, false if it does not
	 */
	private boolean isLetters(String nextString) {
		if (!nextString.matches(NUMBERS)) {
			return true;
		} else {
			return false;
		}
	}

	/**
	 * Method sorts which view is being called, and add the view type as a
	 * string to the ArrayList
	 * 
	 * @param fromParser
	 *            - the sorted inputs from the user
	 * 
	 * @return - the inputs with an additional keyword to determine the type of
	 *         view.
	 */
	protected ArrayList<String> sortViewTypes(ArrayList<String> fromParser) {
		ArrayList<String> stringList = new ArrayList<String>();
		String viewType = fromParser.get(INDEX_ONE);

		if (fromParser.size() == INDEX_THREE) {
			stringList.add(TYPE_IS_VIEW_MANY_LIST);

		} else if (viewType.contains(STRING_DASH) || viewType.contains(TODAY)
				|| (viewType.contains(MONDAY) || (viewType.contains(TUESDAY)) || (viewType.contains(WEDNESDAY))
						|| (viewType.contains(THURSDAY)) || (viewType.contains(FRIDAY)) || (viewType.contains(SATURDAY))
						|| (viewType.contains(SUNDAY)))) {
			stringList.add(TYPE_IS_VIEW_DATE_LIST);

		} else if (viewType.contains(STRING_FLOATING)) {
			stringList.add(TYPE_IS_VIEW_NOTES);

		} else if (!isLetters(viewType)) {
			stringList.add(TYPE_IS_VIEW_INDEX);

		} else if (viewType.contains(HISTROY)) {
			stringList.add(TYPE_IS_VIEW_HISTORY);

		} else {
			stringList.add(TYPE_IS_VIEW_TASK);
		}
		return stringList;
	}

	/**
	 * Method to view the details of a specific task
	 * 
	 * @param taskToBeDisplayed
	 *            -String containing name of the task to be displayed
	 * @return - returns the task with the same name, else returns null
	 * @throws Exception
	 */
	protected TaskFile viewTask(String taskToBeDisplayed) throws Exception {
		ArrayList<String> stringList = storage.readFromMasterFile();

		for (String text : stringList) {
			TaskFile currentFile = storage.getTaskFileByName(text);

			if (currentFile.getName().equals(taskToBeDisplayed.trim())) {
				return currentFile;
			}
		}
		return null;
	}

	/**
	 * Method to view a list of task that are set as completed
	 * 
	 * @return - an ArrayList of TaskFiles that are done
	 * @throws Exception
	 */
	protected ArrayList<TaskFile> viewDoneList() throws Exception {
		ArrayList<String> nameList = new ArrayList<String>();
		ArrayList<TaskFile> doneList = new ArrayList<TaskFile>();
		nameList = storage.readFromMasterFile();

		for (String text : nameList) {
			TaskFile newTask = storage.getTaskFileByName(text);
			if (newTask.getIsDone()) {

				doneList.add(newTask);
			}
		}
		return doneList;
	}

	/**
	 * Method to view a list of task over a period of dates
	 * 
	 * @param dates
	 *            - ArrayList consisting of the start date and end date
	 * @return - ArrayList of TaskFiles over the dates
	 * @throws Exception
	 */
	protected ArrayList<TaskFile> viewManyDatesList(ArrayList<String> dates) throws Exception {
		Date startDate;
		Date endDate;
		Calendar cal = Calendar.getInstance();

		ArrayList<String> stringList = storage.readFromMasterFile();
		ArrayList<Date> listOfDates = new ArrayList<Date>();
		ArrayList<TaskFile> taskListToBeDisplayed = new ArrayList<TaskFile>();

		startDate = df.parse(dates.get(INDEX_ONE));
		endDate = df.parse(dates.get(INDEX_TWO));
		listOfDates.add(startDate);
		cal.setTime(startDate);

		while (!startDate.equals(endDate)) {
			cal.add(Calendar.DATE, INDEX_ONE);
			startDate = cal.getTime();
			listOfDates.add(startDate);
		}
		for (Date date : listOfDates) {
			String dateString = df.format(date);

			for (String text : stringList) {
				TaskFile currentFile = storage.getTaskFileByName(text);

				if (currentFile.getIsRecurring() || currentFile.getIsDone()) {
					continue;
				}
				if (currentFile.getStartDate().equals(dateString.trim())) {
					String name = currentFile.getName();

					if (name.contains(STRING_UNDERSCORE)) {
						String formatterName = name.substring(INDEX_ZERO, name.indexOf(STRING_UNDERSCORE));
						currentFile.setName(formatterName);
						assertFalse(currentFile.getName().contains(STRING_UNDERSCORE));
					}
					taskListToBeDisplayed.add(currentFile);
				}
			}
		}

		Collections.sort(taskListToBeDisplayed);
		return taskListToBeDisplayed;
	}

	/**
	 * Method to view the a list of tasks on a specific day or date
	 * 
	 * @param date
	 *            - a specific date,DD-MM-YYYY, or a day, MONDAY, or Today
	 * @return - ArrayList of TaskFiles with the same dates as the date input
	 * @throws Exception
	 */
	protected ArrayList<TaskFile> viewDateList(String date) throws Exception {
		if (date.trim().equals(TODAY)) {
			Calendar cal = Calendar.getInstance();
			String today = df.format(cal.getTime());
			date = today;
		}
		if (date.trim().equals(TOMORROW)) {
			Calendar cal = Calendar.getInstance();
			cal.add(Calendar.DATE, INDEX_ONE);
			String today = df.format(cal.getTime());
			date = today;

		}
		if (date.equals(MONDAY) || (date.equals(TUESDAY)) || (date.equals(WEDNESDAY)) || (date.equals(THURSDAY))
				|| (date.equals(FRIDAY)) || (date.equals(SATURDAY)) || (date.equals(SUNDAY))) {
			String whichDay = compareDates(date);
			date = whichDay;
		}
		ArrayList<String> stringList = storage.readFromMasterFile();
		ArrayList<TaskFile> taskListToBeDisplayed = new ArrayList<TaskFile>();
		for (String text : stringList) {
			TaskFile currentFile = storage.getTaskFileByName(text);

			if (currentFile.getIsRecurring() || currentFile.getIsDone()) {
				continue;
			}
			if (currentFile.getStartDate().equals(date.trim()) || currentFile.getEndDate().equals(date.trim())) {
				String name = currentFile.getName();

				if (name.contains(STRING_UNDERSCORE)) {
					String formatterName = name.substring(INDEX_ZERO, name.indexOf(STRING_UNDERSCORE));
					currentFile.setName(formatterName);
					assertFalse(currentFile.getName().contains(STRING_UNDERSCORE));
				}
				taskListToBeDisplayed.add(currentFile);
			}
		}
		Collections.sort(taskListToBeDisplayed);
		return taskListToBeDisplayed;
	}

	/**
	 * Method to view list of floating task, notes
	 * 
	 * @return - ArrayList of TaskFiles which are floating
	 * @throws Exception
	 */
	protected ArrayList<TaskFile> viewFloatingList() throws Exception {
		ArrayList<String> stringList = storage.readFromFloatingFile();
		ArrayList<TaskFile> taskListToBeDisplayed = new ArrayList<TaskFile>();

		for (String text : stringList) {
			TaskFile currentFile = storage.getTaskFileByName(text);

			if (currentFile.getIsTask() && !currentFile.getIsDone()) {
				taskListToBeDisplayed.add(currentFile);
			}
		}
		Collections.sort(taskListToBeDisplayed);
		return taskListToBeDisplayed;
	}

	/**
	 * Method to view task that are pass their deadline
	 * 
	 * @return - ArrayList of TaskFiles which have passed their deadline
	 * @throws Exception
	 */
	protected ArrayList<TaskFile> callOverdueTasks() throws Exception {
		ArrayList<TaskFile> listOfOverdueTasks = storage.retrieveOverdueTasks();

		for (TaskFile newTask : listOfOverdueTasks) {
			if (newTask.getName().contains(STRING_UNDERSCORE)) {
				String formatterName = newTask.getName().substring(INDEX_ZERO,
						newTask.getName().indexOf(STRING_UNDERSCORE));
				newTask.setName(formatterName);
				assertFalse(newTask.getName().contains(STRING_UNDERSCORE));
			}
		}
		Collections.sort(listOfOverdueTasks);
		return listOfOverdueTasks;
	}

}
```
###### \src\tnote\logic\CommandViewTest.java
``` java
package tnote.logic;

import static org.junit.Assert.*;

import java.util.ArrayList;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import tnote.object.TaskFile;
import tnote.storage.TNotesStorage;

public class CommandViewTest {
	TNotesStorage storage;
	CommandDelete cmdDel;
	CommandAdd cmdAdd;
	CommandView cmdView;

	@Before
	public void setUp() throws Exception {
		TNotesStorage storage = TNotesStorage.getInstance();
		cmdDel = new CommandDelete();
		cmdAdd = new CommandAdd();
		cmdView = new CommandView();
		storage.setUpStorage();
	}

	@After
	public void tearDown() throws Exception {
		TNotesStorage storage = TNotesStorage.getInstance();
		System.out.println(storage.clearFiles());
	}

	@Test
	public void viewFloatingTest() throws Exception {
		ArrayList<String> aList = new ArrayList<String>();

		aList.add("Chemistry Test");

		TaskFile currentTask = cmdAdd.addTask(aList);
		TaskFile checkTask = new TaskFile("Chemistry Test");
		ArrayList<TaskFile> taskList = cmdView.viewFloatingList();

		assertEquals(checkTask, taskList.get(0));
	}

	@Test
	public void viewOverdueTest() throws Exception {
		ArrayList<String> aList = new ArrayList<String>();

		aList.add("Chemistry Test");
		aList.add("2016-04-10");
		aList.add("14:00");

		String date = aList.get(1);
		String time = aList.get(2);
		TaskFile currentTask = cmdAdd.addTask(aList);
		TaskFile checkTask = new TaskFile("Chemistry Test");
		checkTask.setStartDate(date);
		checkTask.setStartTime(time);
		ArrayList<TaskFile> taskList = cmdView.callOverdueTasks();

		assertEquals(checkTask, taskList.get(0));
	}

	@Test
	public void viewDateTest() throws Exception {
		ArrayList<String> aList = new ArrayList<String>();

		aList.add("Chemistry Test");
		aList.add("10-4-2016");
		aList.add("14:00");

		String date = aList.get(1);
		String time = aList.get(2);
		TaskFile currentTask = cmdAdd.addTask(aList);
		TaskFile checkTask = new TaskFile("Chemistry Test");
		checkTask.setStartDate(date);
		checkTask.setStartTime(time);
		ArrayList<TaskFile> taskList = cmdView.viewDateList(date);

		assertEquals(checkTask, taskList.get(0));
	}

	@Test
	public void viewManyDatesTest() throws Exception {
		ArrayList<String> aList = new ArrayList<String>();
		ArrayList<String> bList = new ArrayList<String>();
		ArrayList<String> cList = new ArrayList<String>();

		aList.add("Chemistry Test");
		aList.add("2016-04-10");
		aList.add("14:00");

		bList.add("puree");
		bList.add("2016-04-11");
		bList.add("15:00");
		
		cList.add("banana");
		cList.add("2016-04-12");
		cList.add("22:00pm");
		cList.add("every");
		cList.add("day");
		cList.add("for");
		cList.add("3");
		cList.add("day");

		String date = aList.get(1);
		String time = aList.get(2);
		String date2 = bList.get(1);
		String date3 = cList.get(1);
		TaskFile currentTask = cmdAdd.addTask(aList);
		TaskFile secondTask = cmdAdd.addTask(bList);
		TaskFile thirdTask = cmdAdd.addTask(cList);
		TaskFile checkTask = new TaskFile("Chemistry Test");
		checkTask.setStartDate(date);
		checkTask.setStartTime(time);

		ArrayList<String> dateList = new ArrayList<String>();
		dateList.add("view");
		dateList.add(date);
		dateList.add(date3);
		ArrayList<String> typeList = cmdView.sortViewTypes(dateList);
		ArrayList<TaskFile> taskList = cmdView.viewManyDatesList(dateList);
		
		thirdTask.setIsRecurr(false);

		assertEquals("[isViewManyList]", typeList.toString());
	
		assertEquals(currentTask, taskList.get(0));
	
		assertEquals(secondTask, taskList.get(1));
	
		assertEquals(thirdTask, taskList.get(2));
	
	}

	@Test
	public void viewTaskTest() throws Exception {
		ArrayList<String> aList = new ArrayList<String>();

		aList.add("Chemistry Test");
		aList.add("2016-04-10");
		aList.add("14:00");
		
		String name = aList.get(0);
		String date = aList.get(1);
		String time = aList.get(2);
		TaskFile currentTask = cmdAdd.addTask(aList);
		TaskFile checkTask = new TaskFile("Chemistry Test");
		checkTask.setStartDate(date);
		checkTask.setStartTime(time);
		TaskFile viewTask = cmdView.viewTask(name);

		assertEquals(checkTask, viewTask);
	}
	@Test
	public void viewDoneTest() throws Exception {
		storage = storage.getInstance();
		ArrayList<String> aList = new ArrayList<String>();

		aList.add("Chemistry Test");
		aList.add("2016-04-10");
		aList.add("14:00");
		
		String name = aList.get(0);
		String date = aList.get(1);
		String time = aList.get(2);
		TaskFile currentTask = cmdAdd.addTask(aList);
		currentTask.setIsDone(true);
		storage.deleteTask(name);
		storage.addTask(currentTask);
		TaskFile checkTask = new TaskFile("Chemistry Test");
		
		checkTask.setStartDate(date);
		checkTask.setStartTime(time);
		checkTask.setIsDone(true);
		ArrayList<TaskFile> doneList = cmdView.viewDoneList();
		
		assertEquals(checkTask, doneList.get(0));
	}
	@Test
	public void sortViewTest() throws Exception {
		ArrayList<String> aList = new ArrayList<String>();
		ArrayList<String> bList = new ArrayList<String>();
		ArrayList<String> cList = new ArrayList<String>();
		ArrayList<String> dList = new ArrayList<String>();
		ArrayList<String> eList = new ArrayList<String>();

		aList.add("view");
		aList.add("today");
		
		ArrayList<String> typeList = cmdView.sortViewTypes(aList);
		
		assertEquals("[isViewDateList]", typeList.toString());
		
		bList.add("view");
		bList.add("history");
		typeList = cmdView.sortViewTypes(bList);
		assertEquals("[isViewHistory]", typeList.toString());
		
		cList.add("view");
		cList.add("notes");
		typeList = cmdView.sortViewTypes(cList);
		assertEquals("[isViewNotes]", typeList.toString());
		
		dList.add("view");
		dList.add("1");
		typeList = cmdView.sortViewTypes(dList);
		assertEquals("[isViewIndex]", typeList.toString());
		
		
	}
}
```
###### \src\tnote\logic\LogicCommand.java
``` java
package tnote.logic;

import java.util.ArrayList;

import tnote.object.TaskFile;

public class LogicCommand {
	private String commandType;
	private TaskFile currentTask;
	private TaskFile oldTask;
	
	private boolean isRecurring;
	private ArrayList<String> startDates;
	private ArrayList<String> endDates;
	
	public LogicCommand(String command) {
		commandType = command;
		this.currentTask = new TaskFile();
		this.oldTask = new TaskFile();
	}

	public TaskFile getCurrentTask() {
		return currentTask;
	}

	public TaskFile getOldTask() {
		return oldTask;
	}
	
	public String getCommandType() {
		return commandType;
	}
	
	public ArrayList<String> getStartDates() {
		return startDates;
	}
	
	public ArrayList<String> getEndDates() {
		return endDates;
	}
	
	public boolean getIsRecurring() {
		return isRecurring;
	}
	
	public void setCurrentTask(TaskFile currentTask) {
		this.currentTask = currentTask;
	}

	public void setOldTask(TaskFile oldTask) {
		this.oldTask = oldTask;
	}
	
	public void setCommandType(String commandType) {
		this.commandType = commandType;
	}
	
	public void setIsRecurring(boolean isRecur) {
		this.isRecurring = isRecur;
	}
	
	public void setStartDates(ArrayList<String> startDates) {
		this.startDates = startDates;
	}
	
	public void setEndDates(ArrayList<String> endDates) {
		this.endDates = endDates;
	}
	
}
```
###### \src\tnote\logic\TNotesLogic.java
``` java
package tnote.logic;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Stack;

import static org.junit.Assert.assertTrue;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;

import tnote.object.NameComparator;
import tnote.object.RecurringTaskFile;
import tnote.object.TaskFile;
import tnote.storage.TNotesStorage;

/**
 * This class manages what methods are called by the UI component
 * 
 * It maintains a stack of objects of all the commands entered as well as their
 * accompanying TaskFile Object, so that the command can be undone or redone
 * 
 * It provides methods to call the various different methods in the subclasses,
 * based on what is parsed from the parser
 * 
 * Tasks can be added, deleted, edited, viewed, searched and sorted by name
 * 
 * @author A0124697U
 *
 */
public class TNotesLogic {
	private static final String UNDO_ERROR = "No action to undo";
	private static final String REDO_ERROR = "No action to redo";
	private static final String EDIT_COMMAND = "edit";
	private static final String ADD_COMMAND = "add";
	private static final String SET_COMMAND = "set";
	private static final String DELETE_COMMAND = "delete";

	private static final int INDEX_ZERO = 0;
	private static final int ARRAYLISINDEXCORRECTION = 1;

	private ArrayList<TaskFile> taskList = new ArrayList<TaskFile>();
	private ArrayList<String> startDates = new ArrayList<String>();
	private ArrayList<String> endDates = new ArrayList<String>();

	private Stack<LogicCommand> undoStack;
	private Stack<LogicCommand> redoStack;

	private TaskFile currentFile = new TaskFile();
	private TNotesStorage storage;

	private CommandAdd cmdAdd = new CommandAdd();
	private CommandView cmdView = new CommandView();
	private CommandDelete cmdDel = new CommandDelete();
	private CommandEdit cmdEdit = new CommandEdit();
	private CommandSearch cmdSearch = new CommandSearch();

	public TNotesLogic() throws Exception {
		storage = TNotesStorage.getInstance();
		undoStack = new Stack<LogicCommand>();
		redoStack = new Stack<LogicCommand>();
	}

	/**
	 * Method to push to stack a object that holds the add or delete command
	 * along with its TaskFile
	 * 
	 * @param commandWord
	 *            - the command of the task to be done,either add or delete
	 * @param previousTask
	 *            - the TaskFile object that was affected by this command
	 */
	private void pushToStack(String commandWord, TaskFile previousTask) {
		LogicCommand commandObj = new LogicCommand(commandWord);
		commandObj.setOldTask(previousTask);
		undoStack.push(commandObj);
		redoStack.clear();
	}

	/**
	 * Method to push to stack a object that holds the add or delete command
	 * along with its recurring TaskFile
	 * 
	 * @param commandWord
	 *            - the command of the recurring task to be done,either add or
	 *            delete
	 * @param previousTask-
	 *            the TaskFile object that was affected by this command
	 * @param startDates
	 *            - the list of start dates for the recurring task
	 * @param endDates
	 *            - the list of end dates for the recurring task
	 */
	private void pushToStackRecur(String commandWord, TaskFile previousTask, ArrayList<String> startDates,
			ArrayList<String> endDates) {
		LogicCommand commandObj = new LogicCommand(commandWord);
		commandObj.setOldTask(previousTask);
		commandObj.setIsRecurring(true);
		commandObj.setStartDates(startDates);
		commandObj.setEndDates(endDates);
		undoStack.push(commandObj);
		redoStack.clear();
	}

	/**
	 * Method to push to stack a object that holds the edit command along with
	 * its TaskFile
	 * 
	 * @param commandWord
	 *            - the command of the task to be edited
	 * @param oldTask
	 *            - the previous TaskFile object before the edit
	 * @param mostRecentTask
	 *            - the new edited TaskFile object
	 */
	private void editPushToStack(String commandWord, TaskFile oldTask, TaskFile mostRecentTask) {
		LogicCommand commandObj = new LogicCommand(commandWord);
		commandObj.setOldTask(oldTask);
		commandObj.setCurrentTask(mostRecentTask);
		undoStack.push(commandObj);
		redoStack.clear();
	}

	/**
	 * Method to push to stack a object that holds the edit command along with
	 * its recurring TaskFile
	 * 
	 * @param commandWord
	 *            - the command of the recurring task to be edited
	 * 
	 * @param oldTask
	 *            - the previous recurring TaskFile object before the edit
	 * @param mostRecentTask
	 *            - the new edited recurring TaskFile object
	 * @param startDates
	 *            - the list of start dates for the recurring TaskFile object
	 * @param endDates
	 *            - the list of end Dates for the recurring TaskFile object
	 */
	private void editPushToStackRecur(String commandWord, TaskFile oldTask, TaskFile mostRecentTask,
			ArrayList<String> startDates, ArrayList<String> endDates) {
		LogicCommand commandObj = new LogicCommand(commandWord);
		commandObj.setOldTask(oldTask);
		commandObj.setCurrentTask(mostRecentTask);
		commandObj.setIsRecurring(true);
		commandObj.setStartDates(startDates);
		commandObj.setEndDates(endDates);
		undoStack.push(commandObj);
		redoStack.clear();
	}

	// ==================================ADDCommand=====================================
	/**
	 * Method that calls the subclass method to add a task
	 * 
	 * @param fromParser
	 *            - the sorted inputs from the user
	 * @return - the newly added taskFile object
	 * @throws Exception
	 */
	public TaskFile addTask(ArrayList<String> fromParser) throws Exception {
		String commandWord = fromParser.remove(INDEX_ZERO);
		currentFile = cmdAdd.addTask(fromParser);

		if (currentFile.getIsRecurring()) {
			ArrayList<String> startDateList = storage.getRecurTaskStartDateList(currentFile.getName());
			ArrayList<String> endDateList = storage.getRecurTaskEndDateList(currentFile.getName());
			pushToStackRecur(commandWord, currentFile, startDateList, endDateList);
		} else {
			assertFalse(currentFile.getIsRecurring());
			pushToStack(commandWord, currentFile);
		}
		return currentFile;
	}

	// ================================DELETECommands=======================================
	/**
	 * Method to delete everything all task at once
	 * 
	 * @return - true if the storage clears , false if the storage is unable to
	 *         clear
	 * @throws Exception
	 */
	public boolean clearAll() throws Exception {
		if (storage.clearFiles()) {
			return true;
		} else {
			return false;
		}
	}

	/**
	 * Method that calls the subclass method to delete a task
	 * 
	 * @param fromParser
	 *            - the sorted inputs from the user
	 * @return - the task that was suppose to be deleted
	 * @throws Exception
	 */
	public TaskFile deleteTask(ArrayList<String> fromParser) throws Exception {
		String commandWord = fromParser.remove(INDEX_ZERO);
		startDates = storage.getRecurTaskStartDateList(fromParser.get(INDEX_ZERO));
		endDates = storage.getRecurTaskEndDateList(fromParser.get(INDEX_ZERO));
		currentFile = cmdDel.delete(fromParser);

		if (currentFile.getIsRecurring()) {
			pushToStackRecur(commandWord, currentFile, startDates, endDates);
		} else {
			assertFalse(currentFile.getIsRecurring());
			pushToStack(commandWord, currentFile);
		}
		return currentFile;
	}

	/**
	 * Method to delete a task based on a number of the current viewed list.
	 * 
	 * @param currentList
	 *            - the currently viewed list by the user.
	 * @param num
	 *            - which number on the list is to be deleted
	 * @return - the new amended list with the task at the selected num removed.
	 * @throws Exception
	 *             - Error message thrown when deleted file cannot be found
	 */
	public ArrayList<TaskFile> deleteIndex(ArrayList<TaskFile> currentList, int num) throws Exception {
		String commandWord = DELETE_COMMAND;
		TaskFile removedTask = currentList.remove(num - ARRAYLISINDEXCORRECTION);
		storage.deleteTask(removedTask.getName());
		pushToStack(commandWord, removedTask);
		return currentList;
	}

	// =============================VIEWCommands======================================

	public ArrayList<String> sortViewTypes(ArrayList<String> fromParser) {
		return cmdView.sortViewTypes(fromParser);
	}

	public TaskFile viewByIndex(ArrayList<TaskFile> currentList, int num) throws Exception {
		TaskFile removedTask = currentList.get(num - ARRAYLISINDEXCORRECTION);
		return removedTask;
	}

	public ArrayList<TaskFile> viewDoneList() throws Exception {
		return cmdView.viewDoneList();
	}

	public TaskFile viewTask(String taskToBeDisplayed) throws Exception {
		return cmdView.viewTask(taskToBeDisplayed);
	}

	public ArrayList<TaskFile> viewManyDatesList(ArrayList<String> dates) throws Exception {
		return cmdView.viewManyDatesList(dates);
	}

	public ArrayList<TaskFile> viewDateList(String date) throws Exception {
		return cmdView.viewDateList(date);
	}

	public ArrayList<TaskFile> viewFloatingList() throws Exception {
		return cmdView.viewFloatingList();
	}

	public ArrayList<TaskFile> callOverdueTasks() throws Exception {
		return cmdView.callOverdueTasks();
	}

	/**
	 * Method to set a task status to be completed
	 * 
	 * @param taskName
	 *            - name of the task
	 * @param status
	 *            - whether the task is set to done or undone
	 * @return - true if the task is set to done, false if the task is set to
	 *         undone
	 * @throws Exception
	 */
	public boolean setStatus(String taskName, boolean status) throws Exception {
		String commandWord = SET_COMMAND;
		TaskFile oldTask = storage.getTaskFileByName(taskName);
		storage.deleteTask(oldTask.getName());
		TaskFile newTask = new TaskFile(oldTask);
		newTask.setIsDone(status);
		storage.addTask(newTask);

		if (newTask.getIsDone()) {
			assertTrue(newTask.getIsDone());
			editPushToStack(commandWord, oldTask, newTask);
			return true;
		} else {
			return false;
		}
	}

	// ================================EDITCommand=========================================
	/**
	 * Method that calls the subclass method to edit a task
	 * 
	 * @param fromParser
	 *            - sorted user inputs from parser component
	 * @return - the changed TaskFile
	 * @throws Exception
	 */
	public TaskFile editTask(ArrayList<String> fromParser) throws Exception {
		String commandWord = fromParser.remove(INDEX_ZERO).trim();
		TaskFile oldFile = storage.getTaskFileByName(fromParser.get(INDEX_ZERO));
		currentFile = cmdEdit.edit(fromParser);

		if (currentFile.getIsRecurring()) {
			startDates = storage.getRecurTaskStartDateList(fromParser.get(INDEX_ZERO));
			endDates = storage.getRecurTaskEndDateList(fromParser.get(INDEX_ZERO));
			editPushToStackRecur(commandWord, oldFile, currentFile, startDates, endDates);
		} else {
			assertFalse(currentFile.getIsRecurring());
			editPushToStack(commandWord, oldFile, currentFile);
		}
		return currentFile;
	}

	// ===========================SEARCHcommmands====================================

	public TaskFile searchSingleTask(String lineOfText) throws Exception {
		currentFile = cmdSearch.searchSingleTask(lineOfText);
		return currentFile;
	}

	public ArrayList<TaskFile> searchTask(ArrayList<String> lineOfText) throws Exception {
		taskList = cmdSearch.searchTask(lineOfText);
		return taskList;
	}

	/**
	 * Method to check if floating tasks exist
	 * 
	 * @return - returns true if there are floating tasks, false if there are no
	 *         floating task
	 * @throws Exception
	 */
	public boolean hasFloatingList() throws Exception {
		ArrayList<String> list = storage.readFromFloatingFile();
		if (list.isEmpty()) {
			return false;
		} else {
			assertFalse(list.isEmpty());
			return true;
		}
	}

	/**
	 * Method to sort the list of tasks currently viewing by name
	 * 
	 * @param currentList
	 *            - the current list the user is viewing, be it todays
	 *            schedule,notes, etc..
	 * 
	 * @return - the same ArrayList, sorted by name.
	 */
	public ArrayList<TaskFile> sortTask(ArrayList<TaskFile> currentList) {
		Collections.sort(currentList, new NameComparator());
		return currentList;
	}

	/**
	 * Method to change the directory
	 * 
	 * @param directoryName
	 *            - changes the directory name to the given string parameter
	 * @return - boolean value, true if the change was successful.
	 * @throws Exception
	 */
	public boolean changeDirectory(String directoryName) throws Exception {
		return storage.setNewDirectory(directoryName);
	}

	/**
	 * Method to delete the entire directory
	 * 
	 * @param directory
	 *            - deletes the directory
	 * @return - boolean value, true if the directory was successfully deleted
	 * @throws IOException
	 */
	public boolean deleteDirectory(String directory) throws IOException {
		if (storage.deleteDirectory(directory)) {
			return true;
		} else {
			return false;
		}
	}

	/**
	 * Method to undo the last command
	 * 
	 * @return - logicCommand object that holds the task tied to the command.
	 * @throws Exception
	 */
	public LogicCommand undo() throws Exception {
		if (!undoStack.empty()) {
			LogicCommand prevCmd = undoStack.pop();
			String commandWord = prevCmd.getCommandType();
			TaskFile prevTask = prevCmd.getOldTask();

			if (prevCmd.getIsRecurring()) {
				startDates = prevCmd.getStartDates();
				endDates = prevCmd.getEndDates();
				RecurringTaskFile recurTask = new RecurringTaskFile(prevTask);
				recurTask.addRecurringStartDate(startDates);
				recurTask.addRecurringEndDate(endDates);

				if (commandWord.equals(ADD_COMMAND)) {
					storage.deleteRecurringTask(prevTask.getName());
				} else if (commandWord.equals(DELETE_COMMAND)) {
					storage.addRecurringTask(recurTask);
				} else if (commandWord.equals(EDIT_COMMAND) || commandWord.equals(SET_COMMAND)) {
					TaskFile currentTask = prevCmd.getCurrentTask();
					storage.deleteRecurringTask(currentTask.getName());
					storage.addRecurringTask(recurTask);
				} else {
					assertEquals("", commandWord);
				}
			} else {
				assertFalse(prevCmd.getIsRecurring());
				if (commandWord.equals(ADD_COMMAND)) {
					storage.deleteTask(prevTask.getName());
				} else if (commandWord.equals(DELETE_COMMAND)) {
					storage.addTask(prevTask);
				} else if (commandWord.equals(EDIT_COMMAND) || commandWord.equals(SET_COMMAND)) {
					TaskFile currentTask = prevCmd.getCurrentTask();
					storage.deleteTask(currentTask.getName());
					storage.addTask(prevTask);
				} else {
					assertEquals("", commandWord);
				}
			}

			redoStack.push(prevCmd);
			return prevCmd;
		} else {
			throw new Exception(UNDO_ERROR);
		}
	}

	/**
	 * Method to redo the last method undone
	 * 
	 * @return - logicCommand object contain the redone command and the TaskFile
	 *         tied to it.
	 * @throws Exception
	 */
	public LogicCommand redo() throws Exception {
		if (!redoStack.empty()) {
			LogicCommand nextCmd = redoStack.pop();
			String commandWord = nextCmd.getCommandType();
			TaskFile prevTask = nextCmd.getOldTask();

			if (nextCmd.getIsRecurring()) {
				startDates = nextCmd.getStartDates();
				endDates = nextCmd.getEndDates();
				RecurringTaskFile recurTask = new RecurringTaskFile(prevTask);
				recurTask.addRecurringStartDate(startDates);
				recurTask.addRecurringEndDate(endDates);

				if (commandWord.equals(ADD_COMMAND)) {
					storage.addRecurringTask(recurTask);
				} else if (commandWord.equals(DELETE_COMMAND)) {
					storage.deleteRecurringTask(prevTask.getName());
				} else if (commandWord.equals(EDIT_COMMAND) || commandWord.equals(SET_COMMAND)) {
					TaskFile currentTask = nextCmd.getCurrentTask();
					RecurringTaskFile recurTaskAfterEdit = new RecurringTaskFile(currentTask);
					recurTaskAfterEdit.addRecurringStartDate(startDates);
					recurTaskAfterEdit.addRecurringEndDate(endDates);

					storage.deleteRecurringTask(prevTask.getName());
					storage.addRecurringTask(recurTaskAfterEdit);
				} else {
					assertEquals("", commandWord);
				}
			} else {
				assertFalse(nextCmd.getIsRecurring());
				if (commandWord.equals(ADD_COMMAND)) {
					storage.addTask(prevTask);
				} else if (commandWord.equals(DELETE_COMMAND)) {
					storage.deleteTask(prevTask.getName());
				} else if (commandWord.equals(EDIT_COMMAND) || commandWord.equals(SET_COMMAND)) {
					TaskFile currentTask = nextCmd.getCurrentTask();
					storage.deleteTask(prevTask.getName());
					storage.addTask(currentTask);
				} else {
					assertEquals("", commandWord);
				}
			}
			undoStack.push(nextCmd);
			return nextCmd;
		} else {
			throw new Exception(REDO_ERROR);
		}
	}
}
```
###### \src\tnote\logic\TNotesLogicTest.java
``` java
package tnote.logic;

import static org.junit.Assert.*;

import java.io.FileNotFoundException;
import java.util.ArrayList;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;

import org.junit.Test;

import tnote.object.TaskFile;
import tnote.storage.TNotesStorage;

public class TNotesLogicTest {

	TNotesLogic logic;
	TNotesStorage storage;

	@Before
	public void setUp() throws Exception {

		logic = new TNotesLogic();
		storage = TNotesStorage.getInstance();
		storage.setUpStorage();
	}

	@After
	public void tearDown() throws Exception {
		System.out.println(storage.clearFiles());
	}

	@Test
	public void addTaskTest() throws Exception {
		ArrayList<String> aList = new ArrayList<String>();
		ArrayList<String> bList = new ArrayList<String>();
		aList.add("add");
		aList.add("Chemistry Test");
		bList.add("add");
		bList.add("math test");
		bList.add("today");
		TaskFile currentTask = logic.addTask(aList);
		TaskFile newTask = logic.addTask(bList);

		assertEquals("Chemistry Test", currentTask.getName());
		assertEquals(currentTask.getDetails(), newTask.getDetails());
		assertFalse(currentTask.getIsRecurring());
		assertFalse(newTask.getIsRecurring());

	}

	@Test
	public void addTaskTest2() throws Exception {
		ArrayList<String> aList = new ArrayList<String>();
		ArrayList<String> bList = new ArrayList<String>();
		aList.add("add");
		aList.add("write report");
		aList.add("15-4-2016");
		aList.add("22:00pm");

		TaskFile currentTask = logic.addTask(aList);
		assertEquals("write report", currentTask.getName());
		assertEquals("22:00pm", currentTask.getStartTime());
		assertEquals("15-4-2016", currentTask.getStartDate());

	}

	@Test
	public void deleteTaskTest() throws Exception {
		ArrayList<String> newList = new ArrayList<String>();
		ArrayList<String> list = new ArrayList<String>();
		list.add("delete");
		list.add("write report");
		newList.add("add");
		newList.add("write report");
		TaskFile oldTask = logic.addTask(newList);
		TaskFile newTask = storage.getTaskFileByName("write report");
		TaskFile currentTask = logic.deleteTask(list);
		assertEquals(newTask, currentTask);

	}

	@Test
	public void viewTask() throws Exception {
		ArrayList<TaskFile> list = new ArrayList<TaskFile>();
		ArrayList<String> addList = new ArrayList<String>();
		ArrayList<String> checkList = new ArrayList<String>();
		checkList.add("view");
		checkList.add("Chemistry Test");
		checkList.add("isViewNotes");
		addList.add("add");
		addList.add("Chemistry Test");
		
		TaskFile oldFile = logic.addTask(addList);
		list = logic.viewFloatingList();

		assertEquals(list.get(0).getName(), checkList.get(1));
	}

	@Test
	public void setTask() throws Exception {
		ArrayList<TaskFile> list = new ArrayList<TaskFile>();
		ArrayList<String> checkList = new ArrayList<String>();
		checkList.add("add");
		checkList.add("homework test");
		checkList.add("today");
		TaskFile currentFile = logic.addTask(checkList);
		ArrayList<String> newList = new ArrayList<String>();
		newList.add("delete");
		newList.add("homework test");
		logic.deleteTask(newList);

		currentFile.setIsDone(true);
		storage.addTask(currentFile);
		assertTrue(currentFile.getIsDone());
	}

	@Test
	public void sortTask() throws Exception{
		ArrayList<TaskFile> list =new ArrayList<TaskFile>();
		ArrayList<String> aList = new ArrayList<String>();
		ArrayList<String> bList = new ArrayList<String>();
		aList.add("add");
		aList.add("homework");
		aList.add("today");
		bList.add("add");
		bList.add("skating");
		bList.add("tomorrow");
		
		TaskFile firstTask = logic.addTask(aList);
		TaskFile secondTask = logic.addTask(bList);	
		list.add(firstTask);
		list = logic.sortTask(list);
		
		assertEquals(list.get(0), firstTask);
		
	}
	@Test
	public void editRecurringTaskTest() throws Exception {
		ArrayList<String> aList = new ArrayList<String>();
		ArrayList<String> bList = new ArrayList<String>();
		ArrayList<String> cList = new ArrayList<String>();
		aList.add("add");
		aList.add("see doctor");
		aList.add("today");
		aList.add("20:00");
		aList.add("22:00");
		aList.add("every");
		aList.add("week");
		aList.add("for");
		aList.add("2");
		aList.add("weeks");
		
		bList.add("edit");
		bList.add("see doctor");
		bList.add("startTime");
		bList.add("21:00");

		TaskFile addTask = logic.addTask(aList);
		TaskFile editTask = logic.editTask(bList);

		assertNotEquals(addTask.getStartTime(), editTask.getStartTime());
		assertEquals(addTask.getDetails(), editTask.getDetails());
		assertEquals(addTask.getStartDate(), editTask.getStartDate());;

		cList.add("edit");
		cList.add("see doctor");
		cList.add("endDate");
		cList.add("23:00pm");
		
		 editTask = logic.editTask(cList);

		assertNotEquals(addTask.getEndDate(), editTask.getEndDate());
	}
}
```
