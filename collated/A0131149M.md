# A0131149M
###### \src\tnote\parser\TNotesParser.java
``` java
package tnote.parser;
import java.util.ArrayList;
import java.util.logging.Logger;

import tnote.util.log.TNoteLogger;

/**
 * This class manages the input String entered by the user, split the string
 * according to space an identify the commands
 * 
 * It retrieves the contents after identified command word and pass it to the
 * UI class. It manages the input into their individual command and put
 * into their respected classes.
 * 
 */
public class TNotesParser {
	private static final String MESSAGE_INVALID_COMMAND = "Invalid command has been entered!";
	private static final String MESSAGE_NULL_INPUTSTRING = "Null inputString is passed in!";	
	private static final String MESSAGE_NULL_STRING = " ";
	private static final String MESSAGE_LOG_ERROR = "test Warning in parser command";
	
	private static int NUM_FIRST_WORD = 0;
	
	private static final Logger logger = Logger.getGlobal();
	
	enum TNotesParserCommandWords {
		ADD, VIEW, EDIT, DELETE, SEARCH, SORT, HELP, EXIT, SET, CHANGE, UNDO, REDO

	}
	private TNotesParserAdd add;
	private TNotesParserChange change;
	private TNotesParserDelete delete;
	private TNotesParserSet set;
	private TNotesParserSort sort;
	private TNotesParserSearch search;
	private TNotesParserView view;
	private TNotesParserEdit edit;
	
	public TNotesParser() throws Exception{
		TNoteLogger.setUp();
		add = new TNotesParserAdd();
		change = new TNotesParserChange();
		delete = new TNotesParserDelete();
		set = new TNotesParserSet();
		sort = new TNotesParserSort();
		search = new TNotesParserSearch();
		view = new TNotesParserView();
		edit = new TNotesParserEdit();
	}
	

	public interface Parser {
		public Object parse(String input);
	}
	
	/**
	 * Return an ArrayList that contains all the contents.
	 * If valid task commands are found, contents in the list are updated.
	 * 
	 * @param inputString	An string input from the user.
	 * @return	An ArrayList of String that are in their respective positions
	 * @throws Exception 
	 * 				- Error message will be thrown for invalid commands
	 */
	public ArrayList<String> checkCommand(String inputString) throws Exception{
		ArrayList<String> list = new ArrayList<String>();
		assert inputString != "" : MESSAGE_NULL_INPUTSTRING;	
		try{
			
			String arr[] = inputString.split(MESSAGE_NULL_STRING);
			String firstWord = arr[NUM_FIRST_WORD].toUpperCase();
			TNotesParserCommandWords getFirstWordValue = TNotesParserCommandWords.valueOf(firstWord);
		switch(getFirstWordValue){
		
			case ADD :

				list.add(firstWord.toLowerCase());
				list.addAll(add.addCommand(arr));
				
				break;
			case VIEW :
				
				list.add(firstWord.toLowerCase());
				list.addAll(view.viewCommand(arr));
				
				return list;
			case EDIT :
				
				list.add(firstWord.toLowerCase());
				list.addAll(edit.editCommand(arr));
				
				return list;	
			case DELETE :
				
				list.addAll(delete.deleteCommand(arr));
				
				return list;
			case SEARCH :
				
				list.add(firstWord.toLowerCase());
				list.addAll(search.searchCommand(arr));
				
				return list;
			case SORT :
				
				list.add(firstWord.toLowerCase());
				list.addAll(sort.sortCommand(arr));
				
				break;
			case HELP :
				
				list.add(firstWord.toLowerCase());
				
				return list;
			case EXIT :
				
				list.add(firstWord.toLowerCase());
				
				return list;
			case SET :
				
				list.add(firstWord.toLowerCase());
				list.addAll(set.setCommand(arr));
				
				return list;
			case CHANGE :
				
				list.addAll(change.changeCommand(arr));
				
				break;	
			case UNDO :
				
				list.add(firstWord.toLowerCase());
				
				break;
			case REDO :
				
				list.add(firstWord.toLowerCase());
				
				break;
			default:
				throw new Exception(MESSAGE_INVALID_COMMAND);

			}
		} catch (Exception e) {
			System.out.println(MESSAGE_INVALID_COMMAND);
		}
		
		logger.warning(MESSAGE_LOG_ERROR);
		return list;

		
	}
}
```
###### \src\tnote\parser\TNotesParserAdd.java
``` java
package tnote.parser;
import java.util.ArrayList;
import java.util.logging.Logger;
import tnote.util.log.TNoteLogger;

/**
 * This class manages the input String after command add
 * 
 * It retrieves the contents after command word add and pass it to the
 * UI class. It manages the input into their individual types and put them into the correct positions.
 * 
 *  The users are able to either add a floating task or specify its timing or date.
 */
public class TNotesParserAdd {
	
	private static final String MESSAGE_ASSERTION_NULL = "Invalid array!";
	private static final String MESSAGE_IMPORTANT = "important";
	private static final String MESSAGE_EVERY = "every";
	private static final String MESSAGE_THIS = "this";
	private static final String MESSAGE_NULL = "";
	private static final String MESSAGE_SPACE = " ";
	private static final String MESSAGE_INVALID_DATE_RANGE = "Invalid date range!";
	private static final String MESSAGE_INVALID_TIME_RANGE = "Invalid time range!";
	private static final String MESSAGE_LOG_ERROR = "test Warning in parser command add";
	
	private static int NUM_LAST_ARR_STR = 1;
	private static int NUM_LAST_TWO_ARR_STR = 2;
	private static int NUM_INITIALISATION = 0;
	private static int NUM_TRUE = 1;
	private static int NUM_FALSE = 0;
	private static int NUM_TWO_TIME_DATE_PRESENT = 2;
	private static int NUM_TIME_DATE_PRESENT = 1;
	private static int NUM_TIME_DATE_ABSENT = 0;
	private static int NUM_FIRST_WORD = 0;
	private static int NUM_SECOND_WORD = 1;
	private static int NUM_GET_SECOND = 2;
	private static int NUM_GET_THIRD = 3;
	private static int NUM_GET_FORTH = 4;
	private static int NUM_GET_FITH = 5;
	
	private static final Logger logger = Logger.getGlobal();
	
	private TNotesParserTime time;
	private TNotesParserDate date;
	private TNotesParserQuery query;
	
	protected TNotesParserAdd(){
		time = new TNotesParserTime();
		date = new TNotesParserDate();
		query = new TNotesParserQuery();
	}
	
	private static final String keyWordArr [] = {
			"due", "from", "to", "details",
			"on", "at", "every"
			};
	/**
	 * This method will identify and organize the inputs after the 
	 * command word add.
	 * 
	 * @param  addArr All Array input by the user
	 * @return addList An ArrayList
	 * @throws Exception
	 *            - if the input array type is not acceptable
	 */
	public ArrayList<String> addCommand(String[] arr) throws Exception{
		assert arr !=null : MESSAGE_ASSERTION_NULL;
		
		ArrayList<String> addList = new ArrayList<String>();
		ArrayList<String> dateList = new ArrayList<String>();
		ArrayList<String> timeList = new ArrayList<String>();
		
		int taskNameIndex = NUM_INITIALISATION;
		
		//check time and date
		for(int i=NUM_INITIALISATION;i<arr.length;i++){
			if(time.checkTime(arr[i])==NUM_TRUE){
				timeList.add(time.formatTime(arr[i].trim()));
			}
		}
		for(int i=NUM_INITIALISATION;i<arr.length;i++){
			if(time.checkTime(arr[i])==NUM_FALSE && date.checkDate(arr[i])==NUM_TRUE){
				dateList.add(date.formatDate(arr[i].trim()));
			}
		}
		
		//add task name
		for(int i = NUM_INITIALISATION; i<arr.length; i++){
			if(taskNameIndex !=NUM_INITIALISATION){
				break;
			}
			else{
				for(int j=NUM_INITIALISATION;j<keyWordArr.length;j++){
					if(arr[i].equals(keyWordArr[j]) && isKeyWord(arr[i+NUM_SECOND_WORD])==NUM_TRUE){
						taskNameIndex = i;
						break;
				
					}
				}
			}
		}
		
		//taskName without keyword
		if(taskNameIndex == NUM_FALSE){
			addList.addAll(checkTaskName(arr,timeList,dateList));
		}
		//task name with key word
		else{
			addList.add(query.taskNameString(arr, taskNameIndex).trim());
		}
			
		for(int k=NUM_INITIALISATION;k<arr.length;k++){
			if(arr[k].equals("details")){
				if(onlyKeyDetails(arr)==NUM_TRUE){
					addList.clear();
					addList.add(query.taskNameString(arr, k).trim());
					addList.addAll(keyWordDetails(arr, k));
				}
				else{
					addList.addAll(keyWordDetails(arr, k));
				}
				break;
			}
			else{
				addList.addAll(checkAddKeyWord(k,arr,timeList,dateList ));
			}	
		}
		if(query.findImpt(arr) == NUM_TRUE){
			addList.add(MESSAGE_IMPORTANT);
		}

		if(timeList.size() == NUM_TWO_TIME_DATE_PRESENT  
				&& dateList.size() == NUM_TIME_DATE_ABSENT
				&& time.compareTime(timeList).get(NUM_FIRST_WORD).equals(MESSAGE_INVALID_TIME_RANGE)){
			addList.clear();
			addList.add(MESSAGE_INVALID_TIME_RANGE);
		}
		if(dateList.size() == NUM_TWO_TIME_DATE_PRESENT &&
			date.compareDate(dateList).get(NUM_FIRST_WORD).equals(MESSAGE_INVALID_DATE_RANGE)){
			addList.clear();
			addList.add(MESSAGE_INVALID_DATE_RANGE);
		}	
		
	logger.info(MESSAGE_LOG_ERROR); 	
	return addList;
	}
	
	private String naturalLanguageTaskName(String arr[]){
		String task = new String();
		int index = NUM_INITIALISATION;
		for(int i=NUM_INITIALISATION;i<arr.length;i++){
			if(arr[i].equals("the")){
				index = i;
			}
		}
		for(int j=NUM_INITIALISATION;j<index;j++){
			task += arr[j] + MESSAGE_SPACE;
		}
		return task;
		
	}
	private ArrayList<String> keyWordDue( String arr[], int j){
		ArrayList <String> list = new ArrayList <String>();
		String thisString = new String();
		if((arr[j+NUM_SECOND_WORD].equals("every")||arr[j+NUM_SECOND_WORD].equals("next"))&& isKeyWord(arr[j+2]) == NUM_TRUE){
			list.add(arr[j+NUM_SECOND_WORD].trim());
			list.add(date.compareWeekDayMonth(arr[j+NUM_GET_SECOND]).trim());
			//for 2 week
			if(arr.length>=j+NUM_GET_FORTH && arr[j+NUM_GET_THIRD].equals("for")){
				list.add("for");
				list.add(arr[j+NUM_GET_FORTH]);
				list.add(arr[j+NUM_GET_FITH]);
			}
		//add call mom due this week(variable)
		}else if(arr[j+1].equals("this")&& isKeyWord(arr[j+NUM_GET_SECOND]) == NUM_TRUE){
			thisString = "this"+" "+ date.compareWeekDayMonth(arr[j+NUM_GET_SECOND]);
			list.add(thisString.trim());
		}
		//add call mom due time/date
		else if(isKeyWord(arr[j+NUM_SECOND_WORD]) == NUM_TRUE){
			if(time.checkTime(arr[j+NUM_SECOND_WORD])==NUM_TRUE){
				if(arr.length>j+NUM_GET_SECOND){
					list.add(time.formatTime(arr[j + NUM_SECOND_WORD]+ 
							time.isAMPM(arr[j+NUM_GET_SECOND])).toString().trim());
				}
				else{
					list.add(time.formatTime(arr[j + NUM_SECOND_WORD]).toString().trim());
				}
				
			}else if(time.checkTime(arr[j+NUM_SECOND_WORD])==NUM_FALSE){
				list.add(date.compareWeekDayMonth(arr[j + NUM_SECOND_WORD]).trim());
			}		
		}
		return list;
		
	}
	private ArrayList<String> keyWordAt(String arr[], int k){
		ArrayList <String> addList = new ArrayList <String>();
		if(time.checkTime(arr[k+NUM_SECOND_WORD])==NUM_TRUE){
			if(arr.length>k+NUM_GET_SECOND){
				addList.add(time.formatTime(arr[k + NUM_SECOND_WORD]+ 
						time.isAMPM(arr[k+NUM_GET_SECOND])).toString().trim());
			}
			else{
				addList.add(time.formatTime(arr[k + NUM_SECOND_WORD]).toString().trim());
			}
		}
		else{
			addList.add(date.compareWeekDayMonth(arr[k+NUM_SECOND_WORD].trim()));
		}
		
		return addList;
	}
	
	private ArrayList<String> keyWordFromTo(String arr[], int k){
		ArrayList <String> addList = new ArrayList <String>();
		if(time.checkTime(arr[k+NUM_SECOND_WORD])==NUM_TRUE){
			addList.add(time.formatTime(arr[k+NUM_SECOND_WORD]));
		}
		else{
			addList.add(date.compareWeekDayMonth(arr[k+NUM_SECOND_WORD].trim()));
		}
		return addList;
		
	}
	private ArrayList<String> keyWordDetails(String arr[], int j){
		ArrayList <String> list = new ArrayList <String>();
		String details = new String();
			for (int num = j+NUM_SECOND_WORD; num < arr.length; num++) {
				details += arr[num] + MESSAGE_SPACE;
			}
			list.add(details.trim());
		
		
		return list;
	}
	
	private ArrayList<String> keyWordEvery(String arr[], int k){
		ArrayList <String> addList = new ArrayList <String>();
		addList.add("every");
		addList.add(date.compareWeekDayMonth(arr[k+NUM_SECOND_WORD].trim()));
		
		if(arr.length>=k+NUM_GET_THIRD && arr[k+NUM_GET_SECOND].equals("for")){
			addList.add(arr[k+NUM_GET_SECOND]);
			addList.add(arr[k+NUM_GET_THIRD]);
			addList.add(arr[k+NUM_GET_FORTH]);
		}
		return addList;
	}

	private int isKeyWord(String word) {
		if(date.formatWeekDay(word).equals(MESSAGE_NULL)
				&&date.formatMonth(word).equals(MESSAGE_NULL)
				&&date.formatSpecialDay(word).equals(MESSAGE_NULL)
				&&time.formatTime(word).equals(MESSAGE_NULL)
				&&date.formatDate(word).equals(MESSAGE_NULL)
				&& !word.equals(MESSAGE_EVERY)
				&& !word.equals(MESSAGE_THIS)){
			return NUM_FALSE;
		}
		else{
			return NUM_TRUE;
		}
	}
	private int onlyKeyDetails(String[] arr) {
		int index = NUM_TRUE;
		for(int i = NUM_INITIALISATION; i<arr.length; i++){
			if(index !=NUM_TRUE){
				break;
			}
			else{
				for(int j=NUM_INITIALISATION;j<keyWordArr.length;j++){
					if(arr[i].equals(keyWordArr[j]) 
						&& isKeyWord(arr[i+NUM_SECOND_WORD])==NUM_TRUE
						&& !arr[i].equals("details")){
						index = NUM_FALSE;
						break;
				
					}
				}
			}
		}
		return index;
	}
	
	private ArrayList<String> checkTaskName(String[] arr,ArrayList <String> timeList,
											ArrayList <String> dateList ) throws Exception {
		ArrayList <String> addList = new ArrayList<String>();
		if(!date.formatSpecialDay(arr[arr.length-NUM_LAST_ARR_STR]).equals(MESSAGE_NULL) 
				&& query.checkAfterBefore(arr)==NUM_FALSE){
			addList.add(query.taskNameString(arr, arr.length-NUM_LAST_ARR_STR).trim());
			addList.add(date.formatSpecialDay(arr[arr.length-NUM_LAST_ARR_STR]));
			
		}else if(arr[arr.length-NUM_LAST_ARR_STR].equals(MESSAGE_IMPORTANT)){
			addList.add(query.taskNameString(arr, arr.length-NUM_LAST_ARR_STR).trim());
			
		}else if(timeList.size() == NUM_TIME_DATE_PRESENT 
				&& dateList.size() ==NUM_TIME_DATE_ABSENT){
				addList.add(query.taskNameString(arr, arr.length-NUM_LAST_ARR_STR).trim());
				addList.add(timeList.get(NUM_FIRST_WORD));
				
		}else if(timeList.size() ==NUM_TIME_DATE_ABSENT 
				&& dateList.size() ==NUM_TIME_DATE_PRESENT){
			addList.add(query.taskNameString(arr, arr.length-NUM_LAST_ARR_STR).trim());
			addList.add(dateList.get(NUM_FIRST_WORD));
			
		}else if(timeList.size() ==NUM_TIME_DATE_PRESENT 
				&& dateList.size() ==NUM_TIME_DATE_PRESENT){
			addList.add(query.taskNameString(arr, arr.length-NUM_LAST_TWO_ARR_STR).trim());
			addList.add(timeList.get(NUM_FIRST_WORD));
			addList.add(dateList.get(NUM_FIRST_WORD));
			
		}else if(timeList.size() ==NUM_TIME_DATE_ABSENT 
				&& dateList.size() ==NUM_TIME_DATE_ABSENT 
				&& query.checkAfterBefore(arr)==NUM_TRUE){
			addList.add(naturalLanguageTaskName(arr));
			addList.add(time.prettyTime(query.taskNameString(arr, arr.length).trim()));
			
		}
		else{		
			addList.add(query.taskNameString(arr, arr.length).trim());
		}
		return addList;
	}
	
	private ArrayList<String> checkAddKeyWord(int k,String[] arr,ArrayList <String> timeList,
			ArrayList <String> dateList ) throws Exception {
		ArrayList <String> addList = new ArrayList<String>();
		// key word at
		if(arr[k].equals("at") && isKeyWord(arr[k+NUM_SECOND_WORD])==NUM_TRUE){
			addList.addAll(keyWordAt(arr, k));
		//key word from to	
		}else if((arr[k].equals("from") || arr[k].equals("to"))&& isKeyWord(arr[k+NUM_SECOND_WORD])==NUM_TRUE){
			addList.addAll(keyWordFromTo(arr, k));
		//key word details	
		}else if(arr[k].equals("on") && isKeyWord(arr[k+NUM_SECOND_WORD])==NUM_TRUE){
			addList.add(date.compareWeekDayMonth(arr[k+1].trim()));
		//key word every
		}else if(arr[k].equals("every") && isKeyWord(arr[k+NUM_SECOND_WORD])==NUM_TRUE 
				&& !arr[k-NUM_LAST_ARR_STR].equals("due")){
			addList.addAll(keyWordEvery(arr,k));
		//key word due	
		}else if(arr[k].equals("due")){
			addList.addAll(keyWordDue(arr, k));
		
		}
		return addList;
	}
	
}
```
###### \src\tnote\parser\TNotesParserAddTest.java
``` java
package tnote.parser;

import static org.junit.Assert.assertEquals;

import java.util.Arrays;
import java.util.List;

import org.junit.Test;

public class TNotesParserAddTest {
	private static final List<String> listAdd1 = 
			Arrays.asList("call mom", "13:00");
	private static final List<String> listAdd2 = 
			Arrays.asList("call mom", "2016-03-02", "15:00","19:00");
	private static final List<String> listAdd3 = 
			Arrays.asList("call mom", "15:00", "tell her buy apple");
	private static final List<String> listAdd4 = 
			Arrays.asList("call mom", "tell her buy apple");
	private static final List<String> listAdd5 = 
			Arrays.asList("call mom", "13:00");
	private static final List<String> listAdd6 = 
			Arrays.asList("call mom", "12:00", "13:00");
	private static final List<String> listAdd7 = 
			Arrays.asList("call mom", "every", "TUESDAY");
	private static final List<String> listAdd8 = 
			Arrays.asList("call mom", "2016-03-02", "15:00");
	private static final List<String> listAdd9 = 
			Arrays.asList("call mom", "2016-03-02", "15:00");
	private static final List<String> listAdd10 = 
			Arrays.asList("call important mom", "2016-02-02", "12:00", "important");
	private static final List<String> listAdd11 = 
			Arrays.asList("call mom", "2016-02-02", "12:00", "say hello");
	private static final List<String> listAdd12 = 
			Arrays.asList("call mom", "buy apple");
	private static final List<String> listAdd13 = 
			Arrays.asList("call mom", "every", "TUESDAY", "12:00", "important");
	private static final List<String> listAdd14 = 
			Arrays.asList("call mom", "every", "TUESDAY");
	private static final List<String> listAdd15 = 
			Arrays.asList("call mom");
	private static final List<String> listAdd16 = 
			Arrays.asList("call mom", "2016-02-02", "2016-03-03");
	private static final List<String> listAdd17 = 
			Arrays.asList("call mom", "2016-02-02","12:00", "2016-03-03", "13:00", "buy apple");
	private static final List<String> listAdd18 = 
			Arrays.asList("call mom", "this week");
	private static final List<String> listAdd19 = 
			Arrays.asList("call mom", "12:00");
	private static final List<String> listAdd20 = 
			Arrays.asList("call mom", "2016-02-02");
	private static final List<String> listAdd21 = 
			Arrays.asList("call mom", "TUESDAY");
	private static final List<String> listAdd22 = 
			Arrays.asList("call mom", "today");
	private static final List<String> listAdd23 = 
			Arrays.asList("call mom");
	private static final List<String> listAdd24 = 
			Arrays.asList("call mom", "important");
	private static final List<String> listAdd25 = 
			Arrays.asList("call mom", "JULY");
	private static final List<String> listAdd26 = 
			Arrays.asList("call mom", "2016-02-02", "12:00", "2016-03-03", "13:00", "at to due from");
	private static final List<String> listAdd27 = 
			Arrays.asList("call mom", "15:00", "2016-02-02");
	private static final List<String> listAdd28 = 
			Arrays.asList("call mom", "every", "JULY");
	private static final List<String> listAdd29 = 
			Arrays.asList("call mom", "every", "JULY", "for", "2", "week");
	private static final List<String> listAdd30 = 
			Arrays.asList("call mom", "2016-02-02", "13:00", "2016-03-03", "12:00", "at to due from");
	private static final List<String> listAdd31 = 
			Arrays.asList("due at from to", "12:00");
	private static final List<String> listAdd32 = 
			Arrays.asList("due at from to", "12:00", "13:00");
	private static final List<String> listAdd33 = 
			Arrays.asList( "due at from","week","every", "TUESDAY");
	private static final List<String> listAdd34 = 
			Arrays.asList("fetch kid from school", "13:00");
	private static final List<String> listAdd35 = 
			Arrays.asList("2");
	private static final List<String> listAdd36 = 
			Arrays.asList("do EE2024");
	
	@Test
	public void testAdd1() throws Exception{
		TNotesParserAdd tester = new TNotesParserAdd(); 		
		assertEquals("i want to test", listAdd1, tester.addCommand("add call mom at 1pm".split(" ")));
		System.out.println("1. add call mom at 1pm (debug)");	
		
		assertEquals("i want to test", listAdd2, tester.addCommand("add call mom due 2-3-2016 at 15:00 to 19:00".split(" ")));
		System.out.println("2. add call mom due 2-3-2016 at 15:00 to 19:00(debug)");	
		
		
		assertEquals("i want to test", listAdd3, 
		tester.addCommand("add call mom at 3:00pm details tell her buy apple".split(" ")));
		System.out.println("3. add call mom at 3:00pm details tell her buy apple(debug)");
		
		assertEquals("i want to test", listAdd4, 
		tester.addCommand("add call mom details tell her buy apple".split(" ")));
		System.out.println("4. add call mom details tell her buy apple(debug)");
		
		assertEquals("i want to test", listAdd5, 
		tester.addCommand("add call mom due 13:00".split(" ")));
		System.out.println("5. add call mom due 13:00");
		
		assertEquals("i want to test", listAdd6, 
		tester.addCommand("add call mom from 12:00 to 13:00".split(" ")));
		System.out.println("6. add call mom from 12:00 to 13:00");
		
		assertEquals("i want to test", listAdd7, 
		tester.addCommand("add call mom every tue".split(" ")));
		System.out.println("7. add call mom every tue(small letter)");
		

	}
	@Test
	public void testAdd2() throws Exception{
		TNotesParserAdd tester = new TNotesParserAdd();
	
		assertEquals("i want to test", listAdd8, 
			tester.addCommand("add call mom due 2-3-2016 at 3:00pm".split(" ")));
			System.out.println("8. add call mom due 2-3-2016 at 3:00pm");
			
			assertEquals("i want to test", listAdd9, 
			tester.addCommand("add call mom due 2-3-2016 at 3:00 pm".split(" ")));
			System.out.println("9. add call mom due 2-3-2016 at 3:00 pm");
			
			assertEquals("i want to test", listAdd10, 
			tester.addCommand("add call important mom due 2-2-2016 at 12:00".split(" ")));
			System.out.println("10. add call important mom due 2-2-2016  at 12:00");
			assertEquals("i want to test", listAdd11, 
			tester.addCommand("add call mom due 2-2-2016 at 12:00 details say hello".split(" ")));
			System.out.println("11. add call mom due 2-2-2016 at 12:00 details say hello");
			assertEquals("i want to test", listAdd12, 
			tester.addCommand("add call mom details buy apple".split(" ")));
			System.out.println("12. add call mom details buy apple");
			assertEquals("i want to test", listAdd13, 
			tester.addCommand("add call mom due every Tue at 12:00 important".split(" ")));
			System.out.println("13. add call mom due every Tue at 12:00 important");
			assertEquals("i want to test", listAdd14, 
			tester.addCommand("add call mom due every Tuesday".split(" ")));
			System.out.println("14. add call mom due every Tuesday (with due)");
			assertEquals("i want to test", listAdd15, 
			tester.addCommand("add call mom".split(" ")));
			System.out.println("15. add call mom(can add symbols)");
			assertEquals("i want to test", listAdd16, 
			tester.addCommand("add call mom from 2-2-2016 to 3-3-2016".split(" ")));
			System.out.println("16. add call mom from 2-2-2016 to 3-3-2016)");
			assertEquals("i want to test", listAdd17, 
			tester.addCommand("add call mom from 2-2-2016 at 12:00 to 3-3-2016 at 13:00 details buy apple".split(" ")));
			System.out.println("17. add call mom from 2-2-2016 at 12:00 to 3-3-2016 at 13:00 details buy apple");
			assertEquals("i want to test", listAdd18, 
			tester.addCommand("add call mom due this week".split(" ")));
			System.out.println("18. add call mom due this week");
			assertEquals("i want to test", listAdd19, 
			tester.addCommand("add call mom at 12:00".split(" ")));
			System.out.println("19. add call mom at 12:00");
			assertEquals("i want to test", listAdd20, 
			tester.addCommand("add call mom due 2-2-2016".split(" ")));
			System.out.println("20. add call mom due 2-2-2016");
			assertEquals("i want to test", listAdd21, 
			tester.addCommand("add call mom on Tue".split(" ")));
		    System.out.println("21. add call mom on Tue");
		    assertEquals("i want to test", listAdd22, 
			tester.addCommand("add call mom today".split(" ")));
			System.out.println("22. add call mom today");
			assertEquals("i want to test", listAdd23, 
			tester.addCommand("add call mom".split(" ")));
			System.out.println("23. add call mom");
			assertEquals("i want to test", listAdd24, 
			tester.addCommand("add call mom important".split(" ")));
			System.out.println("24. add call mom important");
			assertEquals("i want to test", listAdd25, 
			tester.addCommand("add call mom at jul".split(" ")));
			System.out.println("25. add call mom at jul(small letter)");
			assertEquals("i want to test", listAdd26, 
			tester.addCommand("add call mom from 2-2-2016 at 12:00 to 3-3-2016 at 13:00 details at to due from".split(" ")));
			System.out.println("26. add call mom from 2-2-2016 at 12:00 to 3-3-2016 at 13:00 details at to due from");
			assertEquals("i want to test", listAdd27, 
			tester.addCommand("add call mom 3pm 2-2-2016".split(" ")));
			System.out.println("27. add call mom 3pm 2-2-2016(without key word)");
			assertEquals("i want to test", listAdd28, 
			tester.addCommand("add call mom every jul".split(" ")));
			System.out.println("28. add call mom every jul");
			assertEquals("i want to test", listAdd29, 
			tester.addCommand("add call mom every jul for 2 week".split(" ")));
			System.out.println("29. add call mom every jul for 2 week");
			assertEquals("i want to test", listAdd30, 
			tester.addCommand("add call mom from 2-2-2016 at 13:00 to 3-3-2016 at 12:00 details at to due from".split(" ")));
			System.out.println("30. add call mom from 2-2-2016 at 13:00 to 3-3-2016 at 12:00 details at to due from");
			assertEquals("i want to test", listAdd31, 
			tester.addCommand("add due at from to due 12:00".split(" ")));
			System.out.println("31. add due at from to due 12:00");	
			assertEquals("i want to test", listAdd32, 
			tester.addCommand("add due at from to from 12:00 to 13:00".split(" ")));
			System.out.println("32. add due at from to from 12:00 to 13:00");	
			assertEquals("i want to test", listAdd33, 
			tester.addCommand("add due at from to week every tue".split(" ")));
			System.out.println("33. add due at from to every tue");
			assertEquals("i want to test", listAdd34, 
			tester.addCommand("add fetch kid from school at 1pm".split(" ")));
			System.out.println("34. add fetch kid from school at 1pm");
			assertEquals("i want to test", listAdd35, 
			tester.addCommand("add 2".split(" ")));
			System.out.println("35. add 2");
			assertEquals("i want to test", listAdd36, 
			tester.addCommand("add do EE2024".split(" ")));
			System.out.println("36. add do EE2024");
	}

}
```
###### \src\tnote\parser\TNotesParserChange.java
``` java
package tnote.parser;
import java.util.logging.Logger;

import tnote.util.log.TNoteLogger;

import java.util.ArrayList;
/**
 * This class manages the input String after command change
 * 
 * It retrieves the contents after command word change and pass it to the
 * UI class. It manages the input into their individual types and put them into the correct positions. 
 * 
 *  The users are able to change the directory.
 */
public class TNotesParserChange {
	
	private static final String MESSAGE_KEYWORD_CHANGE_DIRECTORY = "change directory";
	private static final String MESSAGE_KEYWORD_TO = "to";
	private static final String MESSAGE_INVALIDE_DIRECTORY = "Invalid directory";
	private static final String MESSAGE_LOG_ERROR = "test Warning in parser command change";
	
	private static final int NUM_INITIALISATION = 1;
	private static final int NUM_INCREMENTATION = 1;
	
	private static final Logger logger = Logger.getGlobal();
	
	/**
	 * Return an ArrayList that contains all the contents after the command word change after 
	 * identified the change type.
	 * If valid task directories are found, contents in the list are updated.
	 * 
	 * @param changeArr	An Array input from the user.
	 * @return	The an ArrayList of split chnage type.
	 * @throws Exception 
	 */
	protected ArrayList <String> changeCommand(String[] changeArr) throws Exception{
		ArrayList<String> list = new ArrayList<String>();
		try{
			list.add(MESSAGE_KEYWORD_CHANGE_DIRECTORY);
			for (int  i= NUM_INITIALISATION;  i< changeArr.length ; i++){
				if(changeArr[i].equals(MESSAGE_KEYWORD_TO)){
					list.add(changeArr[i+NUM_INCREMENTATION].trim());
				}
			}
		}catch(Exception e){
			logger.warning(MESSAGE_LOG_ERROR); 
			throw new Exception(MESSAGE_INVALIDE_DIRECTORY);
		}	
		return list;

	}

}
```
###### \src\tnote\parser\TNotesParserChangeTest.java
``` java
package tnote.parser;

import static org.junit.Assert.assertEquals;

import java.util.Arrays;
import java.util.List;

import org.junit.Test;

public class TNotesParserChangeTest {
	
	private static final String MESSAGE_CHANGE_SUC = "change successfully";
	private static final String MESSAGE_CHANGE_FAIL = "File directory missing";
	
	private static final List<String> listChange1 = Arrays.asList("change directory", "c:/file");
	private static final List<String> listChange2 = Arrays.asList( "change directory", "d:/file");
	private static final List<String> listChange3 = Arrays.asList("change directory", "e:/file");
	private static final List<String> listChange4 = Arrays.asList("change directory");
	
	private static final String[] listChangeArr1 = {"change", "directory", "location", "to", "c:/file"};
	private static final String[] listChangeArr2 = {"change", "file", "location", "to", "d:/file"};
	private static final String[] listChangeArr3 = {"change", "place", "to", "e:/file"};
	private static final String[] listChangeArr4 = {"change", "directory"};

	@Test
	public void testChange1() throws Exception{
		TNotesParserChange tester = new TNotesParserChange(); 		
		assertEquals("i want to test", listChange1, tester.changeCommand(listChangeArr1));
		System.out.println(MESSAGE_CHANGE_SUC);

	}
	
	@Test
	public void testChange2() throws Exception{
		TNotesParserChange tester = new TNotesParserChange(); 		
		assertEquals("i want to test", listChange2, tester.changeCommand(listChangeArr2));
		System.out.println(MESSAGE_CHANGE_SUC);

	}
	
	@Test
	public void testChange3() throws Exception{
		TNotesParserChange tester = new TNotesParserChange(); 		
		assertEquals("i want to test", listChange3, tester.changeCommand(listChangeArr3));
		System.out.println(MESSAGE_CHANGE_SUC);

	}
	
	@Test
	public void testChange4() throws Exception{
		TNotesParserChange tester = new TNotesParserChange(); 		
		assertEquals("i want to test", listChange4, tester.changeCommand(listChangeArr4));
		System.out.println(MESSAGE_CHANGE_FAIL);

	}


}
```
###### \src\tnote\parser\TNotesParserDate.java
``` java

package tnote.parser;
import java.util.logging.Logger;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.DateTimeException;
import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.Month;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.List;

/**
 * This class manages all the inputs related to date.
 * 
 * It format all the date inputs in to a fixed one and state the range.
 * The formats include date
 * 
 * It retrieves the input date and pass it to the
 * rest of the Parser classes.class. 
 * 
 */
public class TNotesParserDate {
	
	
	private static final String MESSAGE_INVALID_MONTH = "Invalid month!";
	private static final String MESSAGE_INVALID_WEEKDAY = "Invalid weekday!";
	private static final String MESSAGE_INVALID_DATE_FORMAT = "invalid date!";
	private static final String MESSAGE_NULL_STRING = "";
	private static final String MESSAGE_INVALID_DATE_RANGE = "Invalid date range!";
	private static final String MESSAGE_INVALID_DATE = "Invalid date range";
	private static final String MESSAGE_STANDARD_DATE_FORMAT ="yyyy-MM-dd";
	private static final String MESSAGE_LOG_ERROR = "test Warning in parser command date";
	
	private static int NUM_SHORT_WEEKDAY = 4;
	private static int NUM_INITIALISATION = 0;
	private static int NUM_TRUE = 1;
	private static int NUM_FALSE = 0;
	private static int NUM_FIRST_WORD = 0;
	private static int NUM_SECOND_WORD = 1;
	private static int NUM_FIRST_CHAR = 0;
	private static int NUM_SUBSTRING_RANGE = 1;
	
	private static final Logger logger = Logger.getGlobal();
	
	private static final List<String> DATE_POSSIBLE_FORMAT = Collections.unmodifiableList(Arrays.asList(
			"d/M/y", "d/M/yyyy", "d/MM/yy","d/MMM/yy", "d/MMM/yyyy",
			"dd/MM/yy","dd/M/yyyy", "dd/MM/yy", "dd/MMM/yyyy", 
			"dd/MMMM/yy","d/MMMM/yyyy", "dd/MMMM/yyyy",
    		
			"d-M-y", "d-M-yyyy", "d-MM-yy","d-MMM-yyyy",
			"dd-MM-yy","dd-M-yyyy", "dd-MM-yy", "dd-MMM-yyyy", "d-MMM-yyyy",
			"d-MMMM-yy","d-MMMM-yyyy", "dd-MMMM-yyyy",
			
			"d.M.yy", "d.M.yyyy", "d.MM.yy","d.MMM.yyyy",  
			"dd.MM.yy","dd.M.yyyy", "dd.MM.yy", "dd.MMM.yyyy", 
			"dd.MMMM.yy","d.MMMM.yyyy", "dd.MMMM.yyyy",
			
			"d M y", "d M yy", "d M yyyy", "d MM yy","d MMM yyyy",  
			"dd MM yy","dd M yyyy", "dd MM yy", "dd MMM yyyy", 
			"dd MMMM yy","d MMMM yyyy", "dd MMMM yyyy"
    		));
	
	private static final List<String> WEEKDAY_POSSIBLE_FORMAT = Collections.unmodifiableList(Arrays.asList(
			"EE", "EEEE"
			));
	
	private static final List<String> MONTH_POSSIBLE_FORMAT = Collections.unmodifiableList(Arrays.asList(
			"MMM"
			));

	/**
	 * Return an String that has the correct format of month.
	 * If valid month is found, contents in the list are updated.
	 * 
	 * @param monthInPUT	An month input from the user.
	 * @return	Month with the correct format
	 * @throws DateTimeException A null exception will be thrown 
	 */
	protected String formatMonth(String monthInput) {
		String monthStr = capTheFirstChar(monthInput);
		String monthString = new String();
		Month month = null;
		
		for (String monthFormat : MONTH_POSSIBLE_FORMAT) {
			month = compareMonthFormat(monthStr, monthFormat);
			if (month != null) {
				monthString =  month.toString();
			}
			else{
				monthString =  MESSAGE_NULL_STRING;
			}
		}
		logger.warning(MESSAGE_LOG_ERROR); 	
		return monthString;
	}
	
	private Month compareMonthFormat(String monthString, String pattern) {
		assert pattern != null : MESSAGE_INVALID_MONTH;
		try {
			DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
			Month month = Month.from(formatter.parse(monthString));
			return month;
		} catch (DateTimeException e) {
			return null;
		}
	}
	
	/**
	 * Return an String that has the correct format of week days.
	 * If valid week days is found, contents in the list are updated.
	 * 
	 * @param weekDayInput	An week days input from the user.
	 * @return	week days with the correct format
	 * @throws DateTimeException A null exception will be thrown 
	 */
	 protected String formatWeekDay(String weekDayInput) {
		String dayFormat = new String();
		String weekDay = capTheFirstChar(weekDayInput);
		String weekDayString = new String();
		DayOfWeek day = null;
		
		if(weekDay.trim().length() <= NUM_SHORT_WEEKDAY){
			dayFormat = WEEKDAY_POSSIBLE_FORMAT.get(NUM_FIRST_WORD);
			
		}else{
			dayFormat = WEEKDAY_POSSIBLE_FORMAT.get(NUM_SECOND_WORD);
		}
		
		day = compareWeekDayFormat(weekDay.trim(), dayFormat);
		if (day != null) {
			weekDayString =  day.toString();
		}
		else{
			weekDayString =  MESSAGE_NULL_STRING;
		}
		logger.warning(MESSAGE_LOG_ERROR); 	
		return weekDayString;
	}
	
	 private DayOfWeek compareWeekDayFormat(String dateString, String pattern) {
		assert pattern != null : MESSAGE_INVALID_WEEKDAY;
		try {
			DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
			DayOfWeek day = DayOfWeek.from(formatter.parse(dateString));
			return day;
		} catch (DateTimeException e) {
			return null;
		}
	}
	/**
	 * Return an String that has the correct format of special days.
	 * If valid special days is found, contents in the list are updated.
	 * 
	 * @param date	An special days input from the user.
	 * @return	special days with the correct format
	 * 			-"" will be returned if there is no special days
	 */
	 protected String formatSpecialDay(String date){
		switch(date.toLowerCase()){
			case "today" :
				return "today";
			case "tomorrow" :
				return "tomorrow";
			case "tmr" :
				return "tomorrow";
			case "tonight" :
				return "tonight";
			case "week" :
				return "week";
			case "day" :
				return "day";
			case "month" :
				return "month";
			case "noon" :
				return "noon";
			case "afternoon" :
				return "afternoon";
			case "evening" :
				return "evening";
			default   :
				return "";
		}	
	}
	/**
	 * Return an String that has the correct format of date.
	 * If valid date is found, contents in the list are updated.
	 * 
	 * @param inoutDate	An date input from the user.
	 * @return	date with the correct format
	 * @throws DateTimeException A null exception will be thrown 
	 */
	 protected String formatDate(String inputDate){
	    LocalDate parsedDate = null;	
		for (String dateFormat : DATE_POSSIBLE_FORMAT) {
			parsedDate = compareDateFormat(inputDate.trim(), dateFormat);
			if (parsedDate != null) {
				return parsedDate.toString();
			}
		}
		logger.warning(MESSAGE_LOG_ERROR); 	
		return MESSAGE_NULL_STRING;
	}
	
	
	private LocalDate compareDateFormat(String dateString, String pattern) {
		assert pattern != null : MESSAGE_INVALID_DATE;	
		try {
			DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
			LocalDate date = LocalDate.parse(dateString, formatter);
			return date;
		} catch (DateTimeException e) {
			return null;
		}
	}
	/**
	 * Return an integer that will indicate if the input String is a
	 * valid date.
	 * If valid date is found, contents in the list are updated.
	 * 
	 * The date formats that can be identify by this methods
	 * are those contains "." or "-"
	 * 
	 * @param input	An time input from the user.
	 * @return	Integer that is either 1 or 0
	 */
	protected int checkDate(String input) {
		assert input != null : MESSAGE_INVALID_DATE_FORMAT;
		int inputCharLength = input.trim().length();
		for(int i =NUM_INITIALISATION; i<inputCharLength; i++){
			if(input.charAt(i) == '.' || input.charAt(i) == '-' ){
				return NUM_TRUE;
			}
		}
		return NUM_FALSE ;
	}
	
	/**
	 * Return an ArrayList that either contains the correct date format or
	 * the original string
	 * 
	 * @param inputDay	An date input ArrayList from the user.
	 * @return	updated inputDate
	 */
	protected String compareWeekDayMonth(String inputDay){
		if(!formatWeekDay(inputDay).equals(MESSAGE_NULL_STRING)){
			return formatWeekDay(inputDay);
		}
		else if(!formatMonth(inputDay).equals(MESSAGE_NULL_STRING)){
			return formatMonth(inputDay);
		}
		else if(!formatSpecialDay(inputDay).equals(MESSAGE_NULL_STRING)){
			return formatSpecialDay(inputDay);
		}
		else if(!formatDate(inputDay).equals(MESSAGE_NULL_STRING)){
			return formatDate(inputDay);
		}
		logger.warning(MESSAGE_LOG_ERROR); 	
		return inputDay;
	}
	
	/**
	 * Return an ArrayList that either contains the correct date format or
	 * the error message.
	 * 
	 * @param dateList	An time input ArrayList from the user.
	 * @return	updated ArrayList
	 * @throws DateTimeException
	 */
	protected ArrayList<String> compareDate(ArrayList<String> dateList) throws ParseException{
		SimpleDateFormat dateformat = new SimpleDateFormat(MESSAGE_STANDARD_DATE_FORMAT);
		Date dateOne = dateformat.parse(dateList.get(NUM_FIRST_WORD));
		Date dateTwo = dateformat.parse(dateList.get(NUM_SECOND_WORD));
		try{
		if (dateOne.after(dateTwo) ) {
			dateList.clear();
			dateList.add(MESSAGE_INVALID_DATE_RANGE);
		    return dateList;
		  
		}else if (dateOne.before(dateTwo) || dateOne.equals(dateTwo)) {
		  
		    return dateList;  
		}
		}catch (DateTimeException e) {
			return dateList;
		}
		logger.warning(MESSAGE_LOG_ERROR); 	
		return dateList;	

	}

	private String capTheFirstChar(String dayMonth) {
		return Character.toString(dayMonth.charAt(NUM_FIRST_CHAR)).toUpperCase() 
				+ dayMonth.substring(NUM_SUBSTRING_RANGE);
	}
		
		
}
```
###### \src\tnote\parser\TNotesParserDateTest.java
``` java
package tnote.parser;

import static org.junit.Assert.assertEquals;

import java.text.ParseException;
import java.util.ArrayList;

import org.junit.Test;

public class TNotesParserDateTest {
	TNotesParserDate date = new TNotesParserDate();
	
	@Test
	public void testFormatDate() {
		String[] testInput = {"2-2-2016", "2-Feb-2016", "16-Jul-1994",
							  "2/2/2016", "2/Feb/2016", "16/Jul/1994",
							  "2 2 2016", "2 Feb 2016", "16 Jul 1994",
							  "2.2.2016", "2.Feb.2016", "16.Jul.1994",
							  "767676767", "JDJDJDJDJ", "2294", "INFFRH95839"
				
							};
		String[] expectedOutput = {"2016-02-02", "2016-02-02", "1994-07-16",
								   "2016-02-02", "2016-02-02", "1994-07-16",
								   "2016-02-02", "2016-02-02", "1994-07-16",
								   "2016-02-02", "2016-02-02", "1994-07-16",
								   "", "", "", ""
				
							};
		String[] testOutput = new String[testInput.length];
		for (int i = 0; i < testInput.length; i++) {
			testOutput[i] = date.formatDate(testInput[i]);
			assertEquals(expectedOutput[i], testOutput[i]);
		}
		System.out.println("test parser date formatting");
	}
	
	@Test
	public void testFormatMonth() {
		String[] testInput = {"Jul", "Feb", "Jan",
							  "jul", "feb", "jan",
							  "JNVJR", "742384738", "JDJ84848"
				
							};
		String[] expectedOutput = {"JULY", "FEBRUARY", "JANUARY",
									"JULY", "FEBRUARY", "JANUARY",
									"", "", ""
				
							};
		String[] testOutput = new String[testInput.length];
		for (int i = 0; i < testInput.length; i++) {
			testOutput[i] = date.formatMonth(testInput[i]);
			assertEquals(expectedOutput[i], testOutput[i]);
		}
		System.out.println("test parser month formatting");
	}
	
	@Test
	public void testFormatWeekDay() {
		String[] testInput = {"Tue", "Wed", "Sun",
							  "tue", "wed", "sun",
							  "jsjshd", "8373773", "jdjdj83838"
							};
		String[] expectedOutput = {"TUESDAY", "WEDNESDAY", "SUNDAY",
								   "TUESDAY", "WEDNESDAY", "SUNDAY",
								   "", "", ""
				
							};
		String[] testOutput = new String[testInput.length];
		for (int i = 0; i < testInput.length; i++) {
			testOutput[i] = date.formatWeekDay(testInput[i]);
			assertEquals(expectedOutput[i], testOutput[i]);
		}
		System.out.println("test parser week days formatting");
	}
	
	@Test
	public void testFormatSpecialDay() {
		String[] testInput = {"today", "tomorrow", "tmr", "week", 
							  "tonight", "month", "day",
							  "noon", "afternoon", "evening",
							  "hshsh83838", "jsjs83838", "next day"
							};
		String[] expectedOutput = {"today", "tomorrow", "tomorrow", "week", 
				  					"tonight", "month", "day",
				  					"noon", "afternoon", "evening",
				  					"","",""
				
							};
		String[] testOutput = new String[testInput.length];
		for (int i = 0; i < testInput.length; i++) {
			testOutput[i] = date.formatSpecialDay(testInput[i]);
			assertEquals(expectedOutput[i], testOutput[i]);
		}
		System.out.println("test parser special day formatting");
	}
	
	@Test
	public void testCheckDate() {
		String[] testInput = {"2-2-2016","4-3-1994", "6.6.89","05.08.69",
							   "", "abt", "83838", "900"
				
							};
		int[] expectedOutput = {1, 1, 1, 1,
								0, 0, 0, 0
				
							};
		int[] testOutput = new int[testInput.length];
		for (int i = 0; i < testInput.length; i++) {
			testOutput[i] = date.checkDate(testInput[i]);
			assertEquals(expectedOutput[i], testOutput[i]);
		}	
		System.out.println("test check date");
	}
	
	@Test
	public void testCompareDate() throws ParseException {
		TNotesParserDate tester = new TNotesParserDate();
		ArrayList<String> timeList = new ArrayList<String>();
		ArrayList<String> timeListOutput = new ArrayList<String>();
		timeList.add("2016-02-02");
		timeList.add("2016-03-03");
		timeListOutput.add("2016-02-02");
		timeListOutput.add("2016-03-03");
		assertEquals("i want to test", timeListOutput ,tester.compareDate(timeList));
		System.out.println("The date range is correct");
		timeList.clear();
		timeList.add("2016-03-03");
		timeList.add("2016-02-02");
		timeListOutput.clear();
		timeListOutput.add("Invalid date range!");
		assertEquals("i want to test", timeListOutput ,tester.compareDate(timeList));
		System.out.println("Invalid date range");
	}
	
	@Test
	public void testCompareWeekDayMonth() throws ParseException {
		String[] testInput = {"today", "tomorrow", "tmr", "week", 
							"tonight", "month", "day",
							"noon", "afternoon", "evening",
							"Tue", "Wed", "Sun",
							"tue", "wed", "sun",
							"Jul", "Feb", "Jan",
							"jul", "feb", "jan",
							"2-2-2016", "2-Feb-2016", "16-Jul-1994",
							"2/2/2016", "2/Feb/2016", "16/Jul/1994",
							"2 2 2016", "2 Feb 2016", "16 Jul 1994",
							"2.2.2016", "2.Feb.2016", "16.Jul.1994"
							
				};
		String[] expectedOutput = {"today", "tomorrow", "tomorrow", "week", 
	  							"tonight", "month", "day",
	  							"noon", "afternoon", "evening",
	  							"TUESDAY", "WEDNESDAY", "SUNDAY",
								"TUESDAY", "WEDNESDAY", "SUNDAY",
								"JULY", "FEBRUARY", "JANUARY",
								"JULY", "FEBRUARY", "JANUARY",
								"2016-02-02", "2016-02-02", "1994-07-16",
								"2016-02-02", "2016-02-02", "1994-07-16",
								"2016-02-02", "2016-02-02", "1994-07-16",
								"2016-02-02", "2016-02-02", "1994-07-16"
	
				};
		String[] testOutput = new String[testInput.length];
			for (int i = 0; i < testInput.length; i++) {
					testOutput[i] = date.compareWeekDayMonth(testInput[i]);
					assertEquals(expectedOutput[i], testOutput[i]);
				}
		System.out.println("test compare all dates");
	}
	
	
}
```
###### \src\tnote\parser\TNotesParserDelete.java
``` java
package tnote.parser;
import java.util.ArrayList;
/**
 * This class manages the input String after command delete
 * 
 * It retrieves the contents after command word and pass it to the
 * UI class. It manages the input into their individual types and put them into the correct positions.
 * The delete types include task name and directory.
 * 
 *  The users are able to specify the type they want to delete. 
 */
public class TNotesParserDelete {
	
	private static final String MESSAGE_KEYWORD_DIRECTORY = "directory";
	private static final String MESSAGE_KEYWORD_DELETE_DIRECTORY = "delete directory";
	private static final String MESSAGE_KEYWORD_DELETE = "delete";
	private static final String MESSAGE_KEYWORD_SPACE = " ";
	
	private static int NUM_INITIALISATION = 1;
	private static int NUM_DELETE_TYPE = 2;
	
	/**
	 * This method will identify and organize the inputs after the 
	 * command word delete.
	 * 
	 * @param  deleteArr All Array input by the user
	 * @return deleteList An ArrayList
	 */
	protected ArrayList <String> deleteCommand(String[] deleteArr) throws Exception{
		
		ArrayList<String> deleteList = new ArrayList<String>();
			if(deleteArr[1].equals(MESSAGE_KEYWORD_DIRECTORY)){
			
				deleteList.add(MESSAGE_KEYWORD_DELETE_DIRECTORY);
				deleteList.add(deleteArr[NUM_DELETE_TYPE].trim());
			}
			else{
			
				deleteList.add(MESSAGE_KEYWORD_DELETE);
				deleteList.add(taskNameFloat(deleteArr).trim());
			}
		return deleteList;
	
	}
	
	private String taskNameFloat(String[] arr) {
		String task = new String();
		for(int i=NUM_INITIALISATION;i<arr.length;i++ ){
			task += arr[i] + MESSAGE_KEYWORD_SPACE;
		}	
		return task;
	}
	

}
```
###### \src\tnote\parser\TNotesParserDeleteTesting.java
``` java
package tnote.parser;

import static org.junit.Assert.assertEquals;
import java.util.Arrays;
import java.util.List;

import org.junit.Test;

public class TNotesParserDeleteTesting {

	private static final String MESSAGE_DELETE_DIR_SUC = "delete directory successfully";
	private static final String MESSAGE_DELETE_TITLE_SUC = "delete title successfully";
	private static final String MESSAGE_DELETE_ALL_SUC = "delete all successfully";
	
	private static final List<String> listDelete1 = Arrays.asList("delete directory", "c:/file");
	private static final List<String> listDelete2 = Arrays.asList("delete", "buy red apple");
	private static final List<String> listDelete3 = Arrays.asList("delete", "all");

	private static final String[] listDeleteArr1 = {"delete", "directory", "c:/file"};
	private static final String[] listDeleteArr2 = {"delete", "buy", "red", "apple"};
	private static final String[] listDeleteArr3 = {"delete", "all"};


	@Test
	public void testDelete1() throws Exception{
		TNotesParserDelete tester = new TNotesParserDelete(); 		
		assertEquals("i want to test", listDelete1, tester.deleteCommand(listDeleteArr1));
		System.out.println(MESSAGE_DELETE_DIR_SUC);

	}
	
	@Test
	public void testDelete2() throws Exception{
		TNotesParserDelete tester = new TNotesParserDelete(); 		
		assertEquals("i want to test", listDelete2, tester.deleteCommand(listDeleteArr2));
		System.out.println(MESSAGE_DELETE_TITLE_SUC);

	}
	
	@Test
	public void testDelete3() throws Exception{
		TNotesParserDelete tester = new TNotesParserDelete(); 		
		assertEquals("i want to test", listDelete3, tester.deleteCommand(listDeleteArr3));
		System.out.println(MESSAGE_DELETE_ALL_SUC);

	}
	

}
```
###### \src\tnote\parser\TNotesParserEdit.java
``` java
package tnote.parser;

import java.util.ArrayList;

/**
 * This class manages the input String after command edit
 * 
 * It retrieves the contents after command word edit and pass it to the
 * UI class. It manages the input into their individual types and put them into the correct positions. 
 * 
 *  The users are able to edit the time, date, name, status and importance of the task.
 */
public class TNotesParserEdit {
	private TNotesParserTime time;
	private TNotesParserDate date;
	private TNotesParserQuery query;
	
	public TNotesParserEdit(){
		time = new TNotesParserTime();
		date = new TNotesParserDate();
		query = new TNotesParserQuery();
	}
	//private static final String MESSAGE_LOG_ERROR = "test Warning in parser command";
	
	private static int NUM_NEXT_STR = 1;
	private static int NUM_START_FROM_SECOND_STR = 1;
	private static final int NUM_INTIALISATION = 0;
	
	//private static final Logger logger = Logger.getGlobal();
	
	/**
	 * Return an ArrayList that contains the contents after the command word 
	 * edit.
	 * 
	 * @param editArr	An content array from the user.
	 * @return	editList An ArrayList that contains Strings of the different types.
	 * @throws Exception 
	 *              - throw error when the Array input is
	 *              invalid.
	 */
	protected ArrayList<String> editCommand(String[] editArr) throws Exception{
		ArrayList<String> editList = new ArrayList<String>();
		for (int  f= NUM_START_FROM_SECOND_STR;  f< editArr.length ; f++){
			if (editArr[f].equals("details")) {
				editList.add(NUM_INTIALISATION, query.taskNameString(editArr, f).trim());
				editList.add(editArr[f]);//"details"
				editList.add(keyWordNext(f, editArr).trim());
					
			}
			else if(editArr[f].equals("status")){
				editList.add(NUM_INTIALISATION, query.taskNameString(editArr, f).trim());
				editList.add(editArr[f].trim());
				editList.add(editArr[f+NUM_NEXT_STR].trim());
			}
			else if(editArr[f].equals("startTime") || editArr[f].equals("endTime") || editArr[f].equals("time")){
				editList.add(NUM_INTIALISATION, query.taskNameString(editArr, f).trim());
				editList.add(editArr[f]);
				editList.add(time.formatTime(editArr[f+NUM_NEXT_STR]).toString());
			}
			else if(editArr[f].equals("startDate") || editArr[f].equals("endDate") ||editArr[f].equals("date")){
				editList.add(NUM_INTIALISATION, query.taskNameString(editArr, f).trim());
				editList.add(editArr[f]);
				editList.add(date.formatDate(editArr[f+NUM_NEXT_STR]));
			}
			else if(editArr[f].equals("name")){
				editList.add(NUM_INTIALISATION, query.taskNameString(editArr, f).trim());
				editList.add(editArr[f]);
				editList.add(newName(f, editArr).trim());	
			}
			else if(editArr[f].equals("importance")){
				editList.add(NUM_INTIALISATION, query.taskNameString(editArr, f).trim());
				editList.add(editArr[f]);
				editList.add(editArr[f+NUM_NEXT_STR]);
			}
		}
		if(editList.isEmpty()){
			editList.add(query.taskNameFloat(editArr));
		}

		return editList;
	}
	
	private String keyWordNext(int f, String editArr[]) throws Exception{
		String details = new String();
		for(int i = f+NUM_NEXT_STR; i<editArr.length; i++){
			details +=editArr[i]+" ";
		}	
		return details;
	}
	
	private String newName(int f, String editArr[]) throws Exception{
		String newName = new String();
		for(int j = f+NUM_NEXT_STR; j<editArr.length; j++){
			
			newName += editArr[j]+ " ";	
		}
		return newName;
	}
	

}
```
###### \src\tnote\parser\TNotesParserEditTest.java
``` java
package tnote.parser;

import static org.junit.Assert.assertEquals;
import java.util.Arrays;
import java.util.List;

import org.junit.Test;

public class TNotesParserEditTest {
	
	private static final String MESSAGE_VIEW_SUC = "edit successfully";
	private static final List<String> listEdit1 = 
			Arrays.asList("call mom", "status", "done");
	private static final List<String> listEdit2 = 
			Arrays.asList("call mom", "endDate", "2016-03-02");
	private static final List<String> listEdit3 = 
			Arrays.asList("call mom", "details", "buy apple");
	private static final List<String> listEdit4 = 
			Arrays.asList("call mom", "importance", "yes");
	
	private static final String[] listEditArr1 = {"edit", "call","mom", "status", "done"};
	private static final String[] listEditArr2 = {"edit", "call","mom","endDate", "2-3-2016"};
	private static final String[] listEditArr3 = {"edit", "call","mom", "details","buy","apple"};
	private static final String[] listEditArr4 = {"edit", "call","mom", "importance", "yes"};
	
	@Test
	public void testEdit1() throws Exception{
		TNotesParserEdit tester = new TNotesParserEdit(); 		
		assertEquals("i want to test", listEdit1, tester.editCommand(listEditArr1));
		System.out.println(MESSAGE_VIEW_SUC);

	}
	@Test
	public void testEdit2() throws Exception{
		TNotesParserEdit tester = new TNotesParserEdit(); 		
		assertEquals("i want to test", listEdit2, tester.editCommand(listEditArr2));
		System.out.println(MESSAGE_VIEW_SUC);

	}
	@Test
	public void testView3() throws Exception{
		TNotesParserEdit tester = new TNotesParserEdit(); 		
		assertEquals("i want to test", listEdit3, tester.editCommand(listEditArr3));
		System.out.println(MESSAGE_VIEW_SUC);

	}
	@Test
	public void testView4() throws Exception{
		TNotesParserEdit tester = new TNotesParserEdit(); 		
		assertEquals("i want to test", listEdit4, tester.editCommand(listEditArr4));
		System.out.println(MESSAGE_VIEW_SUC);

	}

}
```
###### \src\tnote\parser\TNotesParserQuery.java
``` java
package tnote.parser;
import java.util.logging.Logger;

import tnote.util.log.TNoteLogger;

/**
 * This class manages all the checking in the input String. It will indicate whether a particular 
 * word is in the sentence.
 * 
 * It retrieves the necessary information about tasks and returns it to the
 * UI class
 * 
 */

public class TNotesParserQuery {
	
	private static final String MESSAGE_ISLETTER = "[a-zA-Z]+";
	private static final String MESSAGE_NULL_INPUT_ARRAY = "Null input array";
	private static final String MESSAGE_NULL_AFTER_BEFORE_ARRAY = "Null after and before array";
	private static final String MESSAGE_LOG_ERROR = "test Warning in parser command";
	
	private static int NUM_INITIALISATION = 0;
	private static int NUM_TRUE = 1;
	private static int NUM_FALSE = 0;
	private static int NUM_START_FROM_SECOND_STR = 1;
	
	private static final Logger logger = Logger.getGlobal();
	
	private static final String ARR_IMPORTANT [] = {
			"impt","important","importance",
			"compulsory", "essential",
			"indispensable", "key", "crucial",
			};
	
	
	/**
	 * Return an integer which will indicate the presence 
	 * 		   of before and after.
	 * 
	 * @param arr	An Array input from the user.
	 * @return An integer
	 * @throws Exception 
	 */
	protected int checkAfterBefore(String arr[]) throws Exception{
		assert arr != null : MESSAGE_NULL_AFTER_BEFORE_ARRAY;	
		
		int indexThe = NUM_INITIALISATION;
		int indexKey = NUM_INITIALISATION;
		try{
		for(int i=NUM_INITIALISATION;i<arr.length;i++){
			if(arr[i].equals("the")){
				indexThe = i;
			}
		}
		for(int j=NUM_INITIALISATION;j<arr.length;j++){
			if(arr[j].equals("after") ||arr[j].equals("before")){
				indexKey = j;
			}
		}
		}catch(Exception e){
			logger.warning(MESSAGE_LOG_ERROR);
			throw new Exception(MESSAGE_NULL_INPUT_ARRAY);
		}
		if(indexThe<indexKey){
			return NUM_TRUE;
		}
		else{
			return NUM_FALSE;
		} 
		
	}
	/**
	 * Return an String that contains a floating task
	 * 
	 * @param arr	An Array input from the user.
	 * @return String
	 */
	protected String taskNameFloat(String[] arr)throws Exception {
		String task = new String();
		for(int j=NUM_START_FROM_SECOND_STR;j<arr.length;j++ ){
			task += arr[j] + " ";
		}	
		return task.trim();
	}
	/**
	 * Return an Integer that indicate the presence of 
	 * the key word to.
	 * 
	 * @param arr	An Array input from the user.
	 * @return Integer
	 */
	protected int checkViewTo(String[] arr) throws Exception{
		for(int i =NUM_INITIALISATION; i<arr.length;i++){
			if(arr[i].equals("to")){
				return NUM_TRUE;
			}
		}
		return NUM_FALSE;
	}
	/**
	 * Return an Integer that indicate the presence of 
	 * the key word important.
	 * 
	 * @param arr	An Array input from the user.
	 * @return Integer
	 */
	protected int findImpt(String[] arr) throws Exception{
		int index = NUM_INITIALISATION;
		for (int i=NUM_INITIALISATION;i<arr.length;i++){
			for(int j=NUM_INITIALISATION;j<ARR_IMPORTANT.length;j++){
				if(arr[i].equals(ARR_IMPORTANT[j])){
					index = NUM_TRUE;
				}
			}
		}
		return index;
	}
	/**
	 * Return an Integer that indicate the presence of 
	 * the letters.
	 * 
	 * @param nextString An String input from the user.
	 * @return Integer
	 * @throws Exception 
	 */
	protected int isLetters(String nextString) throws Exception {
		if (nextString.matches(MESSAGE_ISLETTER)) {
			return NUM_TRUE;
		} else {
			return NUM_FALSE;
		}
		
	}
	/**
	 * Return an String that indicate the task name
	 *The task name is not a floating task
	 *The task length is indicated by the key words 
	 * 
	 * @param arr An Array input from the user.
	 * 		  count An integer that indicat the position of the key word
	 * @return String The task name
	 */
	protected String taskNameString(String arr[], int count) throws Exception{
		String task = new String();
		task = "";
		for(int i =NUM_START_FROM_SECOND_STR;i<count ;i++){
			task += arr[i]+" ";
		}		
		return task.trim();
	}

}
```
###### \src\tnote\parser\TNotesParserQueryTest.java
``` java
package tnote.parser;

import static org.junit.Assert.assertEquals;
import org.junit.Test;

public class TNotesParserQueryTest {
	
	@Test
	public void testCheckAfterBefore() throws Exception{
		TNotesParserQuery tester = new TNotesParserQuery(); 		
		assertEquals("i want to test",1, tester.checkAfterBefore("the day after tomorrow".split(" ")));
		System.out.println("'after' is present");
		assertEquals("i want to test",1, tester.checkAfterBefore("the week before nexy year".split(" ")));
		System.out.println("'before' is present");
		assertEquals("i want to test",0, tester.checkAfterBefore("the next day".split(" ")));
		System.out.println("both 'before' and 'after' are absent");

	}
	@Test
	public void testTaskNameFloat() throws Exception{
		TNotesParserQuery tester = new TNotesParserQuery(); 		
		assertEquals("i want to test", "call mom" , tester.taskNameFloat("add call mom".split(" ")));
		System.out.println("call mom");
		assertEquals("i want to test", "fetch kid from school" ,
				tester.taskNameFloat("add fetch kid from school".split(" ")));
		System.out.println("fetch kid from school");
		assertEquals("i want to test", "fed dog" ,
				tester.taskNameFloat("add fed dog".split(" ")));
		System.out.println("fed dog");

	}
	
	@Test
	public void testCheckViewTo() throws Exception{
		TNotesParserQuery tester = new TNotesParserQuery(); 		
		assertEquals("i want to test", 1 , tester.checkViewTo("to 2-2-2016".split(" ")));
		System.out.println("'to' is present");
		assertEquals("i want to test", 1 , tester.checkViewTo("from 13:00 to 4pm".split(" ")));
		System.out.println("'to' is present");
		assertEquals("i want to test", 0 , tester.checkViewTo("from 13:00 4pm".split(" ")));
		System.out.println("'to' is absent");

	}
	
	@Test
	public void testFindImpt() throws Exception{
		TNotesParserQuery tester = new TNotesParserQuery(); 		
		assertEquals("i want to test", 1 , tester.findImpt("important task".split(" ")));
		System.out.println("'important' is present");
		assertEquals("i want to test", 1 , tester.findImpt("compulsory task".split(" ")));
		System.out.println("'important' is present");
		assertEquals("i want to test", 1 , tester.findImpt("crucial task".split(" ")));
		System.out.println("'important' is present");
		assertEquals("i want to test", 1 , tester.findImpt("key task".split(" ")));
		System.out.println("'important' is present");
		assertEquals("i want to test", 1 , tester.findImpt("essential task".split(" ")));
		System.out.println("'important' is present");
		assertEquals("i want to test", 0 , tester.findImpt("must do task".split(" ")));
		System.out.println("'important' is absent");
		assertEquals("i want to test", 0 , tester.findImpt("to-do task".split(" ")));
		System.out.println("'important' is absent");
		assertEquals("i want to test", 0 , tester.findImpt("happy task".split(" ")));
		System.out.println("'important' is absent");
		assertEquals("i want to test", 0 , tester.findImpt("task".split(" ")));
		System.out.println("'important' is absent");	

	}
	
	@Test
	public void testTaskNameString() throws Exception{
		TNotesParserQuery tester = new TNotesParserQuery(); 		
		assertEquals("i want to test", "important task" , tester.taskNameString("add important task".split(" "), 3));	
		System.out.println("important task");	
		assertEquals("i want to test", "call mom" , tester.taskNameString("add call mom".split(" "), 3));	
		System.out.println("call mom");
		assertEquals("i want to test", "buy apple from market" , tester.taskNameString("add buy apple from market".split(" "), 5));	
		System.out.println("buy apple from market");
		assertEquals("i want to test", "go home" , tester.taskNameString("add go home".split(" "), 3));	
		System.out.println("go home");
		assertEquals("i want to test", "" , tester.taskNameString("add".split(" "), 1));	
		System.out.println("empty Array");

	}
	
	@Test
	public void testIsLetter() throws Exception{
		TNotesParserQuery tester = new TNotesParserQuery(); 		
		assertEquals("i want to test", 0 , tester.isLetters(""));	
		System.out.println("empty String");	
		assertEquals("i want to test", 0 , tester.isLetters("//@#$%^&*()"));	
		System.out.println("String does not made up of all the letters");
		assertEquals("i want to test", 0 , tester.isLetters("///aa???"));	
		System.out.println("String does not made up of all the letters");
		assertEquals("i want to test", 0 , tester.isLetters("736634728"));	
		System.out.println("String does not made up of all the letters");
		assertEquals("i want to test", 0 , tester.isLetters("hahah*&^%"));	
		System.out.println("String does not made up of all the letters");

	}

}
```
###### \src\tnote\parser\TNotesParserSearch.java
``` java
package tnote.parser;
import java.util.logging.Logger;

import tnote.util.log.TNoteLogger;

import java.util.ArrayList;

/**
 * This class manages the input String after command search
 * 
 * It retrieves the contents after command word search and pass it to the
 * UI class. It split all Strings according to space.
 * 
 *  The users are able to search by letters.
 */
public class TNotesParserSearch { 
	private static final String MESSAGE_EMPTY_INPUT = "Empty input search contents";
	private static final String MESSAGE_INVALID_SEARCH = "Invalid serach";
	private static final String MESSAGE_LOG_ERROR = "test Warning in parser command";
	private static final String MESSAGE_EMPTY = "Nothing to search";
	
	private static final int NUM_INITIALISATION = 1;
	private static final int NUM_EMPTY_ARR = 1;
	
	private static final Logger logger = Logger.getGlobal();
	
	/**
	 * Return an ArrayList that contains all the contents after the command word search.
	 * 
	 * @param searchArr	An Array input from the user.
	 * @return An ArrayList of split sort type.
	 * @throws Exception 
	 */
	
	protected ArrayList <String> searchCommand(String[] searchArr){
		ArrayList<String> list = new ArrayList<String>();
		assert searchArr != null : MESSAGE_EMPTY_INPUT;	
		try {
			if(searchArr.length == NUM_EMPTY_ARR){
				logger.warning(MESSAGE_LOG_ERROR);
				System.out.println(MESSAGE_EMPTY);
			}
			throw new Exception(MESSAGE_INVALID_SEARCH );
		} catch (Exception e) {	
			for(int i=NUM_INITIALISATION; i<searchArr.length; i++){
				list.add(searchArr[i].trim());
			}
			return list;
		}

     }
}
```
###### \src\tnote\parser\TNotesParserSearchTest.java
``` java
package tnote.parser;
import static org.junit.Assert.assertEquals;
import java.util.Arrays;
import java.util.List;

import org.junit.Test;

public class TNotesParserSearchTest {
	private static final String MESSAGE_SEARCH_SUC = "search call mom successfully";
	
	private static final List<String> listSearch1 = Arrays.asList("call", "mom");
	private static final List<String> listSearch2 = Arrays.asList( "happy", "days");
	private static final List<String> listSearch3 = Arrays.asList("Adam");
	
	private static final String[] listSearchArr1 = {"search", "call", "mom"};
	private static final String[] listSearchArr2 = {"search", "happy", "days"};
	private static final String[] listSearchArr3 = {"search", "Adam"};

	@Test
	public void testSort1() throws Exception{
		TNotesParserSearch tester = new TNotesParserSearch(); 		
		assertEquals("i want to test", listSearch1, tester.searchCommand(listSearchArr1));
		System.out.println(MESSAGE_SEARCH_SUC);

	}
	
	@Test
	public void testSort2() throws Exception{
		TNotesParserSearch tester = new TNotesParserSearch(); 			
		assertEquals("i want to test", listSearch2, tester.searchCommand(listSearchArr2));
		System.out.println(MESSAGE_SEARCH_SUC);

	}
	
	@Test
	public void testSort3() throws Exception{
		TNotesParserSearch tester = new TNotesParserSearch(); 		
		assertEquals("i want to test", listSearch3, tester.searchCommand(listSearchArr3));
		System.out.println(MESSAGE_SEARCH_SUC);
	}

}
```
###### \src\tnote\parser\TNotesParserSet.java
``` java
package tnote.parser;
import java.util.ArrayList;
import java.util.logging.Logger;

import tnote.util.log.TNoteLogger;

/**
 * This class manages the input String after command set
 * 
 * It retrieves the contents after command word set and pass it to the
 * UI class. It manages the input into their individual status and put them into the correct positions. 
 * 
 */
public class TNotesParserSet {
	private static final String MESSAGE_SPACE = " ";
	private static final String MESSAGE_INVALID_STATUS = "Invalid status";
	private static final String MESSAGE_EMPTY_INPUT = "Empty input after set command";
	private static final String MESSAGE_LOG_ERROR = "Warning in parser command set";
	
	private static final int NUM_INITIALISATION = 1;
	private static final int NUM_INITIALISATION_ZERO = 0;
	private static final int NUM_DECREMENTATION = 1;
	private static final int NUM_TRUE = 1;
	private static final int NUM_FALSE = 0;
	
	
	private static final String ARR_STATUS [] = {"done", "undone", "complete", "incomplete"};
	
	private static final Logger logger = Logger.getGlobal();
	
	/**
	 * Return an ArrayList that contains all the contents after the command word set after 
	 * identified the set status.
	 * If valid task status are found, contents in the list are updated.
	 * 
	 * @param setArr	An Array input from the user.
	 * @return	The an ArrayList of split String.
	 * @throws Exception 
	 */
	protected ArrayList <String> setCommand(String[] setArr) throws Exception{
		assert setArr != null : MESSAGE_EMPTY_INPUT;
		ArrayList<String> list = new ArrayList<String>();
		String title = new String();
		if(checkDone(setArr[setArr.length-NUM_DECREMENTATION]) == NUM_TRUE){
			for(int i = NUM_INITIALISATION; i<setArr.length-NUM_DECREMENTATION;i++){
				title += setArr[i] + MESSAGE_SPACE;
			}
			list.add(title.trim());
			list.add(setArr[setArr.length-NUM_DECREMENTATION].trim());
		}
		else{
			logger.warning(MESSAGE_LOG_ERROR); 
			System.out.println(MESSAGE_INVALID_STATUS);
		}	
		return list;
	}

	
	private int checkDone(String lastWord){
		for(int i=NUM_INITIALISATION_ZERO;i<ARR_STATUS.length;i++){
			if(lastWord.equals(ARR_STATUS[i])){
				return NUM_TRUE;
			}
		}
		logger.warning(MESSAGE_LOG_ERROR); 
		return NUM_FALSE;
	}

}
```
###### \src\tnote\parser\TNotesParserSetTest.java
``` java
package tnote.parser;

import static org.junit.Assert.assertEquals;
import java.util.Arrays;
import java.util.List;

import org.junit.Test;

public class TNotesParserSetTest {

	private static final String MESSAGE_SET_SUC = "set successfully";
	private static final String MESSAGE_SET_FAIL = "set status fail";
	
	private static final List<String> listSet1 = Arrays.asList("call mom", "complete");
	private static final List<String> listSet2 = Arrays.asList("buy red", "undone");

	private static final String[] listSetArr1 = {"set", "call", "mom", "complete"};
	private static final String[] listSetArr2 = {"set", "buy", "red", "undone"};
	private static final String[] listSetArr3 = {"set", "happy", "day"};
	


	@Test
	public void testSet1() throws Exception{
		TNotesParserSet tester = new TNotesParserSet(); 		
		assertEquals("i want to test", listSet1, tester.setCommand(listSetArr1));
		System.out.println(MESSAGE_SET_SUC);

	}
	
	@Test
	public void testSet2() throws Exception{
		TNotesParserSet tester = new TNotesParserSet(); 		
		assertEquals("i want to test", listSet2, tester.setCommand(listSetArr2));
		System.out.println(MESSAGE_SET_SUC);

	}
	
	@Test
	public void testSet3() {
		try {
		TNotesParserSet tester = new TNotesParserSet(); 		
		tester.setCommand(listSetArr3);
		System.out.println(MESSAGE_SET_FAIL);
		} catch (Exception e) {
			assertEquals("Invalid status", e.getMessage());
		}

	}


}
```
###### \src\tnote\parser\TNotesParserSort.java
``` java
package tnote.parser;
import java.util.ArrayList;
import java.util.logging.Logger;

import tnote.util.log.TNoteLogger;

/**
 * This class manages the input String after command sort
 * 
 * It retrieves the contents after command word sort and pass it to the
 * UI class. It manages the input into their individual types and put them into the correct positions. 
 * 
 *  The users are able to sort by name or importance.
 */
public class TNotesParserSort{
	
	private static final String MESSAGE_KEYWORD_BY = "by";
	private static final String MESSAGE_INVALID_SORT_TYPE = "Invalid sort type";
	private static final String MESSAGE_EMPTY_INPUT = "Empty input sort contents";
	private static final String MESSAGE_LOG_ERROR = "test Warning in parser command";
	
	private static final int NUM_FIRST_SORT_TYPE = 1;
	private static final int NUM_SECOND_SORT_TYPE = 2;
	
	private static final Logger logger = Logger.getGlobal();
	/**
	 * Return an ArrayList that contains all the contents after the command word sort after 
	 * identified the sort type.
	 * If valid task names, time and date are found, contents in the list are updated.
	 * 
	 * @param sortArr	An Array input from the user.
	 * @return	The an ArrayList of split sort type.
	 * @throws Exception 
	 */
	protected ArrayList <String> sortCommand(String[] sortArr) throws Exception{
		assert sortArr != null : MESSAGE_EMPTY_INPUT;	
		ArrayList<String> sortList = new ArrayList<String>();
		if(sortArr[NUM_FIRST_SORT_TYPE].equals(MESSAGE_KEYWORD_BY)){
			sortList.add(sortArr[NUM_SECOND_SORT_TYPE].trim());
			return sortList;
		}
		else{
			logger.warning(MESSAGE_LOG_ERROR);
			sortList.add(MESSAGE_INVALID_SORT_TYPE);
			return sortList;
		}
	}
}



```
###### \src\tnote\parser\TNotesParserSortTest.java
``` java
package tnote.parser;
import static org.junit.Assert.assertEquals;
import java.util.Arrays;
import java.util.List;

import org.junit.Test;

public class TNotesParserSortTest {
	private static final String MESSAGE_SORT_SUC = "sort by importance sorted successfully";
	private static final String MESSAGE_SORT_FAIL = "sorting failed";
	
	private static final List<String> listSort1 = Arrays.asList( "importance");
	private static final List<String> listSort2 = Arrays.asList( "Invalid sort type");
	private static final List<String> listSort3 = Arrays.asList( "name");
	
	private static final String[] listSortArr1 = {"sort", "by","importance"};
	private static final String[] listSortArr2 = {"sort", "call mom"};
	private static final String[] listSortArr3 = {"sort", "by","name"};

	@Test
	public void testSort1() throws Exception{
		TNotesParserSort tester = new TNotesParserSort(); 		
		assertEquals("i want to test", listSort1, tester.sortCommand(listSortArr1));
		System.out.println(MESSAGE_SORT_SUC);
	}
	@Test
	public void testSort2() throws Exception{
		TNotesParserSort tester = new TNotesParserSort(); 		
		assertEquals("i want to test", listSort3, tester.sortCommand(listSortArr3));
		System.out.println(MESSAGE_SORT_SUC);
	}
	@Test
	public void testSort3() throws Exception{
		TNotesParserSort tester = new TNotesParserSort(); 		
		assertEquals("i want to test", listSort2, tester.sortCommand(listSortArr2));
		System.out.println(MESSAGE_SORT_FAIL);
	}
}
```
###### \src\tnote\parser\TNotesParserTest.java
``` java
package tnote.parser;
import static org.junit.Assert.assertEquals;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.junit.Test;

/**
 * This class will test all the input and output from all the 
 * public classes. 
 * 
 * There is no way to test natural languages because the result varies day after day.
 */
public class TNotesParserTest {
	private static final String TEXT_EXIT = "exit command successful";
	public static ArrayList<String> listExit = new ArrayList<String>();
	private static final List<String> listAdd1 = 
			Arrays.asList("add","call mom", "13:00");
	private static final List<String> listAdd2 = 
			Arrays.asList("add", "call mom", "2016-03-02", "15:00","19:00");
	private static final List<String> listAdd3 = 
			Arrays.asList("add","call mom", "15:00", "tell her buy apple");
	private static final List<String> listAdd4 = 
			Arrays.asList("add", "call mom", "tell her buy apple");
	private static final List<String> listAdd5 = 
			Arrays.asList("add", "call mom", "13:00");
	private static final List<String> listAdd6 = 
			Arrays.asList("add", "call mom", "12:00", "13:00");
	private static final List<String> listAdd7 = 
			Arrays.asList("add", "call mom", "every", "TUESDAY");
	private static final List<String> listAdd8 = 
			Arrays.asList("add", "call mom", "2016-03-02", "15:00");
	private static final List<String> listAdd9 = 
			Arrays.asList("add", "call mom", "2016-03-02", "15:00");
	private static final List<String> listAdd10 = 
			Arrays.asList("add", "call important mom", "2016-02-02", "12:00", "important");
	private static final List<String> listAdd11 = 
			Arrays.asList("add", "call mom", "2016-02-02", "12:00", "say hello");
	private static final List<String> listAdd12 = 
			Arrays.asList("add", "call mom", "buy apple");
	private static final List<String> listAdd13 = 
			Arrays.asList("add", "call mom", "every", "TUESDAY", "12:00", "important");
	private static final List<String> listAdd14 = 
			Arrays.asList("add", "call mom", "every", "TUESDAY");
	private static final List<String> listAdd15 = 
			Arrays.asList("add", "call mom");
	private static final List<String> listAdd16 = 
			Arrays.asList("add", "call mom", "2016-02-02", "2016-03-03");
	private static final List<String> listAdd17 = 
			Arrays.asList("add", "call mom", "2016-02-02","12:00", "2016-03-03", "13:00", "buy apple");
	private static final List<String> listAdd18 = 
			Arrays.asList("add", "call mom", "this week");
	private static final List<String> listAdd19 = 
			Arrays.asList("add", "call mom", "12:00");
	private static final List<String> listAdd20 = 
			Arrays.asList("add", "call mom", "2016-02-02");
	private static final List<String> listAdd21 = 
			Arrays.asList("add", "call mom", "TUESDAY");
	private static final List<String> listAdd22 = 
			Arrays.asList("add", "call mom", "today");
	private static final List<String> listAdd23 = 
			Arrays.asList("add", "call mom");
	private static final List<String> listAdd24 = 
			Arrays.asList("add", "call mom", "important");
	private static final List<String> listAdd25 = 
			Arrays.asList("add", "call mom", "JULY");
	private static final List<String> listAdd26 = 
			Arrays.asList("add", "call mom", "2016-02-02", "12:00", "2016-03-03", "13:00", "at to due from");
	private static final List<String> listAdd27 = 
			Arrays.asList("add", "call mom", "15:00", "2016-02-02");
	private static final List<String> listAdd28 = 
			Arrays.asList("add", "call mom", "every", "JULY");
	private static final List<String> listAdd29 = 
			Arrays.asList("add", "call mom", "every", "JULY", "for", "2", "week");
	private static final List<String> listAdd30 = 
			Arrays.asList("add", "call mom", "2016-02-02", "13:00", "2016-03-03", "12:00", "at to due from");
	private static final List<String> listAdd31 = 
			Arrays.asList("add", "due at from to", "12:00");
	private static final List<String> listAdd32 = 
			Arrays.asList("add", "due at from to", "12:00", "13:00");
	private static final List<String> listAdd33 = 
			Arrays.asList("add", "due at from","week","every", "TUESDAY");
	private static final List<String> listAdd34 = 
			Arrays.asList("add", "fetch kid from school", "13:00");
	private static final List<String> listAdd35 = 
			Arrays.asList("add", "2");
	private static final List<String> listAdd36 = 
			Arrays.asList("add", "do EE2024");
	///////////////////////////////////////////////////////////////////////////
	private static final List<String> listEdit1 = 
			Arrays.asList("edit", "call mom", "status", "done");
	private static final List<String> listEdit2 = 
			Arrays.asList("edit", "call mom", "endDate", "2016-03-02");
	private static final List<String> listEdit3 = 
			Arrays.asList("edit", "call mom", "details", "buy apple");
	private static final List<String> listEdit4 = 
			Arrays.asList("edit", "call mom", "importance", "yes");
	////////////////////////////////////////////////////////////////////////////
	private static final List<String> listView1 = 
			Arrays.asList("view", "2016-03-02", "2016-03-04");
	private static final List<String> listView2 = 
			Arrays.asList("view", "i will do homework");
	private static final List<String> listView3 = 
			Arrays.asList("view", "i want to go to school");
	private static final List<String> listView4 = 
			Arrays.asList("view", "today");
	private static final List<String> listView5 = 
			Arrays.asList("view", "2016-03-04");
	private static final List<String> listView6 = 
			Arrays.asList("view", "tomorrow");
	private static final List<String> listView7 = 
			Arrays.asList("view", "JANUARY", "FEBRUARY");
	private static final List<String> listView8 = 
			Arrays.asList("view","next", "month");
	private static final List<String> listView9 = 
			Arrays.asList("view","next" ,"FEBRUARY");
	private static final List<String> listView10 = 
			Arrays.asList("view","2");
	private static final List<String> listView11 = 
			Arrays.asList("view","notes");
	////////////////////////////////////////////////////////////////////////////
	private static final List<String> listSet1 = 
			Arrays.asList("set", "call mom", "complete");
	////////////////////////////////////////////////////////////////////////////
	private static final List<String> listDelete1 = 
			Arrays.asList("delete directory", "c:/file");
	private static final List<String> listDelete2 = 
			Arrays.asList("delete", "buy red apple");
	private static final List<String> listDelete3 = 
			Arrays.asList("delete", "all");
	////////////////////////////////////////////////////////////////////////////
	private static final List<String> listChange1 = 
			Arrays.asList("change directory", "c:/file");
	////////////////////////////////////////////////////////////////////////////
	private static final List<String> listSearch1 = 
			Arrays.asList("search", "call", "mom");
	////////////////////////////////////////////////////////////////////////////
	private static final List<String> listSort1 = 
			Arrays.asList("sort", "importance");
	private static final List<String> listSort2 = 
			Arrays.asList("sort", "name");
	////////////////////////////////////////////////////////////////////////////
	private static final List<String> list1 = 
			Arrays.asList("Invalid command has been entered!");
	
	@Test
	public void checkCommandExit() throws Exception{
		TNotesParser tester = new TNotesParser(); 		
		listExit.add("exit");
		assertEquals("i want to test", listExit, tester.checkCommand("exit"));
		System.out.println(TEXT_EXIT);
	}
	
	@Test
	public void checkCommandAdd() throws Exception{
		TNotesParser tester = new TNotesParser(); 		
		assertEquals("i want to test", listAdd1, tester.checkCommand("add call mom at 1pm"));
		System.out.println("1. add call mom at 1pm (debug)");	
		
		assertEquals("i want to test", listAdd2, tester.checkCommand("add call mom due 2-3-2016 at 15:00 to 19:00"));
		System.out.println("2. add call mom due 2-3-2016 at 15:00 to 19:00(debug)");	
		
		
		assertEquals("i want to test", listAdd3, 
		tester.checkCommand("add call mom at 3:00pm details tell her buy apple"));
		System.out.println("3. add call mom at 3:00pm details tell her buy apple(debug)");
		
		assertEquals("i want to test", listAdd4, 
		tester.checkCommand("add call mom details tell her buy apple"));
		System.out.println("4. add call mom details tell her buy apple(debug)");
		
		assertEquals("i want to test", listAdd5, 
		tester.checkCommand("add call mom due 13:00"));
		System.out.println("5. add call mom due 13:00");
		
		assertEquals("i want to test", listAdd6, 
		tester.checkCommand("add call mom from 12:00 to 13:00"));
		System.out.println("6. add call mom from 12:00 to 13:00");
		
		assertEquals("i want to test", listAdd7, 
		tester.checkCommand("add call mom every tue"));
		System.out.println("7. add call mom every tue(small letter)");
		
		assertEquals("i want to test", listAdd8, 
				tester.checkCommand("add call mom due 2-3-2016 at 3:00pm"));
				System.out.println("8. add call mom due 2-3-2016 at 3:00pm");
				
		assertEquals("i want to test", listAdd9, 
				tester.checkCommand("add call mom due 2-3-2016 at 3:00 pm"));
				System.out.println("9. add call mom due 2-3-2016 at 3:00 pm");
				
		assertEquals("i want to test", listAdd10, 
				tester.checkCommand("add call important mom due 2-2-2016 at 12:00"));
				System.out.println("10. add call important mom due 2-2-2016  at 12:00");
		assertEquals("i want to test", listAdd11, 
				tester.checkCommand("add call mom due 2-2-2016 at 12:00 details say hello"));
				System.out.println("11. add call mom due 2-2-2016 at 12:00 details say hello");
		assertEquals("i want to test", listAdd12, 
				tester.checkCommand("add call mom details buy apple"));
				System.out.println("12. add call mom details buy apple");
		assertEquals("i want to test", listAdd13, 
				tester.checkCommand("add call mom due every Tue at 12:00 important"));
				System.out.println("13. add call mom due every Tue at 12:00 important");
		assertEquals("i want to test", listAdd14, 
				tester.checkCommand("add call mom due every Tuesday"));
				System.out.println("14. add call mom due every Tuesday (with due)");
		assertEquals("i want to test", listAdd15, 
				tester.checkCommand("add call mom"));
				System.out.println("15. add call mom(can add symbols)");
		assertEquals("i want to test", listAdd16, 
				tester.checkCommand("add call mom from 2-2-2016 to 3-3-2016"));
				System.out.println("16. add call mom from 2-2-2016 to 3-3-2016)");
		assertEquals("i want to test", listAdd17, 
				tester.checkCommand("add call mom from 2-2-2016 at 12:00 to 3-3-2016 at 13:00 details buy apple"));
				System.out.println("17. add call mom from 2-2-2016 at 12:00 to 3-3-2016 at 13:00 details buy apple");
		assertEquals("i want to test", listAdd18, 
				tester.checkCommand("add call mom due this week"));
				System.out.println("18. add call mom due this week");
		assertEquals("i want to test", listAdd19, 
				tester.checkCommand("add call mom at 12:00"));
				System.out.println("19. add call mom at 12:00");
		assertEquals("i want to test", listAdd20, 
				tester.checkCommand("add call mom due 2-2-2016"));
				System.out.println("20. add call mom due 2-2-2016");
		assertEquals("i want to test", listAdd21, 
				tester.checkCommand("add call mom on Tue"));
			    System.out.println("21. add call mom on Tue");
		assertEquals("i want to test", listAdd22, 
				tester.checkCommand("add call mom today"));
				System.out.println("22. add call mom today");
		assertEquals("i want to test", listAdd23, 
				tester.checkCommand("add call mom"));
				System.out.println("23. add call mom");
		assertEquals("i want to test", listAdd24, 
				tester.checkCommand("add call mom important"));
				System.out.println("24. add call mom important");
		assertEquals("i want to test", listAdd25, 
				tester.checkCommand("add call mom at jul"));
				System.out.println("25. add call mom at jul(small letter)");
		assertEquals("i want to test", listAdd26, 
				tester.checkCommand("add call mom from 2-2-2016 at 12:00 to 3-3-2016 at 13:00 details at to due from"));
				System.out.println("26. add call mom from 2-2-2016 at 12:00 to 3-3-2016 at 13:00 details at to due from");
		assertEquals("i want to test", listAdd27, 
				tester.checkCommand("add call mom 3pm 2-2-2016"));
				System.out.println("27. add call mom 3pm 2-2-2016(without key word)");
		assertEquals("i want to test", listAdd28, 
				tester.checkCommand("add call mom every jul"));
				System.out.println("28. add call mom every jul");
		assertEquals("i want to test", listAdd29, 
				tester.checkCommand("add call mom every jul for 2 week"));
				System.out.println("29. add call mom every jul for 2 week");
		assertEquals("i want to test", listAdd30, 
				tester.checkCommand("add call mom from 2-2-2016 at 13:00 to 3-3-2016 at 12:00 details at to due from"));
				System.out.println("30. add call mom from 2-2-2016 at 13:00 to 3-3-2016 at 12:00 details at to due from");
		assertEquals("i want to test", listAdd31, 
				tester.checkCommand("add due at from to due 12:00"));
				System.out.println("31. add due at from to due 12:00");	
		assertEquals("i want to test", listAdd32, 
				tester.checkCommand("add due at from to from 12:00 to 13:00"));
				System.out.println("32. add due at from to from 12:00 to 13:00");	
		assertEquals("i want to test", listAdd33, 
				tester.checkCommand("add due at from to week every tue"));
				System.out.println("33. add due at from to every tue");
		assertEquals("i want to test", listAdd34, 
				tester.checkCommand("add fetch kid from school at 1pm"));
				System.out.println("34. add fetch kid from school at 1pm");
		assertEquals("i want to test", listAdd35, 
				tester.checkCommand("add 2"));
				System.out.println("35. add 2");
		assertEquals("i want to test", listAdd36, 
				tester.checkCommand("add do EE2024"));
				System.out.println("36. add do EE2024");
				
	
				
	}
	@Test
	public void checkCommandEdit() throws Exception{
		
		TNotesParser tester = new TNotesParser(); 		
		assertEquals("i want to test", listEdit1, tester.checkCommand("edit call mom status done"));
		System.out.println("1. edit call mom status done (debug)");	
			
		assertEquals("i want to test", listEdit2, 
				tester.checkCommand("edit call mom endDate 2-3-2016"));
		System.out.println("2. edit call mom endDate 2-3-2016");
		assertEquals("i want to test", listEdit3, 
				tester.checkCommand("edit call mom details buy apple"));
		System.out.println("3. edit call mom details buy apple");
		assertEquals("i want to test", listEdit4, 
				tester.checkCommand("edit call mom importance yes"));
		System.out.println("4. edit call mom importance yes");
	}
	
	
	@Test
	public void checkCommandView() throws Exception{
		
		TNotesParser tester = new TNotesParser(); 		
		assertEquals("i want to test", listView1, tester.checkCommand("view 2-3-2016 to 4-3-2016"));
		System.out.println("1. view 2-3-2016 to 4-3-2016");	
		assertEquals("i want to test", listView2, tester.checkCommand("view i will do homework"));
		System.out.println("2. view i will do homework");	
		assertEquals("i want to test", listView3, tester.checkCommand("view i want to go to school"));
		System.out.println("3. view i want to go to school");	
		assertEquals("i want to test", listView4, tester.checkCommand("view today"));
		System.out.println("4. view today");
		assertEquals("i want to test", listView5, tester.checkCommand("view 4-3-2016"));
		System.out.println("5. view 4-3-2016");	
		assertEquals("i want to test", listView6, tester.checkCommand("view tomorrow"));
		System.out.println("6. view tomorrow");	
		assertEquals("i want to test", listView7, tester.checkCommand("view Jan to Feb"));
		System.out.println("7. view Jan to Feb");
		assertEquals("i want to test", listView8, tester.checkCommand("view next month"));
		System.out.println("8. view next month");	
		assertEquals("i want to test", listView9, tester.checkCommand("view next Feb"));
		System.out.println("9. view next Feb");
		assertEquals("i want to test", listView10, tester.checkCommand("view 2"));
		System.out.println("10. view 2");
		assertEquals("i want to test", listView11, tester.checkCommand("view notes"));
		System.out.println("11. view notes");
	}
	
	@Test
	public void checkCommandSet() throws Exception{
		
		TNotesParser tester = new TNotesParser(); 		
		assertEquals("i want to test", listSet1, tester.checkCommand("set call mom complete"));
		System.out.println("1. set call mom complete");	
	}
	
	@Test
	public void checkCommandDelete() throws Exception{
		
		TNotesParser tester = new TNotesParser(); 		
		assertEquals("i want to test", listDelete1, tester.checkCommand("delete directory c:/file"));
		System.out.println("1. delete directory c:/file");			
		assertEquals("i want to test", listDelete2, tester.checkCommand("delete buy red apple"));
		System.out.println("2. delete buy red apple");	
		assertEquals("i want to test", listDelete3, tester.checkCommand("delete all"));
		System.out.println("3. delete all");	
	}
	
	@Test
	public void checkCommandChange() throws Exception{
		
		TNotesParser tester = new TNotesParser(); 		
		assertEquals("i want to test", listChange1, tester.checkCommand("change directory location to c:/file"));
		System.out.println("1. change directory location to c:/file");	
	}
	@Test
	public void checkCommandSearch() throws Exception{
		
		TNotesParser tester = new TNotesParser(); 		
		assertEquals("i want to test", listSearch1, tester.checkCommand("search call mom"));
		System.out.println("1. search call mom");	
	}
	@Test
	public void checkCommandSort() throws Exception{
		
		TNotesParser tester = new TNotesParser(); 		
		assertEquals("i want to test", listSort1, tester.checkCommand("sort by importance"));
		System.out.println("1. sort by importance");
		assertEquals("i want to test", listSort2, tester.checkCommand("sort by name"));
		System.out.println("2. sort by name");
	}
	
	

}
```
###### \src\tnote\parser\TNotesParserTime.java
``` java
package tnote.parser;

import java.text.SimpleDateFormat;
import java.util.logging.Logger;
import java.time.DateTimeException;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import org.ocpsoft.prettytime.nlp.PrettyTimeParser;
import tnote.util.log.TNoteLogger;

/**
 * This class manages all the inputs related to time.
 * 
 * It format all the time inputs in to a fixed one, state the range and translate
 * the time date natural language into specific one. 
 * 
 * It retrieves the input time and pass it to the
 * rest of the Parser classes.class. 
 * 
 */

public class TNotesParserTime {
	
	private static final String MESSAGE_INVALID_TIME = "Invalid time!";
	private static final String MESSAGE_INVALID_TIME_PATTERN = "Invalid time pattern!";
	private static final String MESSAGE_NULL_TIME = "Null input time!";
	private static final String MESSAGE_NULL_TIME_LIST = "Null time input ArrayList";
	private static final String MESSAGE_EMPTY_INPUT = "Empty natural language input";
	private static final String MESSAGE_ISLETTER = "[a-zA-Z]+";
	private static final String MESSAGE_NULL_STRING = "";
	private static final String MESSAGE_INVALID_TIME_RANGE = "Invalid time range!";
	private static final String MESSAGE_STANDARD_DATE_FORMAT = "yyyy-MM-dd";
	private static final String MESSAGE_STANDARD_DATE_TIME_FORMAT = "E, y-M-d 'at' h:m:s a z";
	private static final String MESSAGE_LOG_ERROR = "Warning in check time";
	
	private static int NUM_GET_FIRST_DATE = 0;
	private static int NUM_INITIALISATION = 0;
	private static int NUM_TRUE = 1;
	private static int NUM_FALSE = 0;
	private static int NUM_FIRST_CHAR = 0;
	private static int NUM_LAST_CHAR = 1;
	private static int NUM_SECOND_LAST_CHAR = 2;
	private static int NUM_SUB_ZERO = 0;
	private static int NUM_SUB_ONE = 1;
	private static int NUM_SUB_TWO = 2;
	private static int NUM_SUB_THREE = 3;
	private static int NUM_SUB_FIVE = 5;
	
	
	private static final Logger logger = Logger.getGlobal();
	
	private static final List<String> TIME_POSSIBLE_FORMAT = Collections.unmodifiableList(Arrays.asList(
			"h:mm", "hh:m", "hh:mm","HH:mm",
			"H:MM", "HH:M", "HH:MM",
			"h:mma", "hh:ma", "hh:mma",
			"H:MMA", "HH:MA", "HH:MMA",
			"H:mma", "HH:ma", "HH:ma","ha","h a",
			"h:mm a", "hh:m a", "hh:mm a",
			"H:MM A", "HH:M A", "HH:MM A",
			"H:mm a", "HH:m a", "HH:m a",
			
			"hmm", "hhm", "hhmm","HHmm",
			"HMM", "HHM", "HHMM",
			"hmma", "hhma", "hhmma",
			"HMMA", "HHMA", "HHMMA",
			"Hmma", "HHma", "HHma",
			"hmm a", "hhm a", "hhmm a",
			"HMM A", "HHM A", "HHMM A",
			"Hmm a", "HHm a", "HHm a",
			
			 
			"h.mm", "hh.m", "hh.mm","HH.mm",
			"H.MM", "HH.M", "HH.MM",
			"h.mma", "hh.ma", "hh.mma",
			"H.MMA", "HH.MA", "HH.MMA",
			"H.mma", "HH.ma", "HH.ma",
			"h.mm a", "hh.m a", "hh.mm a",
			"H.MM A", "HH.M A", "HH.MM A",
			"H.mm a", "HH.m a", "HH.m a"
			));
	
	/**
	 * Return an String that has the correct format of time.
	 * If valid time is found, contents in the list are updated.
	 * 
	 * @param time	An time input from the user.
	 * @return	Time with the correct format
	 * @throws DateTimeException A null exception will be thrown 
	 */
	protected String formatTime(String time){
		ArrayList<String> timeList = new ArrayList<String>();
		
		assert time != null : MESSAGE_INVALID_TIME;
		time = time.toUpperCase();
		timeList.addAll(TIME_POSSIBLE_FORMAT);
		LocalTime parsedTime = null;
		
		for (String timeFormat : timeList) {		
			parsedTime = compareTimeFormat(time, timeFormat);
			
			if (parsedTime != null) {
				return parsedTime.toString();
			}
		}
		//if the input is not a time
		logger.warning(MESSAGE_LOG_ERROR);
		return MESSAGE_NULL_STRING;
	}
	
	private LocalTime compareTimeFormat(String timeString, String pattern) {
		assert pattern != null : MESSAGE_INVALID_TIME_PATTERN;
		LocalTime time = null;
		try {
			DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
			time = LocalTime.parse(timeString, formatter);
			return time;
		} catch (DateTimeException e) {
			logger.warning(MESSAGE_LOG_ERROR); 	
			return null;
		}
	
	}
	/**
	 * Return an integer that will indicate if the input String is a
	 * valid time.
	 * If valid time is found, contents in the list are updated.
	 * 
	 * The time formats that can be identify by this methods
	 * are those contains ":" or contains am pm
	 * 
	 * @param input	An time input from the user.
	 * @return	Integer that is either 1 or 0
	 */
	protected int checkTime(String input) {
		assert input != null : MESSAGE_NULL_TIME;
		int inputCharLength = input.trim().length();
		for(int i =NUM_INITIALISATION; i<inputCharLength; i++){
			if((input.charAt(i) == ':' || 
					(Character.toString(input.charAt(inputCharLength-NUM_LAST_CHAR)).equals("m")) &&
					(Character.toString(input.charAt(inputCharLength-NUM_SECOND_LAST_CHAR)).equals("p") ||
					 Character.toString(input.charAt(inputCharLength-2)).equals("a")))
					&& isLetters(Character.toString(input.charAt(NUM_FIRST_CHAR))) == NUM_FALSE){
				return NUM_TRUE;
			}
		}
		logger.warning(MESSAGE_LOG_ERROR); 	
		return NUM_FALSE ;
	}
	
	/**
	 * Return an ArrayList that either contains the correct time format or
	 * the error message.
	 * 
	 * @param list	An time input ArrayList from the user.
	 * @return	updated ArrayList
	 */
	protected ArrayList<String> compareTime(ArrayList<String> list){
		
		assert list != null : MESSAGE_NULL_TIME_LIST;
		
		int firstTime = Integer.parseInt(list.get(0).substring(NUM_SUB_ZERO,NUM_SUB_TWO));
		int secondTime = Integer.parseInt(list.get(NUM_SUB_ONE).substring(NUM_SUB_ZERO,NUM_SUB_TWO));
		
		if(firstTime == secondTime) {
			firstTime = Integer.parseInt(list.get(0).substring(NUM_SUB_THREE,NUM_SUB_FIVE));
			secondTime = Integer.parseInt(list.get(NUM_SUB_ONE).substring(NUM_SUB_THREE,NUM_SUB_FIVE));
			
			if(firstTime >= secondTime) {
				list.clear();
				list.add(MESSAGE_INVALID_TIME_RANGE);
				return list;
			} else {
				return list;
			}
		
		} else if(firstTime > secondTime){
			list.clear();
			list.add(MESSAGE_INVALID_TIME_RANGE);
			return list;
		}
		else{
		logger.warning(MESSAGE_LOG_ERROR); 	
		return list;
		}
		
	}
	private int isLetters(String nextString) {
		if (nextString.matches(MESSAGE_ISLETTER)) {
			return NUM_TRUE;
		} else {
			return NUM_FALSE;
		}
	}
	/**
	 * Return an String that contains the exact time and date
	 * This method will recognize the natural languages that entered by the user 
	 * which indicate the time and date 
	 * 
	 * @param input	The String entered by the user
	 * @return	the exact date after formating
	 * @throws Exception that returns null
	 */
	protected String isAMPM(String atDatePMAM){
		switch(atDatePMAM){
			case "am" :
				return "am";
			case "pm" :
				return "pm";
			case "AM" :
				return "AM";
			case "PM" :
				return "PM";
			default   :
				return "";
		}	
	}
	/**
	 * Return an String that contains the exact time and date
	 * This method will recognize the natural languages that entered by the user 
	 * which indicate the time and date 
	 * 
	 * @param input	The String entered by the user
	 * @return	the exact date after formating
	 * @throws Exception that returns null
	 */
	protected String prettyTime(String input){
		assert input != "" : MESSAGE_EMPTY_INPUT;
		try{
			List<Date> dates = new PrettyTimeParser().parse(input);
			Date date = new Date();
			date =dates.get(NUM_GET_FIRST_DATE);
			SimpleDateFormat dateFormatter = new SimpleDateFormat(MESSAGE_STANDARD_DATE_TIME_FORMAT);
			dateFormatter = new SimpleDateFormat(MESSAGE_STANDARD_DATE_FORMAT);
			return dateFormatter.format(date);
		}catch(Exception e){
			return null;
		}
	}
}
```
###### \src\tnote\parser\TNotesParserTimeTest.java
``` java
package tnote.parser;
import static org.junit.Assert.*;

import java.util.ArrayList;

import org.junit.Test;

public class TNotesParserTimeTest {
	TNotesParserTime time = new TNotesParserTime();
	
	@Test
	public void testParseNormalTimes() {
		String[] testInput = {"1pm", "5.00pm", "9:00pm", "10.00pm",
							   "1.00", "1.00pm", "1:00", "16.00",
							   "10:00am", "9am", "11:30am", "6.15am",
							   "1PM", "5.00PM", "9:00PM", "10.00PM",
							   "10:00AM", "9AM", "11:30AM", "6.15AM",
							   "", "abt", "83838"
				
							};
		String[] expectedOutput = {"13:00", "17:00", "21:00","22:00",
									"01:00", "13:00", "01:00", "16:00",
									"10:00", "09:00", "11:30", "06:15",
									"13:00", "17:00", "21:00","22:00",
									"10:00", "09:00", "11:30", "06:15",
									"", "", ""
				
							};
		String[] testOutput = new String[testInput.length];
		for (int i = 0; i < testInput.length; i++) {
			testOutput[i] = time.formatTime(testInput[i]);
			assertEquals(expectedOutput[i], testOutput[i]);
		}
		System.out.println("test parser time formatting");
	}
	
	@Test
	public void testCheckTime() {
		String[] testInput = {"1pm", "5:00pm", "9:00pm", "10:00am",
							   "", "abt", "83838", "900"
				
							};
		int[] expectedOutput = {1, 1, 1, 1,
								0, 0, 0, 0
				
							};
		int[] testOutput = new int[testInput.length];
		for (int i = 0; i < testInput.length; i++) {
			testOutput[i] = time.checkTime(testInput[i]);
			assertEquals(expectedOutput[i], testOutput[i]);
		}	
		System.out.println("test check time");
	}
	
	@Test
	public void testCompareTime() {
		TNotesParserTime tester = new TNotesParserTime();
		ArrayList<String> timeList = new ArrayList<String>();
		ArrayList<String> timeListOutput = new ArrayList<String>();
		timeList.add("03:00");
		timeList.add("10:00");
		timeListOutput.add("03:00");
		timeListOutput.add("10:00");
		assertEquals("i want to test", timeListOutput ,tester.compareTime(timeList));
		System.out.println("The time range is correct");
		timeList.clear();
		timeList.add("03:00");
		timeList.add("02:00");
		timeListOutput.clear();
		timeListOutput.add("Invalid time range!");
		assertEquals("i want to test", timeListOutput ,tester.compareTime(timeList));
		System.out.println("Invalid time range");
	}
	
	@Test
	public void testIsAMPM() {
		String[] testInput = {"am", "pm",
							  "AM", "PM",
							  ""
				
							};
		String[] expectedOutput = {"am", "pm",
								   "AM", "PM",
								   ""
				
							};
		String[] testOutput = new String[testInput.length];
		for (int i = 0; i < testInput.length; i++) {
			testOutput[i] = time.isAMPM(testInput[i]);
			assertEquals(expectedOutput[i], testOutput[i]);
		}
		System.out.println("test am pm");
	}

}
```
###### \src\tnote\parser\TNotesParserView.java
``` java
package tnote.parser;
import java.util.ArrayList;


/**
 * This class manages the input String after command view
 * 
 * It retrieves the contents after command word view and pass it to the
 * UI class. It manages the input into their individual types and put them into the correct positions.
 * 
 * Contents can be separated into time, date, month and weekDays. 
 * 
 *  The users are able to specify a period of time.
 */
public class TNotesParserView {

	private static final String MESSAGE_NULL_STRING = "";
	private static final String MESSAGE_NULL_ARRAY = "The input array for view is null";
	private static final String MESSAGE_NULL_INPUT_STRING = "Invald input String!";
	
	private static int NUM_PREVIOUS_STR = 1;
	private static int NUM_NEXT_STR = 1;
	private static int NUM_ARR_LENGTH = 1;
	private static int NUM_TRUE = 1;
	private static int NUM_FALSE = 0;
	private static int NUM_FORTH_WORD = 3;
	private static int NUM_THIRD_WORD = 2;
	private static int NUM_SECOND_WORD = 1;
	private static int NUM_START_FROM_SECOND_STR = 1;
	private static final int NUM_INTIALISATION = 0;

	private static final String keyWord [] = {
			"from", "to", "at", "by", "due"
			};
	private static final int NUM_INITIALISATION = 0;
	
	private TNotesParserTime time;
	private TNotesParserDate date;
	private TNotesParserQuery query;
	
	public TNotesParserView(){
		time = new TNotesParserTime();
		date = new TNotesParserDate();
		query = new TNotesParserQuery();
	}
	
	/**
	 * Return an ArrayList that contains all the contents after the command word view.
	 * If valid task names, time and date are found, contents in the list are updated.
	 * 
	 * @param viewArr	An Array input from the user.
	 * @return	The an ArrayList of split Strings.
	 */
	protected ArrayList <String> viewCommand(String[] viewArr) throws Exception{
		ArrayList<String> viewList = new ArrayList<String>();
		ArrayList<String> compareTimeList = new ArrayList<String>();
		ArrayList<String> compareDateList = new ArrayList<String>();
		
		assert viewArr != null : MESSAGE_NULL_ARRAY;	
		
		if(viewArr.length!=NUM_ARR_LENGTH){
			//view next year/week/month
			if (query.isLetters(viewArr[NUM_SECOND_WORD].trim()) == NUM_TRUE 
				&& query.checkViewTo(viewArr) == NUM_FALSE) {
				viewList.addAll(keyWordNext(viewArr));
				//view year/week/month to year/week/month
				//view Feb to Mar
			}else if(query.isLetters(viewArr[NUM_SECOND_WORD].trim()) == NUM_TRUE 
				&& query.checkViewTo(viewArr) == NUM_TRUE 
				&& checkKeyWordBefore(viewArr)==NUM_TRUE){
				viewList.add(date.compareWeekDayMonth(viewArr[NUM_SECOND_WORD]));
				viewList.add(date.compareWeekDayMonth(viewArr[NUM_FORTH_WORD]));
				//view date
			}else if (query.isLetters(viewArr[NUM_SECOND_WORD].trim()) == NUM_FALSE 
				&& query.checkViewTo(viewArr) == NUM_FALSE 
				&& time.checkTime(viewArr[NUM_SECOND_WORD].trim())==NUM_FALSE) {
				String formattedDate = date.formatDate(viewArr[1]);
				if(formattedDate.isEmpty()) {
					viewList.add(viewArr[NUM_SECOND_WORD]);
				} else {
					viewList.add(date.formatDate(viewArr[NUM_SECOND_WORD]));
				}
				//view date to date
			}else if(query.isLetters(viewArr[NUM_SECOND_WORD].trim()) == NUM_FALSE 
				&& query.checkViewTo(viewArr) == NUM_TRUE 
				&& time.checkTime(viewArr[NUM_SECOND_WORD].trim())==NUM_FALSE 
				&& checkKeyWordBefore(viewArr)==NUM_TRUE){
				compareDateList.add(date.formatDate(viewArr[NUM_SECOND_WORD]));
				compareDateList.add(date.formatDate(viewArr[NUM_FORTH_WORD]));
				viewList.addAll(date.compareDate(compareDateList));
				//view time
			}else if (query.isLetters(viewArr[NUM_SECOND_WORD].trim()) == NUM_FALSE 
				&& query.checkViewTo(viewArr) == NUM_FALSE 
				&& time.checkTime(viewArr[NUM_SECOND_WORD].trim())==NUM_TRUE) {
				viewList.add(time.formatTime(viewArr[NUM_SECOND_WORD] 
					+ time.isAMPM(viewArr[viewArr.length-NUM_PREVIOUS_STR])).toString());
				//view time to time
			}else if(query.isLetters(viewArr[NUM_SECOND_WORD].trim()) == NUM_FALSE 
				&& query.checkViewTo(viewArr) == NUM_TRUE 
				&& time.checkTime(viewArr[NUM_SECOND_WORD].trim())==NUM_TRUE 
				&& checkKeyWordBefore(viewArr)==NUM_TRUE){
				compareTimeList.add(time.formatTime(viewArr[NUM_SECOND_WORD] 
					+ time.isAMPM(viewArr[NUM_THIRD_WORD])).toString());
				for(int i=NUM_INITIALISATION;i<viewArr.length;i++){
					if(viewArr[i].equals("to")){
						compareTimeList.add(time.formatTime(viewArr[i+NUM_NEXT_STR] 
						+ time.isAMPM(viewArr[viewArr.length-NUM_PREVIOUS_STR])).toString());
					}
				}
				viewList.addAll(time.compareTime(compareTimeList));
			}
		}
		else{
			viewList.clear();
		}			
		if(viewList.isEmpty()){
			viewList.add(query.taskNameFloat(viewArr).trim());
		}
		return viewList;
	}
	private int isKeyWord(String word){
		assert word != null : MESSAGE_NULL_INPUT_STRING;
		
		if(date.formatWeekDay(word).equals(MESSAGE_NULL_STRING)
				&&date.formatMonth(word).equals(MESSAGE_NULL_STRING)
				&&date.formatSpecialDay(word).equals(MESSAGE_NULL_STRING)
				&&time.formatTime(word).equals(MESSAGE_NULL_STRING)
				&&date.formatDate(word).equals(MESSAGE_NULL_STRING)){
			return NUM_FALSE;
		}
		else{
			return NUM_TRUE;
		}
	}
	private int checkKeyWordBefore(String[] arr) {
		assert arr != null : MESSAGE_NULL_ARRAY;
		
		int index = NUM_INTIALISATION;
		for (int i=NUM_START_FROM_SECOND_STR;i<arr.length;i++){
			for(int j=NUM_INTIALISATION;j<keyWord.length;j++){
				if(arr[i].equals(keyWord[j])){
					index = isKeyWord(arr[i+NUM_NEXT_STR]);
				}
			}
		}	
		return index;
		
	}
	private ArrayList<String> keyWordNext(String arr[]) throws Exception{
		
		assert arr != null : MESSAGE_NULL_ARRAY;
		ArrayList <String> list = new ArrayList <String>();
		if(arr[NUM_SECOND_WORD].equals("next")){
			list.add(arr[NUM_SECOND_WORD]);	
			list.add(date.compareWeekDayMonth(arr[NUM_THIRD_WORD]));
			
		}
		else if(!arr[NUM_SECOND_WORD].equals("next") && (arr.length>=NUM_FORTH_WORD || 
				date.formatSpecialDay(arr[NUM_SECOND_WORD]).equals(MESSAGE_NULL_STRING))){
			list.add(query.taskNameFloat(arr).trim());
		}
		else{
			list.add(date.compareWeekDayMonth(arr[NUM_SECOND_WORD]));
			
		}
		return list;
	}
}
```
###### \src\tnote\parser\TNotesParserViewTest.java
``` java
package tnote.parser;

import static org.junit.Assert.assertEquals;
import java.util.Arrays;
import java.util.List;

import org.junit.Test;

public class TNotesParserViewTest {
	private static final String MESSAGE_VIEW_SUC = "view successfully";
	
	private static final List<String> listView1 = 
			Arrays.asList("2016-03-02", "2016-03-04");
	private static final List<String> listView2 = 
			Arrays.asList("i will do homework");
	private static final List<String> listView3 = 
			Arrays.asList("i want to go to school");
	private static final List<String> listView4 = 
			Arrays.asList("today");
	private static final List<String> listView5 = 
			Arrays.asList("2016-03-04");
	private static final List<String> listView6 = 
			Arrays.asList("tomorrow");
	private static final List<String> listView7 = 
			Arrays.asList("JANUARY", "FEBRUARY");
	private static final List<String> listView8 = 
			Arrays.asList("next", "month");
	private static final List<String> listView9 = 
			Arrays.asList("next" ,"FEBRUARY");
	private static final List<String> listView10 = 
			Arrays.asList("2");
	private static final List<String> listView11 = 
			Arrays.asList("notes");

	private static final String[] listViewArr1 = {"view", "2-3-2016", "to", "4-3-2016"};
	private static final String[] listViewArr2 = {"view", "i will do homework"};
	private static final String[] listViewArr3 = {"view", "i want to go to school"};
	private static final String[] listViewArr4 = {"view", "today"};
	private static final String[] listViewArr5 = {"view", "4-3-2016"};
	private static final String[] listViewArr6 = {"view", "tomorrow"};
	private static final String[] listViewArr7 = {"view", "Jan", "to", "Feb"};
	private static final String[] listViewArr8 = {"view", "next", "month"};
	private static final String[] listViewArr9 = {"view", "next", "Feb"};
	private static final String[] listViewArr10 = {"view", "2"};
	private static final String[] listViewArr11 = {"view", "notes"};


	@Test
	public void testView1() throws Exception{
		TNotesParserView tester = new TNotesParserView(); 		
		assertEquals("i want to test", listView1, tester.viewCommand(listViewArr1));
		System.out.println(MESSAGE_VIEW_SUC);

	}
	
	@Test
	public void testView2() throws Exception{
		TNotesParserView tester = new TNotesParserView(); 		
		assertEquals("i want to test", listView2, tester.viewCommand(listViewArr2));
		System.out.println(MESSAGE_VIEW_SUC);

	}
	@Test
	public void testView3() throws Exception{
		TNotesParserView tester = new TNotesParserView(); 		
		assertEquals("i want to test", listView3, tester.viewCommand(listViewArr3));
		System.out.println(MESSAGE_VIEW_SUC);

	}
	@Test
	public void testView4() throws Exception{
		TNotesParserView tester = new TNotesParserView(); 		
		assertEquals("i want to test", listView4, tester.viewCommand(listViewArr4));
		System.out.println(MESSAGE_VIEW_SUC);

	}
	@Test
	public void testView5() throws Exception{
		TNotesParserView tester = new TNotesParserView(); 		
		assertEquals("i want to test", listView5, tester.viewCommand(listViewArr5));
		System.out.println(MESSAGE_VIEW_SUC);

	}
	@Test
	public void testView6() throws Exception{
		TNotesParserView tester = new TNotesParserView(); 		
		assertEquals("i want to test", listView6, tester.viewCommand(listViewArr6));
		System.out.println(MESSAGE_VIEW_SUC);

	}
	@Test
	public void testView7() throws Exception{
		TNotesParserView tester = new TNotesParserView(); 		
		assertEquals("i want to test", listView7, tester.viewCommand(listViewArr7));
		System.out.println(MESSAGE_VIEW_SUC);

	}
	@Test
	public void testView8() throws Exception{
		TNotesParserView tester = new TNotesParserView(); 		
		assertEquals("i want to test", listView8, tester.viewCommand(listViewArr8));
		System.out.println(MESSAGE_VIEW_SUC);

	}
	@Test
	public void testView9() throws Exception{
		TNotesParserView tester = new TNotesParserView(); 		
		assertEquals("i want to test", listView9, tester.viewCommand(listViewArr9));
		System.out.println(MESSAGE_VIEW_SUC);

	}
	@Test
	public void testView10() throws Exception{
		TNotesParserView tester = new TNotesParserView(); 		
		assertEquals("i want to test", listView10, tester.viewCommand(listViewArr10));
		System.out.println(MESSAGE_VIEW_SUC);

	}
	@Test
	public void testView11() throws Exception{
		TNotesParserView tester = new TNotesParserView(); 		
		assertEquals("i want to test", listView11, tester.viewCommand(listViewArr11));
		System.out.println(MESSAGE_VIEW_SUC);

	}

}
```
