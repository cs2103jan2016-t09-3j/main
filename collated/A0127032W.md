# A0127032W
###### \bin\tnote\gui\view\colour.css
``` css
.TextArea {
	-fx-background-color: #003380;
}

.background {
    -fx-background-color: #ac7339;
}

.body{
  background-image: url(/resources/images/tile.jpg);
  background-repeat:repeat;
}
```
###### \bin\tnote\gui\view\RootLayout.fxml
``` fxml

<?import javafx.scene.layout.BorderPane?>


<BorderPane prefHeight="650.0" prefWidth="1100.0" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" />
```
###### \bin\tnote\gui\view\TNotesSplitView.fxml
``` fxml

<?import javafx.scene.control.SplitPane?>
<?import javafx.scene.control.TextArea?>
<?import javafx.scene.control.TextField?>
<?import javafx.scene.layout.AnchorPane?>

<AnchorPane maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="650.0" prefWidth="1100.0" styleClass="background" stylesheets="@colour.css" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="tnote.gui.view.TNotesOverviewController">
   <children>
      <SplitPane dividerPositions="0.6353383458646616" layoutX="174.0" layoutY="127.0" prefHeight="600.0" prefWidth="800.0" styleClass="background" stylesheets="@colour.css" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
        <items>
          <AnchorPane minHeight="0.0" minWidth="0.0" prefHeight="160.0" prefWidth="100.0">
               <children>
                  <TextArea fx:id="displayMainScreen" layoutX="12.0" layoutY="12.0" onKeyPressed="#handleScrollBar" prefHeight="336.0" prefWidth="388.0" AnchorPane.bottomAnchor="50.0" AnchorPane.leftAnchor="12.0" AnchorPane.rightAnchor="12.0" AnchorPane.topAnchor="12.0" />
                  <TextField fx:id="userInput" layoutX="11.0" layoutY="560.0" onAction="#handleUserInput" prefHeight="26.0" prefWidth="524.0" AnchorPane.bottomAnchor="12.0" AnchorPane.leftAnchor="12.0" AnchorPane.rightAnchor="12.0" />
               </children>
            </AnchorPane>
          <AnchorPane minHeight="0.0" minWidth="0.0" prefHeight="160.0" prefWidth="100.0">
               <children>
                  <TextArea fx:id="displaySideScreen" layoutX="10.0" layoutY="11.0" prefHeight="377.0" prefWidth="161.0" AnchorPane.bottomAnchor="12.0" AnchorPane.leftAnchor="12.0" AnchorPane.rightAnchor="12.0" AnchorPane.topAnchor="12.0" />
               </children>
            </AnchorPane>
        </items>
      </SplitPane>
   </children>
</AnchorPane>
```
###### \src\Main\TNotesMain.java
``` java
package Main;
import java.util.ArrayList;
import java.util.Scanner;

import tnote.ui.TNotesUI;

/**
 * Execute the application TNote from console
 * 
 * 
 * @author A0127032W
 *
 */

public class TNotesMain {
	
	
	//Define Display Messages 
	public static void main(String[] args) {
		String result="";
		String update="";
		
		Scanner sc = new Scanner(System.in);
		
		TNotesUI tNote = new TNotesUI();
		String welcomeMessage = tNote.getWelcomeMessage();
		showToUser(welcomeMessage);
		
		while(true){
		String userInput = sc.nextLine();
		
		try {
			update = tNote.executeCommand(userInput);
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		result += tNote.displayMain();
		result += update;
		
		showToUser(result);
		}		
	}
	
	
	protected static void showToUser (String textToBeShown){
		System.out.println(textToBeShown);
	}
	
	
}
```
###### \src\tnote\gui\MainApp.java
``` java
package tnote.gui;
import java.util.logging.Logger;
import tnote.util.log.TNoteLogger;

import  java.io.IOException;

import javafx.application.Application;
import javafx.fxml.*;
import javafx.scene.Scene;
import javafx.scene.image.Image;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.BorderPane;
import javafx.stage.Stage;
import tnote.gui.view.TNotesOverviewController;


/**
 * Execute the application TNote from this class
 * 
 * 
 * @author A0127032W
 *
 */

public class MainApp extends Application {
	
		private static final String MESSAGE_LOG_ERROR = "Warning";
		private static final Logger logger = Logger.getGlobal();
	 
		private Stage primaryStage;
	    private BorderPane rootLayout;
	    
	    @Override
	    public void start(Stage primaryStage) {
	        this.primaryStage = primaryStage;
	        this.primaryStage.setTitle("T-Note");
	        this.primaryStage.setResizable(false);
	    
	        this.primaryStage.getIcons().add(new Image("file:resources/images/turtleIcon.png"));
	        
	        initRootLayout();

	        showTNotesOverview();
	    }

	    /**
	     * Initializes the root layout.
	     */
	    public void initRootLayout() {
	        try {
	            // Load root layout from fxml file.
	            FXMLLoader loader = new FXMLLoader();
	            loader.setLocation(MainApp.class.getResource("/tnote/gui/view/RootLayout.fxml"));
	            rootLayout = (BorderPane) loader.load();

	            // Show the scene containing the root layout.
	            Scene scene = new Scene(rootLayout,1100,650);
	            primaryStage.setScene(scene);
	            primaryStage.show();
	        } catch (IOException e) {
	        	logger.warning(MESSAGE_LOG_ERROR);
	            e.printStackTrace();
	        }
	    }

	    /**
	     * Shows the TNotes overview inside the root layout.
	     */
	    public void showTNotesOverview() {
	        try {
	            // Load TNotesOverview overview.
	            FXMLLoader loader = new FXMLLoader();
	         
	            loader.setLocation(MainApp.class.getResource("/tnote/gui/view/TNotesSplitView.fxml"));
	            
	            AnchorPane TNotesOverview = (AnchorPane) loader.load();

	            // Set TNotes overview into the center of root layout.
	            rootLayout.setCenter(TNotesOverview);
    	       
	            // Give the controller access to the main app.
	           TNotesOverviewController controller = loader.getController();
    	        controller.setMainApp(this);
    	        
	        } catch (IOException e) {
	        	logger.warning(MESSAGE_LOG_ERROR);
	            e.printStackTrace();
	        }
	    }

	    /**
	     * Returns the main stage.
	     * @return
	     */
	    public Stage getPrimaryStage() {
	        return primaryStage;
	    }

	    public static void main(String[] args) {
	        launch(args);
	    }

}
```
###### \src\tnote\gui\view\colour.css
``` css
.TextArea {
	-fx-background-color: #003380;
}

.background {
    -fx-background-color: #ac7339;
}

.body{
  background-image: url(/resources/images/tile.jpg);
  background-repeat:repeat;
}
```
###### \src\tnote\gui\view\RootLayout.fxml
``` fxml

<?import javafx.scene.layout.BorderPane?>


<BorderPane prefHeight="650.0" prefWidth="1100.0" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" />
```
###### \src\tnote\gui\view\TNotesOverviewController.java
``` java
package tnote.gui.view;

import javafx.fxml.FXML;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import tnote.gui.MainApp;
import tnote.ui.TNotesUI;
import javafx.scene.control.ScrollBar;
import javafx.scene.control.TextArea;

/**
 *	This class handles the logic in TNotesSplitView.fxml
 *		
 * 	@author A0127032W
 */

public class TNotesOverviewController {

	@FXML
	private TextField userInput;

	@FXML
	public TextArea displayMainScreen;

	@FXML
	protected TextArea displaySideScreen;

	private ScrollBar scrollBar;

	public TNotesUI tNote = new TNotesUI();

	private MainApp mainApp;
	
	
	
	/**
	 * The constructor for TNotesOverviewController. Initializes necessary variables.
	 * 
	 */
	public TNotesOverviewController() {
		scrollBar = new ScrollBar();
	}

	/**
	 * Initializes the controller class
	 * 
	 */
	@FXML
	private void initialize() {
		String welcomeMsg = tNote.getWelcomeMessage();

		displaySideScreen.setWrapText(true);
		displaySideScreen.setEditable(false);

		displayMainScreen.setWrapText(true);
		displayMainScreen.setEditable(false);
		displayMainScreen.setScrollTop(Double.MAX_VALUE);

		String mainScreenPrint = tNote.displayMain();
		mainScreenPrint += welcomeMsg;
		displayMainScreen.setText(mainScreenPrint);

		String showOverDue = tNote.displayOverdueTasks();
		String showFloats = tNote.displayFloats();
		showFloats += showOverDue;
		displaySideScreen.setText(showFloats);
		userInput.setPromptText("Enter command here");
		userInput.setStyle("-fx-text-inner-color: brown;");
	
	}	
	
	/**
	 * Updates TextArea whenever the user types in input in TextField
	 */
	@FXML
	private void handleUserInput() {
		String result = "";
		String update = "";
		String floatList = "";
		String overDueList = "";

		try {
			String userCommand = userInput.getText();
			update = tNote.executeCommand(userCommand);
		} catch (Exception e) {
			e.printStackTrace();
		}

		overDueList = tNote.displayOverdueTasks();
		floatList = tNote.displayFloats();
		result = tNote.displayMain();

		if (update.equals("exit")) {
			System.exit(0);
		}

		else {
			floatList += overDueList;
			displaySideScreen.setText(floatList);
			result += update;
			displayMainScreen.setText(result);		
			userInput.clear();
		}

	}

	/**
	 * Scrolls the page with keyboard buttons: Up, Down.
	 * 
	 * @param event
	 */
	@FXML
	private void handleScrollBar(KeyEvent event) {
		if (event.getCode() == KeyCode.UP) {
			// scroll up
			scrollBar.increment();
		}
		if (event.getCode() == KeyCode.DOWN) {
			// scroll down
			scrollBar.decrement();
		}

	}
	
	/**
	 * Is called by the main application to give a reference back to itself.
	 * 
	 * @param mainApp
	 */
	public void setMainApp(MainApp mainApp) {
		this.mainApp = mainApp;

	}

}
```
###### \src\tnote\gui\view\TNotesSplitView.fxml
``` fxml

<?import javafx.scene.control.SplitPane?>
<?import javafx.scene.control.TextArea?>
<?import javafx.scene.control.TextField?>
<?import javafx.scene.layout.AnchorPane?>

<AnchorPane maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="650.0" prefWidth="1100.0" styleClass="background" stylesheets="@colour.css" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="tnote.gui.view.TNotesOverviewController">
   <children>
      <SplitPane dividerPositions="0.6353383458646616" layoutX="174.0" layoutY="127.0" prefHeight="600.0" prefWidth="800.0" styleClass="background" stylesheets="@colour.css" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
        <items>
          <AnchorPane minHeight="0.0" minWidth="0.0" prefHeight="160.0" prefWidth="100.0">
               <children>
                  <TextArea fx:id="displayMainScreen" layoutX="12.0" layoutY="12.0" onKeyPressed="#handleScrollBar" prefHeight="336.0" prefWidth="388.0" AnchorPane.bottomAnchor="50.0" AnchorPane.leftAnchor="12.0" AnchorPane.rightAnchor="12.0" AnchorPane.topAnchor="12.0" />
                  <TextField fx:id="userInput" layoutX="11.0" layoutY="560.0" onAction="#handleUserInput" prefHeight="26.0" prefWidth="524.0" AnchorPane.bottomAnchor="12.0" AnchorPane.leftAnchor="12.0" AnchorPane.rightAnchor="12.0" />
               </children>
            </AnchorPane>
          <AnchorPane minHeight="0.0" minWidth="0.0" prefHeight="160.0" prefWidth="100.0">
               <children>
                  <TextArea fx:id="displaySideScreen" layoutX="10.0" layoutY="11.0" prefHeight="377.0" prefWidth="161.0" AnchorPane.bottomAnchor="12.0" AnchorPane.leftAnchor="12.0" AnchorPane.rightAnchor="12.0" AnchorPane.topAnchor="12.0" />
               </children>
            </AnchorPane>
        </items>
      </SplitPane>
   </children>
</AnchorPane>
```
###### \src\tnote\ui\TNotesMessages.java
``` java
package tnote.ui;

import java.util.ArrayList;;

public class TNotesMessages {

	private ArrayList<String> addHelpArray;
	private ArrayList<String> viewHelpArray;
	private ArrayList<String> deleteHelpArray;
	private ArrayList<String> editHelpArray;
	private ArrayList<String> searchHelpArray;
	private ArrayList<String> sortHelpArray;
	private ArrayList<String> miscHelpArray;

	public ArrayList<String> allHelpArray;

	// Constructor
	public TNotesMessages() {
		setAddHelpMessages();
		setViewHelpMessages();
		setDeleteHelpMessages();
		setEditHelpMessages();
		setSortHelpMessages();
		setSearchHelpMessages();
		setMiscHelpMessages();
		setAllHelpMessages();
	}

	// Getters
	public ArrayList<String> getAddHelpMessages() {
		return addHelpArray;
	}

	public ArrayList<String> getviewHelpMessages() {
		return viewHelpArray;
	}

	public ArrayList<String> getDeleteHelpMessages() {
		return deleteHelpArray;
	}

	public ArrayList<String> getEditHelpMessages() {
		return editHelpArray;
	}

	public ArrayList<String> getSearchHelpMessages() {
		return searchHelpArray;
	}

	public ArrayList<String> getSortHelpMessages() {
		return sortHelpArray;
	}

	public ArrayList<String> getMiscHelpMessages() {
		return miscHelpArray;
	}

	public ArrayList<String> getAllHelpMessages() {
		return allHelpArray;
	}

	// Modifiers

	public void setAllHelpMessages() {
		allHelpArray = new ArrayList<String>();
		mergeArrays(addHelpArray);
		mergeArrays(viewHelpArray);
		mergeArrays(deleteHelpArray);
		mergeArrays(editHelpArray);
		mergeArrays(sortHelpArray);
		mergeArrays(miscHelpArray);
		mergeArrays(searchHelpArray);
	}

	public void mergeArrays(ArrayList<String> tempArray) {
		for (int i = 0; i < tempArray.size(); i++) {
			allHelpArray.add(tempArray.get(i).toString());
		}
	}

	public void setAddHelpMessages() {
		addHelpArray = new ArrayList<String>();
		addHelpArray.add("====Add====");
		addHelpArray.add("add [task]");
		addHelpArray.add("add [task] on [day]");
		addHelpArray.add("add [task] every day for [num] days");
		addHelpArray.add("add [task] every week for [num] weeks");
		addHelpArray.add("add [task] every month for [num] months");
		addHelpArray.add("add [task] due every [day]");
		addHelpArray.add("add [task] at [time]");
		addHelpArray.add("add [task] due [date]");
		addHelpArray.add("add [task] from [date] to [date]");
		addHelpArray.add("add [task] from [time] to [time]");
		addHelpArray.add("add [task] due [date] at [time] to [date] at [time]");
		addHelpArray.add("add [task] important");
		addHelpArray.add("add [task] details [task details]");
		addHelpArray.add("\n");
	}

	public void setViewHelpMessages() {
		viewHelpArray = new ArrayList<String>();
		viewHelpArray.add("====View====");
		viewHelpArray.add("view [date]");
		viewHelpArray.add("view [day]");
		viewHelpArray.add("view today");
		viewHelpArray.add("view tomorrow");
		viewHelpArray.add("view [task]");
		viewHelpArray.add("view [index]");
		viewHelpArray.add("view history");
		viewHelpArray.add("view notes");
		viewHelpArray.add("view [date] to [date]");
		viewHelpArray.add("\n");
	}

	public void setDeleteHelpMessages() {
		deleteHelpArray = new ArrayList<String>();
		deleteHelpArray.add("====Delete====");
		deleteHelpArray.add("delete [task]");
		deleteHelpArray.add("delete [index]");
		deleteHelpArray.add("delete all");
		deleteHelpArray.add("\n");
	}

	public void setEditHelpMessages() {
		editHelpArray = new ArrayList<String>();
		editHelpArray.add("====Edit====");
		editHelpArray.add("edit [task] name [new value]");
		editHelpArray.add("edit [task] time [new value]");
		editHelpArray.add("edit [task] startTime [new value]");
		editHelpArray.add("edit [task] endTime [new value]");
		editHelpArray.add("edit [task] date [new value]");
		editHelpArray.add("edit [task] startDate [new value]");
		editHelpArray.add("edit [task] endDate [new value]");
		editHelpArray.add("edit [task] details [new value]");
		editHelpArray.add("edit [task] importance [yes/no]");
		editHelpArray.add("\n");
	}

	public void setSearchHelpMessages() {
		searchHelpArray = new ArrayList<String>();
		searchHelpArray.add("====Search====");
		searchHelpArray.add("search [keyword/task]");
		searchHelpArray.add("\n");
	}

	public void setSortHelpMessages() {
		sortHelpArray = new ArrayList<String>();
		sortHelpArray.add("====Sort====");
		sortHelpArray.add("sort by name");
		sortHelpArray.add("\n");

	}

	public void setMiscHelpMessages() {
		miscHelpArray = new ArrayList<String>();
		miscHelpArray.add("====Misc====");
		miscHelpArray.add("set [task] done/undone");
		miscHelpArray.add("change directory location to [new directory path]");
		miscHelpArray.add("delete directory [Month folder]");
		miscHelpArray.add("\n");
	}

	// Misc
	public String printHelpArray() {
		String printArray;

		printArray = "====Start of List====\n";
		for (int i = 0; i < allHelpArray.size(); i++) {
			printArray += allHelpArray.get(i).toString();
			printArray += "\n";
		}

		printArray += "====End of List====\n";
		return printArray;
	}

}
```
###### \src\tnote\ui\TNotesUI.java
``` java
package tnote.ui;

import static org.junit.Assert.assertTrue;
import java.io.IOException;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.logging.Logger;
import tnote.logic.LogicCommand;
import tnote.logic.TNotesLogic;
import tnote.object.TaskFile;
import tnote.parser.TNotesParser;

/**
 * This class acts as a controller, it determines how the input is from the user
 * is processed. It handles how the resulting message should be displayed for
 * the user to see.
 * 
 * This class interacts with tnote.parser.TNotesParser, tnote.logic.TNotesLogic,
 * and tnote.object.TaskFile frequently. Occasionally it interacts with
 * tnote.logic.LogicCommand.
 * 
 * First, it calls tnote.parser.TnotesParser to split the String obtained from
 * the input that the user typed and it is return back to this class.
 * 
 * Next, it decides which command that the user wishes to do, and the it then
 * calls the appropriate method from tnote.logic.TNotesLogic and it is returned
 * an Object or an ArrayList of Objects from tnote.Object.TaskFile or
 * tnote.logic.LogicCommand.
 * 
 * After which, it format the message that would be passed to
 * tnote.gui.view.TNotesOverviewController to be displayed to the user.
 * 
 * @author A0127032W
 * 
 */

public class TNotesUI {

	// Command_type
	enum COMMAND_TYPE {
		ADD_COMMAND, CHANGE_DIRECTORY, DELETE_COMMAND, DELETE_DIRECTORY, EDIT_COMMAND, EXIT, HELP_COMMAND, INVALID, REDO_COMMAND, SEARCH_COMMAND, SET_COMMAND, SORT_COMMAND, UNDO_COMMAND, VIEW_COMMAND
	}

	// Attributes
	private TNotesParser parser;
	private TNotesLogic logic;
	private TNotesMessages message;

	private ArrayList<String> commandArguments;
	private ArrayList<TaskFile> viewList;
	private ArrayList<TaskFile> mainScreenArray;

	private int userIndex;

	// Messages
	private static final String MESSAGE_OVERDUE_TITLE = "====OVERDUE TASKS====\n";
	private static final String MESSAGE_NOTES_TITLE = "====NOTES====\n";
	private static final String MESSAGE_DATE_TITLE = "=======%s=======\n";
	private static final String MESSAGE_HISTORY_TITLE = "====HISTORY====\n";

	private static final String MESSAGE_UPDATE_SCHEDULE = "Schedule has been updated.\n";
	private static final String MESSAGE_SCHEDULE_ONE_DATE = "You have changed to view schedule for %s.\n";
	private static final String MESSAGE_SCHEDULE_DATE_TO_DATE = "You have changed to view schedule from %s to %s.\n";

	private static final String MESSAGE_WELCOME = "Hello, welcome to T-Note. How may I help you?\n";
	private static final String MESSAGE_IMPORTANT = "Note: Task was noted as important\n";
	private static final String MESSAGE_DETAILS = "Things to note: \"%s\"\n";
	private static final String MESSAGE_INVALID = "Invalid command entered.\nPlease enter \"Help\" to show a list of available commands.\n";
	private static final String MESSAGE_HELP = "List of available commands:\n\nNote: words in [] should be modified to your needs.\n\n";
	private static final String MESSAGE_EXIT = "exit";

	private static final String MESSAGE_PRINT_OVERDUE_LIST = "%s. [%s][%s] %s\n";
	private static final String MESSAGE_PRINT_FLOAT_LIST = "%s. %s%s\n";
	private static final String MESSAGE_PRINT_DEADLINE = "%s. [%s] %s%s\n";
	private static final String MESSAGE_PRINT_MEETING_ONE_DATE = "%s. [%s]-[%s] %s%s\n";
	private static final String MESSAGE_PRINT_MEETING_TWO_DATES = "%s. [%s][%s]-[%s][%s] %s%s\n";

	private static final String MESSAGE_ADD_CONFIRMATION_TASK = "I have added \"%s\" to your notes!\n";
	private static final String MESSAGE_ADD_CONFIRMATION_DEADLINE = "I have added \"%s\" at [%s] on [%s] to your schedule!\n";
	private static final String MESSAGE_ADD_CONFIRMATION_MEETING = "I have added \"%s\" from [%s] at [%s] to [%s] at [%s] to your schedule!\n";

	private static final String MESSAGE_CHANGE_DIRECTORY_SUCESS = "You have succesfully changed directory to %s.\n";
	private static final String MESSAGE_CHANGE_DIRECTORY_FAILURE = "Unable to change directory.\n";

	private static final String MESSAGE_DELETE_DIRECTORY_SUCESS = "You have succesfully deleted the directory: %s\n";
	private static final String MESSAGE_DELETE_DIRECTORY_FAILURE = "Unable to delete directory.\n";

	private static final String MESSAGE_DELETE_TASK = "I have deleted \"%s\" from your schedule for you!\n\n";
	private static final String MESSAGE_DELETE_ALL = "I have deleted EVERYTHING.\n";

	private static final String MESSAGE_EDIT_NAME = "You have changed the task name from \"%s\" to \"%s\"!\n";
	private static final String MESSAGE_EDIT_TIME = "You have changed the start time in \"%s\" from [%s] to [%s]!\n";
	private static final String MESSAGE_EDIT_END_TIME = "You have changed the end time in \"%s\" from [%s] to [%s]!\n";
	private static final String MESSAGE_EDIT_DATE = "You have changed the start date in \"%s\" from [%s] to [%s]!\n";
	private static final String MESSAGE_EDIT_END_DATE = "You have changed the end date in \"%s\" from [%s] to [%s]!\n";
	private static final String MESSAGE_EDIT_DETAILS = "You have changed the details in \"%s\" from [%s] to [%s]!\n";
	private static final String MESSAGE_EDIT_IMPORTANCE = "You have changed the importance of \"%s\" to ";

	private static final String MESSAGE_VIEW_TASK = "Displaying the task \"%s\":\n\n";
	private static final String MESSAGE_VIEW_ONE_DATE = "Date: %s\n";
	private static final String MESSAGE_VIEW_TWO_DATES = "Date: %s - %s\n";
	private static final String MESSAGE_VIEW_ONE_TIME = "Time: %s\n";
	private static final String MESSAGE_VIEW_TWO_TIMES = "Time: %s - %s\n";
	private static final String MESSAGE_VIEW_IMPORTANCE = "Importance: %s\n";
	private static final String MESSAGE_VIEW_STATUS = "Status: %s\n";
	private static final String MESSAGE_VIEW_DETAILS = "Details: %s\n";

	private static final String MESSAGE_SET_CONFIRMATION = "You have changed the status in \"%s\" from %s to %s\n\n";
	private static final String MESSAGE_SET_ERROR = "Error. The task is already %s!\n";

	private static final String MESSAGE_SEARCH_CONFIRMATION = "Searching for \"%s\" .......This is what I've found:\n";
	private static final String MESSAGE_SEARCH_FAILURE = "Nothing was found......\n";

	private static final String MESSAGE_SORT_CONFIRMATION = "I have sorted everything by name for you! I'm so amazing, what would you do without me!\n";

	private static final String MESSAGE_UNDO_CONFIRMATION = "You have undone %s %s!\n";

	private static final String MESSAGE_REDO_CONFIRMATION = "You have redone %s %s!\n";

	private static final String MESSAGE_PRINT_DEADLINE_W_DATE = "%s. [%s][%s] %s%s\n";
	private static final String MESSAGE_PRINT_MEETING_ONE_DATE_W_DATE = "%s. [%s][%s]-[%s] %s%s\n";

	private static final String MESSAGE_LOG_ERROR = "Caught exception error";
	private static final String MESSAGE_LOG_CONSTRUCTOR = "Entered TNotesUI constructor";
	private static final String MESSAGE_LOG_PARSER_SUCESS = "Parsed sucessfully";
	private static final String MESSAGE_LOG_COMMAND_WORD = "Check command: %s";
	private static final String MESSAGE_LOG_DISPLAY_MAIN_UPDATED = "Display main screen is called";
	private static final String MESSAGE_LOG_OVERDUE_TASK_UPDATED = "Display overdue tasks is called";
	private static final String MESSAGE_LOG_DISPLAY_NOTES_UPDATED = "Display notes is called";
	
	private static final Logger logger = Logger.getGlobal();

	/**
	 * The constructor for TNotesUI. Initializes necessary variables.
	 * 
	 * @param Nothing
	 * @return Nothing
	 * 
	 */
	// Constructor
	public TNotesUI() {
		try {
			parser = new TNotesParser();
			logic = new TNotesLogic();
			message = new TNotesMessages();
			mainScreenArray = new ArrayList<TaskFile>();
			mainScreenArray = logic.viewDateList("today");
			logger.info(MESSAGE_LOG_CONSTRUCTOR);
		} catch (Exception e) {
			logger.warning(MESSAGE_LOG_ERROR);
			e.getMessage();
		}
	}

	/**
	 * This method gets the welcome string
	 * 
	 * @return TNote's welcome String
	 */

	// Getters
	public String getWelcomeMessage() {
		String welcomeMsg = String.format(MESSAGE_WELCOME);
		return welcomeMsg;
	}

	/**
	 * This method is main method called
	 * 
	 * @param userInput
	 *            - the input String that the user typed
	 * @return formatted string that is displayed for the user to see in a
	 *         organized and informative manner
	 * @throws Exception
	 */

	// Main Method
	public String executeCommand(String userInput) throws Exception {
		
		String resultString = "";
		String commandString;
		ArrayList<String> userCommandSplit = new ArrayList<String>();

		try {
			userCommandSplit = parser.checkCommand(userInput);
			assertTrue(userCommandSplit.size()!=0);
		} catch (ParseException e) {
			logger.warning(MESSAGE_LOG_ERROR);
			e.printStackTrace();
		}
		
		logger.info(MESSAGE_LOG_PARSER_SUCESS);
		commandString = getFirstWord(userCommandSplit);
		COMMAND_TYPE command = determineCommandType(commandString);

		logger.info(String.format(MESSAGE_LOG_COMMAND_WORD, commandString));
		switch (command) {
		case ADD_COMMAND:
			resultString = formatAddCommand(userCommandSplit);

			break;
		case CHANGE_DIRECTORY:
			String changeDirectoryPath = userCommandSplit.get(1);

			resultString = formatChangeDirectoryCommand(changeDirectoryPath);
			break;
		case DELETE_DIRECTORY:
			String deleteDirectoryPath = userCommandSplit.get(1);

			resultString = formatDeleteDirectoryCommand(deleteDirectoryPath);
			break;
		case EDIT_COMMAND:
			String editTaskName = userCommandSplit.get(1).trim();
			String editType = userCommandSplit.get(2).trim();

			resultString = formatEditCommand(userCommandSplit, editTaskName, editType);
			break;
		case DELETE_COMMAND:
			String deleteType = userCommandSplit.get(1);

			resultString = formatDeleteCommand(userCommandSplit, deleteType);
			break;
		case VIEW_COMMAND:
			ArrayList<String> viewType = logic.sortViewTypes(userCommandSplit);
			String viewTypeString = viewType.get(0);

			resultString = formatViewCommand(userCommandSplit, viewTypeString);
			break;
		case SET_COMMAND:
			String taskName = userCommandSplit.get(1);

			resultString = formatSetCommand(userCommandSplit, taskName);
			break;
		case SEARCH_COMMAND:

			resultString = formatSearchCommand(userCommandSplit);
			break;
		case SORT_COMMAND:
			String sortType = userCommandSplit.get(1).trim();

			resultString = formatSortCommand(userCommandSplit, sortType);
			break;
		case UNDO_COMMAND:

			resultString = formatUndoCommand();
			break;
		case REDO_COMMAND:

			resultString = formatRedoCommand();
			break;
		case INVALID:

			resultString = String.format(MESSAGE_INVALID);
			break;
		case HELP_COMMAND:

			resultString = String.format(MESSAGE_HELP);
			resultString += message.printHelpArray();
			break;
		case EXIT:

			resultString = String.format(MESSAGE_EXIT);
			break;
		default:
			resultString = "Error!";
		}
		return resultString;
	}

	// ==== SubCommands ====

	/**
	 * This method formats the String for the add command
	 * 
	 * @param userCommandSplit
	 *            - ArrayList<String> returned from tnote.parser.TNotesParser
	 * @return formated String to be displayed to the user
	 */
	// ==== ADD ====
	private String formatAddCommand(ArrayList<String> userCommandSplit) {
		String formatAddString = "";
		TaskFile addTask;

		try {
			addTask = logic.addTask(userCommandSplit);
			formatAddString = checkAddTypes(addTask);
		} catch (Exception e) {
			logger.warning(MESSAGE_LOG_ERROR);
			formatAddString = e.getMessage();
		}
		return formatAddString;
	}

	/**
	 * This method checks if the task is a floating task, deadline task or
	 * meeting task and updates the main screen display
	 * 
	 * @param taskFile
	 *            - this is a TaskFile object of the added task returned from
	 *            tnote.logic.TNotesLogic
	 * @return formated string to be returned displaying the dates and timings
	 *         in accordance to their various types
	 */

	private String checkAddTypes(TaskFile taskFile) {
		String addString = "";

		// Floating task case
		if (taskFile.getIsTask()) {
			addString = String.format(MESSAGE_ADD_CONFIRMATION_TASK, taskFile.getName());
		}

		// Tasks with only 1 date
		if (taskFile.getIsDeadline()) {
			addString = String.format(MESSAGE_ADD_CONFIRMATION_DEADLINE, taskFile.getName(), taskFile.getStartTime(),
					taskFile.getStartDate());
			updateMainScreen(taskFile.getStartDate());
		}

		// Tasks with 2 dates
		if (taskFile.getIsMeeting()) {
			addString += String.format(MESSAGE_ADD_CONFIRMATION_MEETING, taskFile.getName(), taskFile.getStartDate(),
					taskFile.getStartTime(), taskFile.getEndDate(), taskFile.getEndTime());
			updateMainScreen(taskFile.getStartDate());
		}

		if (taskFile.getImportance()) {
			addString += String.format(MESSAGE_IMPORTANT);
		}

		if (taskFile.hasDetails()) {
			addString += String.format(MESSAGE_DETAILS, taskFile.getDetails().trim());
		}

		return addString;
	}

	/**
	 * This method formats the String for the change directory command
	 * 
	 * @param changeDirectoryPath
	 *            - takes in a new directory path
	 * @return formatted String to be displayed to the user
	 */

	// ==== CHANGE DIRECTORY ====

	private String formatChangeDirectoryCommand(String changeDirectoryPath) {
		String formatChangeDirString;
		try {
			if (logic.changeDirectory(changeDirectoryPath)) {
				formatChangeDirString = String.format(MESSAGE_CHANGE_DIRECTORY_SUCESS, changeDirectoryPath);
			} else {
				formatChangeDirString = String.format(MESSAGE_CHANGE_DIRECTORY_FAILURE);
			}
		} catch (Exception e) {
			logger.warning(MESSAGE_LOG_ERROR);
			formatChangeDirString = e.getMessage();
		}
		return formatChangeDirString;
	}

	/**
	 * This method formats the String for the delete directory command
	 * 
	 * @param deleteDirectoryPath
	 *            - takes in existing directory path to delete
	 * @return formatted String to be displayed to the user
	 */

	// ==== DELETE DIRECTORY ====

	private String formatDeleteDirectoryCommand(String deleteDirectoryPath) {
		String formatDeletDirString;

		try {
			if (logic.deleteDirectory(deleteDirectoryPath)) {
				formatDeletDirString = String.format(MESSAGE_DELETE_DIRECTORY_SUCESS, deleteDirectoryPath);
			} else {
				formatDeletDirString = String.format(MESSAGE_DELETE_DIRECTORY_FAILURE);
			}

		} catch (Exception e) {
			logger.warning(MESSAGE_LOG_ERROR);
			formatDeletDirString = e.getMessage();
		}
		return formatDeletDirString;
	}

	/**
	 * This method formats the String for the edit command and updates the main
	 * screen display
	 * 
	 * @param userCommandSplit
	 *            - an ArrayList<String> returned from tnote.parser.TNotesParser
	 * @param editTaskName
	 *            - the name of the task that will be edited
	 * @param editType
	 *            - the type of edit that the user wants to do
	 * @return formatted String to be displayed to the user
	 */

	// ==== EDIT ====

	private String formatEditCommand(ArrayList<String> userCommandSplit, String editTaskName, String editType) {
		TaskFile oldTaskFile;
		TaskFile newTaskFile;
		String formatEditString = "";

		try {
			oldTaskFile = logic.searchSingleTask(editTaskName);
			newTaskFile = logic.editTask(userCommandSplit);

			formatEditString = checkEditType(editTaskName, editType, oldTaskFile, newTaskFile);

			updateMainScreen(newTaskFile.getStartDate());

		} catch (Exception e) {
			logger.warning(MESSAGE_LOG_ERROR);
			formatEditString = e.getMessage();
		}
		return formatEditString;
	}

	/**
	 * This method checks for the type of edit that the user wishes to do and
	 * formats the String accordingly
	 * 
	 * @param editTaskName
	 *            - name of the task that will be edited
	 * @param editType
	 *            - the type of edit
	 * @param oldTaskFile
	 *            - the TaskFile Object before it is edited
	 * @param newTaskFile
	 *            - the TaskFile Object after it is edited
	 * @return formated String to be displayed to the user such with timing and
	 *         dates
	 */

	private String checkEditType(String editTaskName, String editType, TaskFile oldTaskFile, TaskFile newTaskFile) {
		String displayEditString = "";

		if (editType.equals("name")) {
			displayEditString = String.format(MESSAGE_EDIT_NAME, oldTaskFile.getName(), newTaskFile.getName());
		}
		if (editType.equals("time") || editType.equals("startTime")) {
			displayEditString = String.format(MESSAGE_EDIT_TIME, editTaskName, oldTaskFile.getStartTime(),
					newTaskFile.getStartTime());
		}
		if (editType.equals("endTime")) {
			displayEditString = String.format(MESSAGE_EDIT_END_TIME, editTaskName, oldTaskFile.getEndTime(),
					newTaskFile.getEndTime());
		}
		if (editType.equals("date") || editType.equals("startDate")) {
			displayEditString = String.format(MESSAGE_EDIT_DATE, editTaskName, oldTaskFile.getStartDate(),
					newTaskFile.getStartDate());
		}
		if (editType.equals("endDate")) {
			displayEditString = String.format(MESSAGE_EDIT_END_DATE, editTaskName, oldTaskFile.getEndDate(),
					newTaskFile.getEndDate());
		}
		if (editType.equals("details")) {
			displayEditString = String.format(MESSAGE_EDIT_DETAILS, editTaskName, oldTaskFile.getDetails(),
					newTaskFile.getDetails());
		}
		if (editType.equals("importance")) {
			displayEditString = String.format(MESSAGE_EDIT_IMPORTANCE, editTaskName);
			displayEditString += displayImportance(newTaskFile);
		}

		return displayEditString;
	}

	/**
	 * This method formats the String for the delete command according to its
	 * deleteType
	 * 
	 * @param userCommandSplit
	 *            - an ArrayList<String> returned from tnote.parser.TNotesParser
	 * @param deleteType
	 *            - the delete type
	 * @return formatted String to be displayed to the user
	 * @throws Exception
	 */

	// ==== DELETE ====
	private String formatDeleteCommand(ArrayList<String> userCommandSplit, String deleteType) throws Exception {
		String resultString = "";
		ArrayList<TaskFile> updatedList = new ArrayList<TaskFile>();
		TaskFile deletedTask;

		if (isLetters(deleteType) == 0) {
			resultString = String.format(MESSAGE_UPDATE_SCHEDULE);
			int index = Integer.valueOf(deleteType);
			deletedTask = viewList.get(index - 1);

			updatedList = logic.deleteIndex(viewList, index);
			updateMainScreen(deletedTask.getStartDate());
			resultString += String.format(MESSAGE_DELETE_TASK, deletedTask.getName());

		}

		else if (deleteType.equals("all")) {
			if (logic.clearAll()) {
				resultString += String.format(MESSAGE_DELETE_ALL);
				updateMainScreen("today");
			}
		}

		else {
			resultString = String.format(MESSAGE_UPDATE_SCHEDULE);
			deletedTask = logic.deleteTask(userCommandSplit);
			updateMainScreen(deletedTask.getStartDate());
			resultString += String.format(MESSAGE_DELETE_TASK, deletedTask.getName());
		}
		return resultString;
	}

	/**
	 * This method formats the string for the view command and updates the
	 * changes to the main screen display
	 * 
	 * @param userCommandSplit
	 *            - ArrayList<String> returned from tnote.parser.TNotesParser
	 * @param viewTypeString
	 *            - the type of view that the user wishes to view
	 * @return formatted String to be displayed to the user
	 */

	// ==== VIEW ====

	private String formatViewCommand(ArrayList<String> userCommandSplit, String viewTypeString) {
		ArrayList<TaskFile> viewArray = new ArrayList<TaskFile>();
		TaskFile currTask;
		String formatViewString = "";
		System.out.println(viewTypeString);

		if (viewTypeString.equals("isViewTask")) {
			String taskName = userCommandSplit.get(1);

			try {
				currTask = logic.viewTask(taskName);

				formatViewString += printOneDetailedTask(currTask);

			} catch (Exception e) {
				logger.warning(MESSAGE_LOG_ERROR);
				formatViewString = e.getMessage();
			}
		}

		else if (viewTypeString.equals("isViewDateList")) {
			String date = userCommandSplit.get(1);

			try {
				viewArray = logic.viewDateList(date);

				// Saves copy of current list
				viewList = viewArray;

				// Updates to main screen
				mainScreenArray = viewArray;

				formatViewString = String.format(MESSAGE_SCHEDULE_ONE_DATE, date);

			} catch (Exception e) {
				logger.warning(MESSAGE_LOG_ERROR);
				formatViewString = e.getMessage();
			}
		}

		else if (viewTypeString.equals("isViewManyList")) {
			String dateOne = userCommandSplit.get(1);
			String dateTwo = userCommandSplit.get(2);

			try {

				viewArray = logic.viewManyDatesList(userCommandSplit);

				// Saves copy of current list
				viewList = viewArray;

				// Updates to main screen
				mainScreenArray = viewArray;

				formatViewString = String.format(MESSAGE_SCHEDULE_DATE_TO_DATE, dateOne, dateTwo);

			} catch (Exception e) {
				logger.warning(MESSAGE_LOG_ERROR);
				formatViewString = e.getMessage();
			}

		}

		else if (viewTypeString.equals("isViewNotes")) {
			formatViewString += displayFloats();
		}

		else if (viewTypeString.equals("isViewIndex")) {
			String strIndex = userCommandSplit.get(1);
			int viewIndex = Integer.parseInt(strIndex);
			TaskFile viewTaskFile;

			try {
				viewTaskFile = logic.viewByIndex(viewList, viewIndex);
				formatViewString += printOneDetailedTask(viewTaskFile);
			} catch (Exception e) {
				logger.warning(MESSAGE_LOG_ERROR);
				formatViewString = e.getMessage();
			}
		}

		else if (viewTypeString.equals("isViewHistory")) {
			ArrayList<TaskFile> historyList;

			formatViewString = String.format(MESSAGE_HISTORY_TITLE);
			try {
				historyList = logic.viewDoneList();
				formatViewString += printTaskList(historyList);
			} catch (Exception e) {
				logger.warning(MESSAGE_LOG_ERROR);
				formatViewString = e.getMessage();
			}
		}
		return formatViewString;
	}

	/**
	 * This method formats Strings from TaskFile that are informative to the user
	 * 
	 * @param currTask
	 *            - TaskFile Object
	 * @return formatted Strings from TaskFile
	 */

	private String printOneDetailedTask(TaskFile currTask) {
		String formatViewString;
		formatViewString = String.format(MESSAGE_VIEW_TASK, currTask.getName());
		if (currTask.getIsTask()) {
			formatViewString += String.format(MESSAGE_VIEW_ONE_DATE, "-");
			formatViewString += String.format(MESSAGE_VIEW_ONE_TIME, "-");
		}
		if (currTask.getIsDeadline()) {
			formatViewString += String.format(MESSAGE_VIEW_ONE_DATE, currTask.getStartDate());
			formatViewString += String.format(MESSAGE_VIEW_ONE_TIME, currTask.getStartTime());
		}
		if (currTask.getIsMeeting()) {
			formatViewString += String.format(MESSAGE_VIEW_TWO_DATES, currTask.getStartDate(), currTask.getEndDate());
			formatViewString += String.format(MESSAGE_VIEW_TWO_TIMES, currTask.getStartTime(), currTask.getEndTime());
		}
		if (currTask.hasDetails()) {
			formatViewString += String.format(MESSAGE_VIEW_DETAILS, currTask.getDetails());
		} else {
			formatViewString += String.format(MESSAGE_VIEW_DETAILS, "-");
		}
		if (currTask.getIsDone()) {
			formatViewString += String.format(MESSAGE_VIEW_STATUS, "Completed");
		}
		if (!currTask.getIsDone()) {
			formatViewString += String.format(MESSAGE_VIEW_STATUS, "-");
		}
		if (!currTask.getImportance()) {
			formatViewString += String.format(MESSAGE_VIEW_IMPORTANCE, "-");
		}
		if (currTask.getImportance()) {
			formatViewString += String.format(MESSAGE_VIEW_IMPORTANCE, "Highly Important");
		}
		return formatViewString;
	}

	/**
	 * This method formats the String for the sort command
	 * 
	 * @param userCommandSplit
	 *            - ArrayList<String> returned from tnote.parser.TNotesParser
	 * @param sortType
	 *            - the type of sort that the user wishes to do
	 * @return formatted String to be displayed to the user
	 */

	// ==== Sort ====

	private String formatSortCommand(ArrayList<String> userCommandSplit, String sortType) {
		ArrayList<TaskFile> arraySort;
		String sortString = "";
		String dateOfList = viewList.get(0).getStartDate();

		if (sortType.equals("name")) {
			sortString = String.format(MESSAGE_SORT_CONFIRMATION);

			try {
				arraySort = logic.sortTask(viewList);
				sortString += printTaskList(arraySort);

			} catch (Exception e) {
				logger.warning(MESSAGE_LOG_ERROR);
				sortString = e.getMessage();
			}
		}
		return sortString;
	}

	/**
	 * This method formats String for set command and updates to main screen
	 * display
	 * 
	 * @param userCommandSplit
	 *            - ArrayList<String> returned from tnote.parser.TNotesParser
	 * @param taskName
	 *            - name of task being edited
	 * @return formatted String to be displayed to the user
	 */

	// ==== SET ====

	private String formatSetCommand(ArrayList<String> userCommandSplit, String taskName) {
		String setString = "";
		TaskFile currentTask;

		try {
			currentTask = logic.searchSingleTask(taskName.trim());
			boolean taskStatus = currentTask.getIsDone();
			String newStatus = userCommandSplit.get(2).trim();
			String undone = "[UNDONE]";
			String done = "[DONE]";

			setString += changeTaskStatus(taskName, setString, taskStatus, newStatus, undone, done);

			currentTask = logic.searchSingleTask(taskName.trim());
			setString += printOneDetailedTask(currentTask);

			updateMainScreen(currentTask.getStartDate());
		} catch (Exception e) {
			logger.warning(MESSAGE_LOG_ERROR);
			setString = e.getMessage();
		}
		return setString;
	}

	/**
	 * This method formats String for set command to show previous status and
	 * current set status
	 * 
	 * @param taskName
	 *            - name of tasks to be edited
	 * @param setString
	 *            - the command that the user typed
	 * @param taskStatus
	 *            - the original status of the task
	 * @param newStatus
	 *            - the updated status of the task
	 * @param undone
	 *            - String that prints "undone"
	 * @param done
	 *            - String that prints "done"
	 * @return formatted String to be displayed to user
	 * @throws Exception
	 */
	private String changeTaskStatus(String taskName, String setString, boolean taskStatus, String newStatus,
			String undone, String done) throws Exception {

		if (taskStatus == false && newStatus.equals("done")) {
			if (logic.setStatus(taskName, true)) {
				setString += String.format(MESSAGE_SET_CONFIRMATION, taskName, undone, done);
			}
		}

		else if (taskStatus == true && newStatus.equals("undone")) {
			if (!logic.setStatus(taskName, false)) {
				setString += String.format(MESSAGE_SET_CONFIRMATION, taskName, done, undone);
			}
		}

		else {
			setString = String.format(MESSAGE_SET_ERROR, newStatus);
		}
		return setString;
	}

	/**
	 * This method formats String for search command
	 * 
	 * @param userCommandSplit
	 *            - ArrayList<String> returned by tnote.parser.TNotesParser
	 * @return formatted String to be displayed to the user
	 */

	// ==== SEARCH ====

	private String formatSearchCommand(ArrayList<String> userCommandSplit) {
		ArrayList<TaskFile> arraySearch;
		String searchInput = userCommandSplit.get(1);
		String searchResultString = "";

		try {
			arraySearch = logic.searchTask(userCommandSplit);
			if (!arraySearch.isEmpty()) {
				if (userCommandSplit.size() > 2) {
					searchInput += longSearchInput(userCommandSplit);
				}
				searchResultString = String.format(MESSAGE_SEARCH_CONFIRMATION, searchInput);
				searchResultString += printSearchList(arraySearch);
			} else {
				searchResultString += String.format(MESSAGE_SEARCH_FAILURE);
			}
		} catch (Exception e) {
			logger.warning(MESSAGE_LOG_ERROR);
			searchResultString = e.getMessage();
		}
		return searchResultString;
	}

	private String longSearchInput(ArrayList<String> userCommandSplit) {
		String searchInput = "...";

		for (int i = 2; i < userCommandSplit.size(); i++) {
			searchInput += userCommandSplit.get(i);
			searchInput += "...";
		}
		return searchInput;
	}

	/**
	 * This method formats String for undo command
	 * 
	 * @return formatted String to be displayed to user
	 */

	// ==== UNDO ====

	private String formatUndoCommand() {
		String undoString = "";

		try {
			LogicCommand logicCommand = logic.undo();
			String commandEntered = logicCommand.getCommandType();
			TaskFile taskFile = logicCommand.getOldTask();
			String taskName = taskFile.getName();

			undoString = String.format(MESSAGE_UNDO_CONFIRMATION, commandEntered, taskName);

			String dateOfUpdatedList = taskFile.getStartDate();

			updateMainScreen(dateOfUpdatedList);

		} catch (Exception e) {
			logger.warning(MESSAGE_LOG_ERROR);
			undoString = e.getMessage();
		}
		return undoString;
	}

	/**
	 * This method formats String for redo command
	 * 
	 * @return formatted String to be displayed to the user
	 */

	// ==== REDO ====
	private String formatRedoCommand() {
		String RedoString = "";

		try {
			LogicCommand logicCommand = logic.redo();
			String commandEntered = logicCommand.getCommandType();
			TaskFile taskFile = logicCommand.getOldTask();
			String taskName = taskFile.getName();

			RedoString = String.format(MESSAGE_REDO_CONFIRMATION, commandEntered, taskName);

			String dateOfUpdatedList = taskFile.getStartDate();

			updateMainScreen(dateOfUpdatedList);

		} catch (Exception e) {
			logger.warning(MESSAGE_LOG_ERROR);
			RedoString = e.getMessage();
		}
		return RedoString;
	}

	// ===== GUI Display Screens ====

	/**
	 * This method displays Strings to the main screen
	 * 
	 * @return formated String to be displayed on the main screen
	 */

	// ==== Main screen ====
	public String displayMain() {
		String scheduleString = "";

	
		if (mainScreenArray.size() != 0) {
			scheduleString += printTaskList(mainScreenArray);
			scheduleString += "\n";
		}

		logger.info(MESSAGE_LOG_DISPLAY_MAIN_UPDATED);
		return scheduleString;
	}

	// ==== Side screen ====

	/**
	 * This method displays Strings from overdue tasks to the side screen
	 * 
	 * @return formatted Strings from overdue tasks to the side screen
	 */

	// Display overdue tasks
	public String displayOverdueTasks() {
		String overDueString;

		try {
			ArrayList<TaskFile> arrayOverdue = new ArrayList<TaskFile>();
			arrayOverdue = logic.callOverdueTasks();
			overDueString = String.format(MESSAGE_OVERDUE_TITLE);
			overDueString = printOverDueList(overDueString, arrayOverdue);
			logger.info(MESSAGE_LOG_OVERDUE_TASK_UPDATED);
		} catch (Exception e) {
			logger.warning(MESSAGE_LOG_ERROR);
			overDueString = e.getMessage();
		}
		return overDueString;
	}

	/**
	 * This method formats Strings from an array containing over due tasks
	 * 
	 * @param overDueString
	 *            - String of overdue tasks
	 * @param arrayOverdue
	 *            - array of overdue tasks
	 * @return formated Strings of overdue tasks to be displayed to side screen
	 */

	private String printOverDueList(String overDueString, ArrayList<TaskFile> arrayOverdue) {
		TaskFile overDueTask;

		for (int i = 0; i < arrayOverdue.size(); i++) {
			int indexDisplay = i + 1;
			overDueTask = arrayOverdue.get(i);
			overDueString += String.format(MESSAGE_PRINT_OVERDUE_LIST, indexDisplay, overDueTask.getStartTime(),
					overDueTask.getStartDate(), overDueTask.getName());
		}
		return overDueString;
	}

	/**
	 * This method displays Strings from floating list to the side screen
	 * display
	 * 
	 * @return formatted Strings to be displayed to the side screen display
	 */

	// Display floating tasks
	public String displayFloats() {
		String floatString = "";

		floatString = String.format(MESSAGE_NOTES_TITLE);
		try {
			if (logic.hasFloatingList()) {
				ArrayList<TaskFile> arrayFloat = new ArrayList<TaskFile>();
				arrayFloat = logic.viewFloatingList();
				floatString += printFloatList(floatString, arrayFloat);
				logger.info(MESSAGE_LOG_DISPLAY_NOTES_UPDATED);
			}
		} catch (Exception e) {
			logger.warning(MESSAGE_LOG_ERROR);
			floatString = e.getMessage();

		}
		return floatString;
	}

	/**
	 * This method formats String from an array list of floating tasks
	 * 
	 * @param floatString
	 *            - String of floating tasks
	 * @param arrayFloat
	 *            - Array of floating tasks
	 * @return formatted String of an array list of floating tasks
	 */

	private String printFloatList(String floatString, ArrayList<TaskFile> arrayFloat) {
		int floatIndex;
		TaskFile floatTask;
		String importance;
		String printString = "";

		for (int i = 0; i < arrayFloat.size(); i++) {
			floatIndex = i + 1;
			floatTask = arrayFloat.get(i);
			importance = checkImportance(floatTask);
			printString += String.format(MESSAGE_PRINT_FLOAT_LIST, floatIndex, importance, floatTask.getName());
		}
		printString += "\n";
		return printString;
	}

	/**
	 * This method checks for the importance of the TaskFile Object
	 * 
	 * @param taskFile
	 *            - TaskFile Object
	 * @return formatted String indicating its importance
	 */

	private String checkImportance(TaskFile taskFile) {
		String importance;

		if (taskFile.getImportance()) {
			importance = "[IMPORTANT]";
		} else {
			importance = "";
		}
		return importance;
	}

	/**
	 * This method checks for the command type from the commandString
	 * 
	 * @param commandString
	 *            - the first word that the user typed
	 * @return appropriate COMMAND_TYPE
	 */

	private COMMAND_TYPE determineCommandType(String commandString) {
		if (checkCommand(commandString, "add")) {
			return COMMAND_TYPE.ADD_COMMAND;
		} else if (checkCommand(commandString, "change directory")) {
			return COMMAND_TYPE.CHANGE_DIRECTORY;
		}
		if (checkCommand(commandString, "delete directory")) {
			return COMMAND_TYPE.DELETE_DIRECTORY;
		} else if (checkCommand(commandString, "edit")) {
			return COMMAND_TYPE.EDIT_COMMAND;
		} else if (checkCommand(commandString, "delete")) {
			return COMMAND_TYPE.DELETE_COMMAND;
		} else if (checkCommand(commandString, "view")) {
			return COMMAND_TYPE.VIEW_COMMAND;
		} else if (checkCommand(commandString, "search")) {
			return COMMAND_TYPE.SEARCH_COMMAND;
		} else if (checkCommand(commandString, "set")) {
			return COMMAND_TYPE.SET_COMMAND;
		} else if (checkCommand(commandString, "sort")) {
			return COMMAND_TYPE.SORT_COMMAND;
		} else if (checkCommand(commandString, "help")) {
			return COMMAND_TYPE.HELP_COMMAND;
		} else if (checkCommand(commandString, "undo")) {
			return COMMAND_TYPE.UNDO_COMMAND;
		} else if (checkCommand(commandString, "redo")) {
			return COMMAND_TYPE.REDO_COMMAND;
		} else if (checkCommand(commandString, "exit")) {
			return COMMAND_TYPE.EXIT;
		}

		else {
			return COMMAND_TYPE.INVALID;
		}

	}

	private boolean checkCommand(String commandString, String typeOfCommand) {
		return commandString.equals(typeOfCommand);
	}

	private String getFirstWord(ArrayList<String> userCommandArrayList) {
		return userCommandArrayList.get(0);
	}

	/**
	 * This method checks if nextString are letters
	 * 
	 * @param nextString
	 *            - a String input
	 * @return 1 if String are letter else returns 0
	 */

	private int isLetters(String nextString) {
		if (!nextString.matches("[0-9]+")) {
			return 1;
		} else {
			return 0;
		}
	}

	/**
	 * This method checks for the importance of a taskFile
	 * 
	 * @param taskFile
	 *            - a TaskFile Object
	 * @return "IMPORANT" if the taskFile is important else "NOT IMPORTANT" is
	 *         returned instead
	 */

	private String displayImportance(TaskFile taskFile) {
		String displayImportanceString;

		if (taskFile.getImportance()) {
			displayImportanceString = "IMPORTANT";
		} else {
			displayImportanceString = "NOT IMPORTANT";
		}
		return displayImportanceString;
	}

	/**
	 * This method prints Strings from ArrayList<TaskFile>
	 * 
	 * @param scheduleArray
	 * 					- ArrayList<TaskFile>
	 * @return formatted String from ArrayList<TaskFile>
	 */
	
	private String printTaskList(ArrayList<TaskFile> scheduleArray) {
		String currStartDate = scheduleArray.get(0).getStartDate();
		String printString = String.format(MESSAGE_DATE_TITLE, currStartDate);

		for (int i = 0; i < scheduleArray.size(); i++) {
			TaskFile currTask = scheduleArray.get(i);
			int realIndex = i + 1;
			String importance;

			if (!currStartDate.equals(currTask.getStartDate())) {
				printString += String.format(MESSAGE_DATE_TITLE, currTask.getStartDate());
				currStartDate = currTask.getStartDate();
			}

			importance = checkImportance(currTask);

			if (currTask.getIsDeadline()) {
				printString += String.format(MESSAGE_PRINT_DEADLINE, realIndex, currTask.getStartTime(), importance,
						currTask.getName());
			}

			else if (currTask.getIsMeeting()) {
				if (currTask.getStartDate().trim().equals(currTask.getEndDate().trim())) {
					printString += String.format(MESSAGE_PRINT_MEETING_ONE_DATE, realIndex, currTask.getStartTime(),
							currTask.getEndTime(), currTask.getName(), importance);
				} else {
					printString += String.format(MESSAGE_PRINT_MEETING_TWO_DATES, realIndex, currTask.getStartTime(),
							currTask.getStartDate(), currTask.getEndTime(), currTask.getEndDate(), currTask.getName(),
							importance);
				}
			}
		}
		return printString;
	}

	/**
	 * This method formats Strings from ArrayList<TaskFile> for search commands
	 * 
	 * @param scheduleArray
	 * 					- ArrayList<TaskFile>
	 * @return formatted String from ArrayList<TaskFile> for search commands
	 */
	
	private String printSearchList(ArrayList<TaskFile> scheduleArray) {
		String printString = "";

		for (int i = 0; i < scheduleArray.size(); i++) {
			TaskFile currTask = scheduleArray.get(i);
			int realIndex = i + 1;
			String importance;

			importance = checkImportance(currTask);

			if (currTask.getIsDeadline()) {
				printString += String.format(MESSAGE_PRINT_DEADLINE_W_DATE, realIndex, currTask.getStartDate(),
						currTask.getStartTime(), importance, currTask.getName());
			}

			else if (currTask.getIsMeeting()) {
				if (currTask.getStartDate().trim().equals(currTask.getEndDate().trim())) {
					printString += String.format(MESSAGE_PRINT_MEETING_ONE_DATE_W_DATE, realIndex,
							currTask.getStartDate(), currTask.getStartTime(), currTask.getEndTime(), currTask.getName(),
							importance);
				} else {
					printString += String.format(MESSAGE_PRINT_MEETING_TWO_DATES, realIndex, currTask.getStartTime(),
							currTask.getStartDate(), currTask.getEndTime(), currTask.getEndDate(), currTask.getName(),
							importance);
				}
			}

			else if (currTask.getIsTask()) {
				printString += String.format(MESSAGE_PRINT_FLOAT_LIST, realIndex, currTask.getName(), importance);
			}
		}
		return printString;
	}

	/**
	 * This method updates the main screen display in tnote.gui.view.TNotesOverviewController
	 * 
	 * @param date
	 * 			- date of schedule to be shown
	 */
	private void updateMainScreen(String date) {
		ArrayList<TaskFile> updateArray;

		try {
			updateArray = logic.viewDateList(date);
			mainScreenArray = updateArray;
		} catch (Exception e) {
			logger.warning(MESSAGE_LOG_ERROR);
			e.printStackTrace();
		}
		return;
	}

}
```
###### \src\tnote\ui\TNotesUITest.java
``` java
package tnote.ui;

import static org.junit.Assert.*;
import java.util.*;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.Test;

import tnote.storage.TNotesStorage;
import java.util.Date;
import java.text.DateFormat;
import java.text.SimpleDateFormat;

public class TNotesUITest {
	TNotesUI tnoteUI;
	TNotesStorage storage;

	private String getDate() {
		DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
		Date date = new Date();
		return dateFormat.format(date);
	}

	@Before
	public void setUp() throws Exception {
		tnoteUI = new TNotesUI();
		storage = TNotesStorage.getInstance();
		storage.setUpStorage();
		storage.clearFiles();
	}

	@After
	public void tearDown() throws Exception {
		System.out.println(storage.clearFiles());
	}

	@AfterClass
	public static void tearDownClass() throws Exception {
		TNotesStorage storage = TNotesStorage.getInstance();
		System.out.println(storage.deleteMasterDirectory());
	}

	@Test
	public void checkFormatAddCommandTask() {
		try {
			String expectedOutput = "I have added \"task\" to your notes!\n";
			String userInput = "add task";
			String output = tnoteUI.executeCommand(userInput);
			assertEquals(expectedOutput, output);
		} catch (Exception e) {
			fail("Exception should not be thrown for valid cases");
		}
	}

	@Test
	public void checkFormatAddCommandTaskDetails() {
		try {
			String expectedOutput = "I have added \"read a book\" to your notes!\nThings to note: \"harry potter.\"\n";
			String userInput = "add read a book details harry potter";
			String output = tnoteUI.executeCommand(userInput);
			assertEquals(expectedOutput, output);
		} catch (Exception e) {
			fail("Exception should not be thrown for valid cases");
		}
	}

	@Test
	public void checkFormatAddCommandTaskImportant() {
		try {
			String expectedOutput = "I have added \"meeting\" to your notes!\nNote: Task was noted as important\n";
			String userInput = "add meeting important";
			String output = tnoteUI.executeCommand(userInput);
			assertEquals(expectedOutput, output);
		} catch (Exception e) {
			fail("Exception should not be thrown for valid cases");
		}
	}

	@Test
	public void checkFormatAddCommandDeadlineDay() {
		try {
			String expectedOutput = String.format("I have added \"deadline\" at [23:59] on [%s] to your schedule!\n",
					getDate());
			String userInput = "add deadline due today";
			String output = tnoteUI.executeCommand(userInput);
			assertEquals(expectedOutput, output);
		} catch (Exception e) {
			fail("Exception should not be thrown for valid cases");
		}
	}

	@Test
	public void checkFormatAddCommandDeadlineTime() {
		try {
			String expectedOutput = String.format("I have added \"deadline\" at [15:00] on [%s] to your schedule!\n",
					getDate());
			String userInput = "add deadline due 3pm";
			String output = tnoteUI.executeCommand(userInput);
			assertEquals(expectedOutput, output);
		} catch (Exception e) {
			fail("Exception should not be thrown for valid cases");
		}
	}

	@Test
	public void checkFormatAddCommandDeadlineDateTime() {
		try {
			String expectedOutput = String.format("I have added \"deadline\" at [15:00] on [%s] to your schedule!\n",
					getDate());
			String userInput = "add deadline due today at 3pm";
			String output = tnoteUI.executeCommand(userInput);
			assertEquals(expectedOutput, output);
		} catch (Exception e) {
			fail("Exception should not be thrown for valid cases");
		}
	}

	@Test
	public void checkFormatAddCommandDeadlineSpecificDateTime() {
		try {
			String expectedOutput = String
					.format("I have added \"deadline\" at [15:00] on [2016-09-09] to your schedule!\n");
			String userInput = "add deadline due 9-9-2016 at 3pm";
			String output = tnoteUI.executeCommand(userInput);
			assertEquals(expectedOutput, output);
		} catch (Exception e) {
			fail("Exception should not be thrown for valid cases");
		}
	}

	@Test
	public void checkFormatAddCommandMeetingTime() {
		try {
			String expectedOutput = String.format(
					"I have added \"meeting\" from [%s] at [15:00] to [%s] at [17:00] to your schedule!\n", getDate(),
					getDate());
			String userInput = "add meeting due 3pm to 5pm";
			String output = tnoteUI.executeCommand(userInput);
			assertEquals(expectedOutput, output);
		} catch (Exception e) {
			e.printStackTrace();
			fail("Exception should not be thrown for valid cases");
		}
	}

	@Test
	public void checkFormatAddCommandMeetingDates() {
		try {
			String expectedOutput = "I have added \"meeting\" from [2016-09-08] at [23:59] to [2016-09-10] at [23:59] to your schedule!\n";
			String userInput = "add meeting from 8-9-2016 to 10-9-2016";
			String output = tnoteUI.executeCommand(userInput);
			assertEquals(expectedOutput, output);
		} catch (Exception e) {
			fail("Exception should not be thrown for valid cases");
		}
	}

	@Test
	public void checkFormatAddCommandMeetingDatesTime() {
		try {
			String expectedOutput = "I have added \"meeting\" from [2016-09-08] at [13:00] to [2016-09-10] at [13:00] to your schedule!\n";
			String userInput = "add meeting due 8-9-2016 at 1pm to 10-9-2016 at 1pm";
			String output = tnoteUI.executeCommand(userInput);
			assertEquals(expectedOutput, output);
		} catch (Exception e) {
			fail("Exception should not be thrown for valid cases");
		}
	}

	@Test
	public void checkFormatAddCommandRecurDays() {
		try {
			String expectedOutput = String.format(
					"I have added \"meeting\" at [23:59] on [%s] to your schedule!\nThings to note: \"It recurs every day for 5 days\"\n",
					getDate());
			String userInput = "add meeting due every day for 5 days";
			String output = tnoteUI.executeCommand(userInput);
			assertEquals(expectedOutput, output);
		} catch (Exception e) {
			fail("Exception should not be thrown for valid cases");
		}
	}

	@Test
	public void checkFormatAddCommandRecurWeeks() {
		try {
			String expectedOutput = String.format(
					"I have added \"meeting\" at [23:59] on [%s] to your schedule!\nThings to note: \"It recurs every week for 5 weeks\"\n",
					getDate());
			String userInput = "add meeting due every week for 5 weeks";
			String output = tnoteUI.executeCommand(userInput);
			assertEquals(expectedOutput, output);
		} catch (Exception e) {
			fail("Exception should not be thrown for valid cases");
		}
	}

	@Test
	public void checkFormatEditCommandName() {
		try {
			String userInput = "add meeting from 3pm to 5pm";
			String output = tnoteUI.executeCommand(userInput);
			userInput = "edit meeting name conference";
			output = tnoteUI.executeCommand(userInput);
			String expectedOutput = "You have changed the task name from \"meeting\" to \"conference\"!\n";
			assertEquals(expectedOutput, output);
		} catch (Exception e) {
			fail("Exception should not be thrown for valid cases");
		}
	}

	@Test
	public void checkFormatEditCommandTime() {
		try {
			String userInput = "add meeting from 3pm to 5pm";
			String output = tnoteUI.executeCommand(userInput);
			userInput = "edit meeting time 4pm";
			output = tnoteUI.executeCommand(userInput);
			String expectedOutput = "You have changed the start time in \"meeting\" from [15:00] to [16:00]!\n";
			assertEquals(expectedOutput, output);
		} catch (Exception e) {
			fail("Exception should not be thrown for valid cases");
		}
	}

	@Test
	public void checkFormatEditCommandEndTime() {
		try {
			String userInput = "add meeting from 3pm to 5pm";
			String output = tnoteUI.executeCommand(userInput);
			userInput = "edit meeting endTime 4pm";
			output = tnoteUI.executeCommand(userInput);
			String expectedOutput = "You have changed the end time in \"meeting\" from [17:00] to [16:00]!\n";
			assertEquals(expectedOutput, output);
		} catch (Exception e) {
			fail("Exception should not be thrown for valid cases");
		}
	}

	@Test
	public void checkFormatEditCommandDate() {
		try {
			String userInput = "add meeting from 3pm to 5pm";
			String output = tnoteUI.executeCommand(userInput);
			userInput = "edit meeting endDate 5-5-2016";
			output = tnoteUI.executeCommand(userInput);
			String expectedOutput = String
					.format("You have changed the end date in \"meeting\" from [%s] to [2016-05-05]!\n", getDate());
			assertEquals(expectedOutput, output);
			userInput = "edit meeting startDate 2-5-2016";
			output = tnoteUI.executeCommand(userInput);
			expectedOutput = String
					.format("You have changed the start date in \"meeting\" from [%s] to [2016-05-02]!\n", getDate());
			assertEquals(expectedOutput, output);
		} catch (Exception e) {
			e.printStackTrace();
			fail("Exception should not be thrown for valid cases");
		}
	}

	@Test
	public void checkFormatEditCommandDetails() {
		try {
			String userInput = "add meeting from 3pm to 5pm";
			String output = tnoteUI.executeCommand(userInput);
			userInput = "edit meeting details bring important documents";
			output = tnoteUI.executeCommand(userInput);
			String expectedOutput = "You have changed the details in \"meeting\" from [] to [bring important documents]!\n";
			assertEquals(expectedOutput, output);
		} catch (Exception e) {
			fail("Exception should not be thrown for valid cases");
		}
	}

	@Test
	public void checkFormatEditCommandImportance() {
		try {
			String userInput = "add meeting from 3pm to 5pm";
			String output = tnoteUI.executeCommand(userInput);
			userInput = "edit meeting importance yes";
			output = tnoteUI.executeCommand(userInput);
			String expectedOutput = "You have changed the importance of \"meeting\" to IMPORTANT";
			assertEquals(expectedOutput, output);
		} catch (Exception e) {
			fail("Exception should not be thrown for valid cases");
		}
	}

	@Test
	public void checkFormatDeleteCommandName() {
		try {
			String userInput = "add meeting from 3pm to 5pm";
			String output = tnoteUI.executeCommand(userInput);
			userInput = "delete meeting";
			output = tnoteUI.executeCommand(userInput);
			String expectedOutput = "Schedule has been updated.\nI have deleted \"meeting\" from your schedule for you!\n\n";
			assertEquals(expectedOutput, output);
		} catch (Exception e) {
			fail("Exception should not be thrown for valid cases");
		}
	}

	@Test
	public void checkFormatDeleteIndex() {
		try {
			String userInput = "add meeting due today";
			String output = tnoteUI.executeCommand(userInput);
			userInput = "view today";
			output = tnoteUI.executeCommand(userInput);
			userInput = "delete 1";
			output = tnoteUI.executeCommand(userInput);
			String expectedOutput = "Schedule has been updated.\nI have deleted \"meeting\" from your schedule for you!\n\n";
			assertEquals(expectedOutput, output);
		} catch (Exception e) {
			fail("Exception should not be thrown for valid cases");
		}
	}

	@Test
	public void checkFormatDeleteAll() {
		try {
			String userInput = "add meeting due today";
			String output = tnoteUI.executeCommand(userInput);
			userInput = "add conference due today";
			output = tnoteUI.executeCommand(userInput);
			userInput = "delete all";
			output = tnoteUI.executeCommand(userInput);
			String expectedOutput = "I have deleted EVERYTHING.\n";
			assertEquals(expectedOutput, output);
		} catch (Exception e) {
			fail("Exception should not be thrown for valid cases");
		}
	}

	@Test
	public void checkFormatViewCommandName() {
		try {
			String userInput = "add meeting details meet mr lim";
			String output = tnoteUI.executeCommand(userInput);
			userInput = "view meeting";
			output = tnoteUI.executeCommand(userInput);
			String expectedOutput = "Displaying the task \"meeting\":\n\nDate: -\nTime: -\nDetails: meet mr lim.\nStatus: -\nImportance: -\n";
			assertEquals(expectedOutput, output);
		} catch (Exception e) {
			fail("Exception should not be thrown for valid cases");
		}
	}
	
	@Test
	public void checkFormatViewCommandNameImportant() {
		try {
			String userInput = "add meeting from 3pm to 6pm important";
			String output = tnoteUI.executeCommand(userInput);
			userInput = "view meeting";
			output = tnoteUI.executeCommand(userInput);
			String expectedOutput = String.format("Displaying the task \"meeting\":\n\nDate: %s - %s\nTime: 15:00 - 18:00\nDetails: -\nStatus: -\nImportance: Highly Important\n",getDate(),getDate());
			assertEquals(expectedOutput, output);
		} catch (Exception e) {
			e.printStackTrace();
			fail("Exception should not be thrown for valid cases");
		
		}
	}

	@Test
	public void checkFormatViewCommandToday() {
		try {
			String userInput = "add meeting due today";
			String output = tnoteUI.executeCommand(userInput);
			userInput = "view today";
			output = tnoteUI.executeCommand(userInput);
			String expectedOutput = "You have changed to view schedule for today.\n";
			assertEquals(expectedOutput, output);
		} catch (Exception e) {
			fail("Exception should not be thrown for valid cases");
		}
	}

	@Test
	public void checkFormatViewCommandDate() {
		try {
			String userInput = "add meeting due 5-5-2016";
			String output = tnoteUI.executeCommand(userInput);
			userInput = "add conference from 5-5-2016 to 6-5-2016";
			output = tnoteUI.executeCommand(userInput);
			userInput = "view 5-5-2016";
			output = tnoteUI.executeCommand(userInput);
			String expectedOutput = "You have changed to view schedule for 2016-05-05.\n";
			assertEquals(expectedOutput, output);
		} catch (Exception e) {
			fail("Exception should not be thrown for valid cases");
		}
	}

	@Test
	public void checkFormatViewCommandDateToDate() {
		try {
			String userInput = "add meeting due 5-5-2016";
			String output = tnoteUI.executeCommand(userInput);
			userInput = "add conference due 6-5-2016";
			output = tnoteUI.executeCommand(userInput);
			userInput = "add revise for finals from 6-5-2016 to 8-5-2016";
			output = tnoteUI.executeCommand(userInput);
			userInput = "view 5-5-2016 to 8-5-2016";
			output = tnoteUI.executeCommand(userInput);
			String expectedOutput = "You have changed to view schedule from 2016-05-05 to 2016-05-08.\n";
			assertEquals(expectedOutput, output);
		} catch (Exception e) {
			fail("Exception should not be thrown for valid cases");
		}
	}

	@Test
	public void checkFormatViewCommandIndex() {
		try {
			String userInput = "add meeting due today";
			String output = tnoteUI.executeCommand(userInput);
			userInput = "view today";
			output = tnoteUI.executeCommand(userInput);
			userInput = "view 1";
			output = tnoteUI.executeCommand(userInput);
			String expectedOutput = String.format(
					"Displaying the task \"meeting\":\n\nDate: %s\nTime: 23:59\nDetails: -\nStatus: -\nImportance: -\n",
					getDate());
			assertEquals(expectedOutput, output);
		} catch (Exception e) {
			fail("Exception should not be thrown for valid cases");
		}
	}
	
	@Test
	public void checkFormatViewCommandFloat() {
		try {
			String userInput = "add meeting important";
			String output = tnoteUI.executeCommand(userInput);
			userInput = "view notes";
			output = tnoteUI.executeCommand(userInput);
			String expectedOutput = "====NOTES====\n1. [IMPORTANT]meeting\n\n";
			assertEquals(expectedOutput, output);
		} catch (Exception e) {
			fail("Exception should not be thrown for valid cases");
		}
	}
	
	@Test
	public void checkFormatViewCommandHistory() {
		try {
			String userInput = "add meeting due today";
			String output = tnoteUI.executeCommand(userInput);
			userInput = "set meeting done";
			output = tnoteUI.executeCommand(userInput);
			userInput = "view history";
			output = tnoteUI.executeCommand(userInput);
			String expectedOutput = String.format("====HISTORY====\n=======%s=======\n1. [23:59] meeting\n",getDate());
			assertEquals(expectedOutput, output);
		} catch (Exception e) {
			fail("Exception should not be thrown for valid cases");
		}
	}

	@Test
	public void checkSortCommand() {
		try {
			String userInput = "add apple due 4pm";
			String output = tnoteUI.executeCommand(userInput);
			userInput = "add banana due 1pm";
			output = tnoteUI.executeCommand(userInput);
			userInput = "view today";
			output = tnoteUI.executeCommand(userInput);
			userInput = "sort by name";
			output = tnoteUI.executeCommand(userInput);
			String expectedOutput = String.format(
					"I have sorted everything by name for you! I'm so amazing, what would you do without me!\n=======%s=======\n1. [16:00] apple\n2. [13:00] banana\n",
					getDate());
			assertEquals(expectedOutput, output);
		} catch (Exception e) {
			fail("Exception should not be thrown for valid cases");
		}
	}

	@Test
	public void checkUndoCommand() {
		try {
			String userInput = "add meeting";
			String output = tnoteUI.executeCommand(userInput);
			userInput = "undo";
			output = tnoteUI.executeCommand(userInput);
			String expectedOutput = "You have undone add meeting!\n";
			assertEquals(expectedOutput, output);
		} catch (Exception e) {
			fail("Exception should not be thrown for valid cases");
		}
	}

	@Test
	public void checkRedoCommand() {
		try {
			String userInput = "add meeting";
			String output = tnoteUI.executeCommand(userInput);
			userInput = "undo";
			output = tnoteUI.executeCommand(userInput);
			userInput = "redo";
			output = tnoteUI.executeCommand(userInput);
			String expectedOutput = "You have redone add meeting!\n";
			assertEquals(expectedOutput, output);
		} catch (Exception e) {
			fail("Exception should not be thrown for valid cases");
		}
	}

	@Test
	public void checkSearchCommand() {
		try {
			String userInput = "add apple";
			String output = tnoteUI.executeCommand(userInput);
			userInput = "add banana";
			output = tnoteUI.executeCommand(userInput);
			userInput = "add apple banana";
			output = tnoteUI.executeCommand(userInput);
			userInput = "search apple";
			output = tnoteUI.executeCommand(userInput);
			String expectedOutput = "Searching for \"apple\" .......This is what I've found:\n1. apple\n2. apple banana\n";
			assertEquals(expectedOutput, output);
			userInput = "search a e";
			output = tnoteUI.executeCommand(userInput);
			expectedOutput = "Searching for \"a...e...\" .......This is what I've found:\n1. apple\n2. apple banana\n";
			assertEquals(expectedOutput, output);
		} catch (Exception e) {
			fail("Exception should not be thrown for valid cases");
		}
	}
	
	@Test
	public void checkSearchCommandFail() {
		try {
			String userInput = "add apple";
			String output = tnoteUI.executeCommand(userInput);
			userInput = "add banana";
			output = tnoteUI.executeCommand(userInput);
			userInput = "add apple banana";
			output = tnoteUI.executeCommand(userInput);
			userInput = "search pear";
			output = tnoteUI.executeCommand(userInput);
			String expectedOutput = "Nothing was found......\n";
			assertEquals(expectedOutput, output);
		} catch (Exception e) {
			fail("Exception should not be thrown for valid cases");
		}
	}

	@Test
	public void checkSetCommand() {
		try {
			String userInput = "add meeting due today";
			String output = tnoteUI.executeCommand(userInput);
			userInput = "set meeting done";
			output = tnoteUI.executeCommand(userInput);
			String expectedOutput = String.format(
					"You have changed the status in \"meeting\" from [UNDONE] to [DONE]\n\nDisplaying the task \"meeting\":\n\nDate: %s\nTime: 23:59\nDetails: -\nStatus: Completed\nImportance: -\n",
					getDate());
			assertEquals(expectedOutput, output);
			userInput = "set meeting undone";
			output = tnoteUI.executeCommand(userInput);
			expectedOutput = String.format(
					"You have changed the status in \"meeting\" from [DONE] to [UNDONE]\n\nDisplaying the task \"meeting\":\n\nDate: %s\nTime: 23:59\nDetails: -\nStatus: -\nImportance: -\n",
					getDate());
			assertEquals(expectedOutput, output);
			userInput = "set meeting undone";
			output = tnoteUI.executeCommand(userInput);
			expectedOutput = String.format("Error. The task is already undone!\nDisplaying the task \"meeting\":\n\nDate: %s\nTime: 23:59\nDetails: -\nStatus: -\nImportance: -\n",getDate());
			assertEquals(expectedOutput, output);
		} catch (Exception e) {
			fail("Exception should not be thrown for valid cases");
		}
	}

	@Test
	public void checkDeleteDirCommand() {
		try {
			String userInput = "add meeting due 10-10-2016";
			String output = tnoteUI.executeCommand(userInput);
			userInput = "delete directory october";
			output = tnoteUI.executeCommand(userInput);
			String expectedOutput = "You have succesfully deleted the directory: october\n";
			assertEquals(expectedOutput, output);
		} catch (Exception e) {
			fail("Exception should not be thrown for valid cases");
		}
	}
	
	@Test
	public void checkChangeDirCommand() {
		try {
			String userInput = "add meeting due 10-10-2016";
			String output = tnoteUI.executeCommand(userInput);
			userInput = "change directory location to NewFolder";
			output = tnoteUI.executeCommand(userInput);
			String expectedOutput = "You have succesfully changed directory to NewFolder.\n";
			assertEquals(expectedOutput, output);
		} catch (Exception e) {
			fail("Exception should not be thrown for valid cases");
		}
	}
	
	@Test
	public void checkHelpCommand() {
		try {
			String userInput = "help";
			String output = tnoteUI.executeCommand(userInput);
			TNotesMessages msg = new TNotesMessages();
			String expectedOutput = "List of available commands:\n\nNote: words in [] should be modified to your needs.\n\n";
			expectedOutput += msg.printHelpArray();
			assertEquals(expectedOutput, output);
		} catch (Exception e) {
			fail("Exception should not be thrown for valid cases");
		}
	}
	
	@Test
	public void checkWelcomeMsg(){
		String output = tnoteUI.getWelcomeMessage();
		String expectedOutput = "Hello, welcome to T-Note. How may I help you?\n";
		assertEquals(expectedOutput, output);
	}
	
	
}
```
