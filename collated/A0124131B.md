# A0124131B
###### \src\tnote\object\NameComparator.java
``` java
package tnote.object;

import java.util.Comparator;

/**
 * This class is a comparator class for the TaskFile object. It allows TaskFile
 * objects to be sorted in alphabetical order
 * 
 * @author A0124131B
 *
 */
public class NameComparator implements Comparator<TaskFile> {

	@Override
	public int compare(TaskFile task1, TaskFile task2) {
		return task1.getName().compareTo(task2.getName());
	}
}
```
###### \src\tnote\object\RecurringTaskFile.java
``` java
package tnote.object;

import java.text.ParseException;
import java.util.ArrayList;

import tnote.util.exceptions.IncorrectTimeException;

/**
 * This class is used to represent recurring tasks in TNotes, as recurring tasks
 * require some additional information to be stored
 * 
 * @author A0124131B
 *
 */

public class RecurringTaskFile extends TaskFile {
	private String recurringInterval;
	private ArrayList<String> listOfRecurStartDates;
	private ArrayList<String> listOfRecurEndDates;

	/*--------------------Constructors-----------------------------*/
	/**
	 * Basic constructor for RecurringTaskFile
	 */
	public RecurringTaskFile() {
		recurringInterval = new String();
		listOfRecurStartDates = new ArrayList<String>();
		listOfRecurEndDates = new ArrayList<String>();
	}

	/**
	 * Constructor for RecurringTaskFile which takes in a TaskFile object,
	 * creating a copy of the TaskFile object
	 * 
	 * @param task
	 *            the TaskFile object to copy
	 * @throws ParseException
	 *             Error when the start date and time or end date and time
	 *             cannot be parsed into a calendar object
	 * @throws IncorrectTimeException
	 *             Error when the end date and time is before the start date and
	 *             time
	 */
	public RecurringTaskFile(TaskFile task) throws ParseException, IncorrectTimeException {
		super(task);
		recurringInterval = new String();
		listOfRecurStartDates = new ArrayList<String>();
		listOfRecurEndDates = new ArrayList<String>();
	}

	/*---------------------------------Accessors------------------------------------*/

	/**
	 * Method to retrieve the recurring interval of the RecurringTaskFile
	 * 
	 * @return String the recurring interval of the RecurringTaskFile
	 */
	public String getRecurringInterval() {
		return recurringInterval;
	}

	/**
	 * Method to retrieve the list of starting dates for the RecurringTaskFile
	 * 
	 * @return ArrayList{@code<String>} the list of starting dates for the
	 *         RecurringTaskFile
	 */
	public ArrayList<String> getListOfRecurStartDates() {
		return listOfRecurStartDates;
	}

	/**
	 * Method to retrieve the list of ending dates for the RecurringTaskFile
	 * 
	 * @return ArrayList{@code<String>} the list of ending dates for the
	 *         RecurringTaskFile
	 */
	public ArrayList<String> getListOFRecurEndDates() {
		return listOfRecurEndDates;
	}

	/*-------------------------------Mutators--------------------------------------------*/

	/**
	 * Method to set the recurring interval attribute in the RecurringTaskFile
	 * 
	 * @param interval
	 *            the String to set as the recurringInterval for the
	 *            RecurringTaskFile
	 */
	public void setRecurringInterval(String interval) {
		this.recurringInterval = interval;
	}

	/**
	 * Method to add a list of dates as the starting dates for the
	 * RecurringTaskFile
	 * 
	 * @param date
	 *            the list of Strings to set as the list of starting dates for
	 *            the RecurringTaskFile
	 */
	public void addRecurringStartDate(ArrayList<String> date) {
		this.listOfRecurStartDates = date;
	}

	/**
	 * Method to add a list of dates as the ending dates for the
	 * RecurringTaskFile
	 * 
	 * @param date
	 *            the list of Strings to set as the list of ending dates for the
	 *            RecurringTaskFile
	 */
	public void addRecurringEndDate(ArrayList<String> date) {
		this.listOfRecurEndDates = date;
	}
}
```
###### \src\tnote\object\RecurringTaskFileTest.java
``` java
package tnote.object;

import static org.junit.Assert.*;

import java.util.ArrayList;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

public class RecurringTaskFileTest {
	TaskFile task;
	RecurringTaskFile rTask;

	@Before
	public void setUp() throws Exception {
		task = new TaskFile("call bro", "2016-03-02", "11:00", "2016-03-04", "10:00", "abc", false, false);
	}

	@After
	public void tearDown() throws Exception {
	}

	@Test
	public void test() {
		try {
			rTask = new RecurringTaskFile(task);

			ArrayList<String> startDates1 = new ArrayList<String>();
			startDates1.add("2016-04-09");
			startDates1.add("2016-04-10");
			startDates1.add("2016-04-11");
			startDates1.add("2016-04-12");
			startDates1.add("2016-04-13");

			ArrayList<String> startDates2 = new ArrayList<String>();
			startDates2.add("2016-04-20");
			startDates2.add("2016-04-27");
			startDates2.add("2016-05-04");
			startDates2.add("2016-05-11");

			ArrayList<String> endDates1 = new ArrayList<String>();
			endDates1.add("2016-04-10");
			endDates1.add("2016-04-11");
			endDates1.add("2016-04-12");
			endDates1.add("2016-04-13");
			endDates1.add("2016-04-14");

			ArrayList<String> endDates2 = new ArrayList<String>();
			endDates2.add("2016-04-20");
			endDates2.add("2016-04-27");
			endDates2.add("2016-05-04");
			endDates2.add("2016-05-11");

			// Test get interval
			assertEquals("Check get interval", "", rTask.getRecurringInterval());

			// Test set interval
			rTask.setRecurringInterval("week");
			assertEquals("Check set interval", "week", rTask.getRecurringInterval());

			// Test get Start Date list
			ArrayList<String> emptyList = new ArrayList<String>();
			assertEquals("Check get list of recur start date", emptyList, rTask.getListOfRecurStartDates());

			// Test set Start Date list
			rTask.addRecurringStartDate(startDates1);
			assertEquals("Check set list 1 of recur start dates", startDates1, rTask.getListOfRecurStartDates());

			rTask.addRecurringStartDate(startDates2);
			assertEquals("Check set list 2 of recur start dates", startDates2, rTask.getListOfRecurStartDates());

			// Test get end date list
			assertEquals("Check get list of recur end dates", emptyList, rTask.getListOFRecurEndDates());

			// Test set end date list
			rTask.addRecurringEndDate(endDates1);
			assertEquals("Check set list 1 of recur end dates", endDates1, rTask.getListOFRecurEndDates());

			rTask.addRecurringEndDate(endDates2);
			assertEquals("Check set list 2 of recur end dates", endDates2, rTask.getListOFRecurEndDates());

		} catch (Exception e) {
			fail("Exception should not be thrown for valid cases");
		}
	}

}
```
###### \src\tnote\object\TaskFile.java
``` java
package tnote.object;

import static org.junit.Assert.assertTrue;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.logging.Logger;

import tnote.util.exceptions.IncorrectTimeException;

/**
 * This class is the basic object used in TNote
 * It contains all the necessary information necessary for a single task in TNote
 * 
 * @author A0124131B
 *
 */

public class TaskFile implements Comparable<TaskFile>, Cloneable {

	private static final String MESSAGE_TASK_TYPE_SET_UP = "Task type set up complete for task %s";
	private static final String MESSAGE_TASK_CALS_SET_UP = "Calendars set up for task %s";
	private static final String MESSAGE_TASK_DATES_SET_UP = "Dates set up for %s";
	private static final String MESSAGE_TASK_SET_UP = "task %s is set up";

	private static final String ERROR_INCORRECT_TIMING = "The specified end time %s is before the start time %s";
	private static final String ERROR_INCORRECT_FORMAT_END_CAL = "Incorrect date/time format for end cal for task %s";
	private static final String ERROR_INCORRECT_FORMAT_START_CAL = "Incorrect date/time format for start cal for task %s";

	private static final String DEFAULT_TIME = "23:59";
	private static final String DATE_TIME_STRING_FORMAT = "%s %s";
	private static final String DATE_ONLY_FORMAT = "yyyy-MM-dd";
	private static final String DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm";
	private static final String TASKFILE_TO_STRING = "Task: %s, Start Date: %s, Start Time: %s, End Date: %s, "
			+ "End Time: %s, Details: %s, Importance: %s, IsRecurring: %s, IsDone: %s";

	private static final Logger logger = Logger.getGlobal();

	private String name;
	private String startDate;
	private String startTime;
	private String endDate;
	private String endTime;
	private String details;

	private boolean isRecurr;
	private boolean isImportant;
	private boolean isDone;

	private transient boolean isDeadline;
	private transient boolean isTask;
	private transient boolean isMeeting;

	private transient Calendar startCal;
	private transient Calendar endCal;

	/*----------------------Constructors-------------------------- */

	/**
	 * Constructor for an empty TaskFile object
	 */
	public TaskFile() {

		setName("");
		setStartDate("");
		setStartTime("");
		setIsRecurr(false);
		setEndDate("");
		setEndTime("");
		setDetails("");
		setImportance(false);
		setIsDone(false);

		initializeTaskTypes();
	}

	/**
	 * Constructor for a task file with only a name
	 * 
	 * @param name
	 *            the name of the TaskFile object
	 * @throws ParseException
	 *             Error when the start date and time or end date and time
	 *             cannot be parsed into a calendar object
	 * @throws IncorrectTimeException
	 *             Error when the end date and time is before the start date and
	 *             time
	 */
	public TaskFile(String name) throws ParseException, IncorrectTimeException {
		this(name, "", "", "", "", "", false, false);
	}

	/**
	 * Constructor for a TaskFile object with a name, starting date and time,
	 * details, an isImportant boolean and an isRecurring boolean
	 * 
	 * @param name
	 *            the name of the TaskFile object
	 * @param date
	 *            the starting date of the TaskFile object
	 * @param time
	 *            the starting time of the TaskFile object
	 * @param details
	 *            the details of the TaskFileobject
	 * @param isImportant
	 *            a boolean flag setting whether the TaskFile is important
	 * @param isRecurr
	 *            a boolean flag setting whether the TaskFile is a recurring
	 *            task
	 * @throws ParseException
	 *             Error when the start date and time or end date and time
	 *             cannot be parsed into a calendar object
	 * @throws IncorrectTimeException
	 *             Error when the end date and time is before the start date and
	 *             time
	 */
	public TaskFile(String name, String date, String time, String details, boolean isImportant, boolean isRecurr)
			throws ParseException, IncorrectTimeException {
		this(name, date, time, "", "", details, isImportant, isRecurr);
	}

	/**
	 * Constructor for a TaskFile object with a name, start date and time, end
	 * date and time, details, an isImportant boolean and an isRecurring boolean
	 * 
	 * @param name
	 *            the name of the TaskFile object
	 * @param startDate
	 *            the starting date of the TaskFile object
	 * @param startTime
	 *            the starting time of the TaskFile object
	 * @param endDate
	 *            the ending date of the TaskFile object
	 * @param endTime
	 *            the ending time of the TaskFile object
	 * @param details
	 *            the details of the TaskFile object
	 * @param isImportant
	 *            a boolean flag setting whether the TaskFile is important
	 * @param isRecurr
	 *            a boolean flag setting whether the TaskFile is a recurring
	 *            task
	 * @throws ParseException
	 *             Error when the start date and time or end date and time
	 *             cannot be parsed into a calendar object
	 * @throws IncorrectTimeException
	 *             Error when the end date and time is before the start date and
	 *             time
	 */
	public TaskFile(String name, String startDate, String startTime, String endDate, String endTime,
			String details, boolean isImportant, boolean isRecurr)
			throws ParseException, IncorrectTimeException {

		setName(name);
		setStartDate(startDate);
		setStartTime(startTime);
		setEndDate(endDate);
		setEndTime(endTime);

		setDetails(details);
		setImportance(isImportant);
		setIsRecurr(isRecurr);
		setIsDone(false);
		setUpTaskFile();

	}

	/**
	 * Constructor which creates a new TaskFile object as an exact copy of a
	 * specified TaskFile object
	 * 
	 * @param task
	 *            the TaskFile object to copy
	 * @throws ParseException
	 *             Error when the start date and time or end date and time
	 *             cannot be parsed into a calendar object
	 * @throws IncorrectTimeException
	 *             Error when the end date and time is before the start date and
	 *             time
	 */
	public TaskFile(TaskFile task) throws ParseException, IncorrectTimeException {
		this(task.getName(), task.getStartDate(), task.getStartTime(), task.getEndDate(), task.getEndTime(),
				task.getDetails(), task.getImportance(), task.getIsRecurring());
	}

	/*-----------------------Accessors--------------------------*/
	/**
	 * Method to get the ending time of the TaskFile
	 * 
	 * @return String the ending time of the TaskFile
	 */
	public String getEndTime() {
		return endTime;
	}

	/**
	 * Method to get the ending date of the TaskFile
	 * 
	 * @return String the ending date of the TaskFile
	 */
	public String getEndDate() {
		return endDate;
	}

	/**
	 * Method to get the details String of the TaskFile
	 * 
	 * @return String the details of the TaskFile
	 */
	public String getDetails() {
		return details;
	}

	/**
	 * Method to get the importance flag in the TaskFile
	 * 
	 * @return true if the TaskFile is set as important
	 */
	public boolean getImportance() {
		return isImportant;
	}

	/**
	 * Method to get the the done status of the TaskFile
	 * 
	 * @return true if the TaskFile is set as done
	 */
	public boolean getIsDone() {
		return isDone;
	}

	/**
	 * Method to get the deadline flag in the TaskFile
	 * 
	 * @return true if the TaskFile is a deadline task with only a start date
	 *         and time
	 */
	public boolean getIsDeadline() {
		return isDeadline;
	}

	/**
	 * Method to get the task flag in the TaskFile
	 * 
	 * @return true if TaskFile has no starting date and time or ending date and
	 *         time
	 */
	public boolean getIsTask() {
		return isTask;
	}

	/**
	 * Method to get the meeting flag in the TaskFile
	 * 
	 * @return true if the TaskFile contains a start and end date and time
	 */
	public boolean getIsMeeting() {
		return isMeeting;
	}

	/**
	 * Method to get the calendar object representing the starting date and time
	 * of the TaskFile
	 * 
	 * @return Calendar the Calendar object representing the starting date and
	 *         time of the TaskFile
	 */
	public Calendar getStartCal() {
		return startCal;
	}

	/**
	 * Method to get the calendar object representing the ending date and time
	 * of the TaskFile
	 * 
	 * @return Calendar the Calendar object representing the ending date and
	 *         time of the TaskFile
	 */
	public Calendar getEndCal() {
		return endCal;
	}

	/**
	 * Method to get the name of the TaskFile
	 * 
	 * @return String the name of the TaskFile
	 */
	public String getName() {
		return name;
	}

	/**
	 * Method to get the start time String of the TaskFile
	 * 
	 * @return String the start time String of the TaskFile
	 */
	public String getStartTime() {
		return startTime;
	}

	/**
	 * Method to get the start date String of the TaskFile
	 * 
	 * @return String the start date String of the TaskFile
	 */
	public String getStartDate() {
		return startDate;
	}

	/**
	 * Method to get the recurring flag in a TaskFile
	 * 
	 * @return true if the TaskFile is set as a recurring task
	 */
	public boolean getIsRecurring() {
		return isRecurr;
	}

	/**
	 * Method to check if the TaskFile contains any details
	 * 
	 * @return true if the taskFil contains details
	 */
	public boolean hasDetails() {
		if (this.getDetails().isEmpty()) {
			return false;
		} else {
			return true;
		}
	}

	/*-------------------------------Mutators---------------------*/

	/**
	 * Method to set the name of the TaskFile
	 * 
	 * @param task
	 *            the String to be set as the TaskFile's name
	 */
	public void setName(String task) {
		this.name = task;
	}

	/**
	 * Method to set the start date of the TaskFile
	 * 
	 * @param startDate
	 *            the String to be set as the TaskFile's starting date
	 */
	public void setStartDate(String startDate) {
		this.startDate = startDate;

	}

	/**
	 * Method to set the start time of the TaskFile
	 * 
	 * @param startTime
	 *            the String to be set as the TaskFile's starting time
	 */
	public void setStartTime(String startTime) {
		this.startTime = startTime;
	}

	/**
	 * Method to set the isRecurring flag in the TaskFile. If flag is set to
	 * true, the TaskFile is considered a recurring task
	 * 
	 * @param isRecurr
	 *            the boolean value to set the isRecurring value in the TaskFile
	 *            to
	 */
	public void setIsRecurr(boolean isRecurr) {
		this.isRecurr = isRecurr;
	}

	/**
	 * Method to set the end date of the TaskFile
	 * 
	 * @param endDate
	 *            the String to be set as the TaskFile's ending date
	 */
	public void setEndDate(String endDate) {
		this.endDate = endDate;
	}

	/**
	 * Method to set the end time of the TaskFile
	 * 
	 * @param endTime
	 *            the String to be set as the TaskFile's ending time
	 */
	public void setEndTime(String endTime) {
		this.endTime = endTime;
	}

	/**
	 * Method to set the details of the TaskFile
	 * 
	 * @param details
	 *            the String to be set as the TaskFile's details
	 */
	public void setDetails(String details) {
		this.details = details;
	}

	/**
	 * Method to set the importance flag inside the TaskFile. If flag is set to
	 * true, the TaskFile is considered important
	 * 
	 * @param importance
	 *            the boolean value to set the isImportant value in the TaskFile
	 *            to
	 */
	public void setImportance(boolean importance) {
		this.isImportant = importance;
	}

	/**
	 * Method to set the done status flag in the TaskFile. If flag is set to
	 * true, the TaskFile is considered done
	 * 
	 * @param status
	 *            the boolean value the set the isDone value in the TaskFile to
	 */
	public void setIsDone(boolean status) {
		isDone = status;
	}

	/*----------------------------Set Up------------------------------------*/

	/**
	 * Method to setup the necessary variables inside a task file such as
	 * calendars, task type flags
	 * 
	 * @throws ParseException
	 *             Error parsing the date time Strings into a Calendar object
	 * @throws IncorrectTimeException
	 *             Error when the end date and time of the TaskFile is before
	 *             its start date and time
	 */
	public void setUpTaskFile() throws ParseException, IncorrectTimeException {

		setUpDates();
		setUpCal();
		setTypeOfTask();

		logger.info(String.format(MESSAGE_TASK_SET_UP, name));

	}

	/**
	 * Method to set up all the date Strings inside the TaskFile object Empty
	 * date Strings are filled up either as the current date, or the value which
	 * the start or end date contains Empty time Strings are given the default
	 * value of 23:59
	 */
	private void setUpDates() {
		String currentDateString = getCurrentDate();

		if (startDate.isEmpty() && !startTime.isEmpty()) {
			setStartDate(currentDateString);
		} else if (!startDate.isEmpty() && startTime.isEmpty()) {
			setStartTime(DEFAULT_TIME);
		} else {
			assertTrue((startDate.isEmpty() && startTime.isEmpty()) || 
					(!startDate.isEmpty() && !startTime.isEmpty()));
		}

		if (endDate.isEmpty() && !endTime.isEmpty()) {
			setEndDate(startDate);
		} else if (!endDate.isEmpty() && endTime.isEmpty()) {
			setEndTime(DEFAULT_TIME);
		} else {
			assertTrue((endDate.isEmpty() && endTime.isEmpty()) || 
					(!endDate.isEmpty() && !endTime.isEmpty()));
		}

		logger.info(String.format(MESSAGE_TASK_DATES_SET_UP, name));
	}

	/**
	 * Method to set up the calendars inside the TaskFile object. Calendar
	 * objects are only set up if their respective date Strings are not empty
	 * 
	 * @throws ParseException
	 *             Error parsing the date time Strings into a Calendar object
	 * @throws IncorrectTimeException
	 *             Error when the end date and time of the TaskFile is before
	 *             its start date and time
	 */
	private void setUpCal() throws ParseException, IncorrectTimeException {
		if (!startDate.isEmpty()) {
			startCal = Calendar.getInstance();
			setStartCal();

			if (!endDate.isEmpty()) {
				endCal = Calendar.getInstance();
				setEndCal();

				if (endCal.before(startCal)) {
					SimpleDateFormat stringToDateFormat = new SimpleDateFormat(DATE_TIME_FORMAT);
					String startCalString = stringToDateFormat.format(startCal.getTime());
					String endCalString = stringToDateFormat.format(endCal.getTime());

					throw new IncorrectTimeException(
							String.format(ERROR_INCORRECT_TIMING, endCalString, startCalString), getName());
				}
			}
		}
		logger.info(String.format(MESSAGE_TASK_CALS_SET_UP, name));
	}

	/**
	 * Method to convert the starting date and time Strings into the startCal
	 * Calendar object
	 * 
	 * @throws ParseException
	 *             Error parsing the date time Strings into a Calendar object
	 */
	private void setStartCal() throws ParseException {
		try {
			Date date = convertStringToDate(startDate, startTime);
			startCal.setTime(date);
		} catch (ParseException pEx) {
			String errorMessage = String.format(ERROR_INCORRECT_FORMAT_START_CAL, name);

			logger.warning(errorMessage);
			throw new ParseException(errorMessage, pEx.getErrorOffset());
		}

	}

	/**
	 * Method to convert the ending date and time Strings into the endCal
	 * Calendar object
	 * 
	 * @throws ParseException
	 *             Error parsing the date time Strings into a Calendar object
	 */
	private void setEndCal() throws ParseException {
		try {
			Date date = convertStringToDate(endDate, endTime);
			endCal.setTime(date);
		} catch (ParseException pEx) {
			String errorMessage = String.format(ERROR_INCORRECT_FORMAT_END_CAL, name);

			logger.warning(errorMessage);
			throw new ParseException(errorMessage, pEx.getErrorOffset());
		}
	}

	/**
	 * Method to set the type of task the TaskFile object is
	 */
	private void setTypeOfTask() {
		initializeTaskTypes();

		if (startDate.isEmpty()) {
			isTask = true;
		} else if (endDate.isEmpty()) {
			isDeadline = true;
		} else {
			isMeeting = true;
		}

		logger.info(String.format(MESSAGE_TASK_TYPE_SET_UP, name));
	}

	/**
	 * Method to concatenate the date and time String and convert them into a
	 * Date object
	 * 
	 * @param dateString
	 *            the date String
	 * @param timeString
	 *            the time String
	 * @return Date object representing the date and time String
	 * @throws ParseException
	 *             Error parsing the date time Strings into a Date object
	 */
	private Date convertStringToDate(String dateString, String timeString) throws ParseException {
		String dateTimeString;
		Date date;
		SimpleDateFormat stringToDateFormat;

		stringToDateFormat = new SimpleDateFormat(DATE_TIME_FORMAT);

		dateTimeString = combineDateTime(dateString, timeString);

		date = stringToDateFormat.parse(dateTimeString);

		return date;
	}

	/**
	 * Method to initialize all the task type flags to false
	 */
	private void initializeTaskTypes() {
		isDeadline = false;
		isTask = false;
		isMeeting = false;
	}

	/**
	 * Method to retrieve the current date from the system
	 * 
	 * @return String the date String representing the current date
	 */
	private String getCurrentDate() {
		SimpleDateFormat currentDateFormat = new SimpleDateFormat(DATE_ONLY_FORMAT);
		Date currentDate = new Date();
		String currentDateString = currentDateFormat.format(currentDate);
		return currentDateString;
	}

	/**
	 * Method to concatenate the date and time Strings in a specific format
	 * 
	 * @param date
	 *            the date String
	 * @param time
	 *            the time String
	 * @return the concatenated date and time String
	 */
	private String combineDateTime(String date, String time) {
		return String.format(DATE_TIME_STRING_FORMAT, date, time);
	}

	/*---------------------------Overriding methods--------------------------------*/

	@Override
	public String toString() {
		String taskFileInString = String.format(TASKFILE_TO_STRING, name, startDate, startTime,
				endDate, endTime, details, isImportant, isRecurr, isDone);

		return taskFileInString;
	}

	@Override
	public int compareTo(TaskFile taskFile) {
		if (getIsTask()) {
			if (taskFile.getIsTask()) {
				return getName().compareTo(taskFile.getName());
			} else {
				return -1;
			}
		} else {
			if (taskFile.getIsTask()) {
				return 1;
			} else {
				if (getStartCal().equals(taskFile.getStartCal())) {
					return getName().compareTo(taskFile.getName());
				} else {
					return getStartCal().compareTo(taskFile.getStartCal());
				}
			}
		}
	}

	@Override
	public boolean equals(Object obj) {
		TaskFile otherObj = (TaskFile) obj;
		return this.toString().equals(otherObj.toString());
	}

	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
}
```
###### \src\tnote\object\TaskFileTest.java
``` java
package tnote.object;

import static org.junit.Assert.assertTrue;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;


import tnote.util.exceptions.IncorrectTimeException;

public class TaskFileTest {

	TaskFile task;

	@Before
	public void setUp() throws Exception {
	}

	@After
	public void tearDown() throws Exception {
	}

	@Test
	public void testFloatingGetSetNameImportanceDoneDetails() {
		try {
			task = new TaskFile("floating task");

			// Test task flag
			assertTrue("check task flag", task.getIsTask());
			assertFalse("check other deadline flag", task.getIsDeadline());
			assertFalse("check other meeting flag", task.getIsMeeting());

			// Test get name
			assertEquals("check get name", "floating task", task.getName());

			// Test set name
			task.setName("new task name");
			assertEquals("check set name", "new task name", task.getName());

			// Test get done, default is false
			assertFalse("check get done", task.getIsDone());

			// Test set done
			task.setIsDone(true);
			assertTrue("check set done", task.getIsDone());

			// Test get has details, get details
			assertFalse("check has details false", task.hasDetails());
			assertEquals("check empty details", "", task.getDetails());

			// Test set details
			task.setDetails("new detail string 1234");
			assertEquals("check set details", "new detail string 1234", task.getDetails());
			assertTrue("check has details true", task.hasDetails());

			// Test get importance, default is false
			assertFalse("check get importance", task.getImportance());

			// Test set importance
			task.setImportance(true);
			assertTrue("check set importance", task.getImportance());

		} catch (Exception e) {
			fail("Exception should not be thrown for valid cases");
		}
	}

	@Test
	public void testDeadlineStartDateTimeRecurStartCal() {
		try {
			task = new TaskFile("deadline task");

			// Test get start time
			assertEquals("check get start time", "", task.getStartTime());

			// Test set start time
			task.setStartTime("14:30");
			assertEquals("check set start time", "14:30", task.getStartTime());

			task.setStartTime("23:59");
			assertEquals("check set start time again", "23:59", task.getStartTime());

			// Test get start date
			assertEquals("check get start date", "", task.getStartDate());

			// Test set start date
			task.setStartDate("2016-04-11");
			assertEquals("check set start date", "2016-04-11", task.getStartDate());

			task.setStartDate("2016-03-15");
			assertEquals("check set start date", "2016-03-15", task.getStartDate());

			task.setUpTaskFile();

			// check deadline flag
			assertTrue("check is deadline flag", task.getIsDeadline());
			assertFalse("check other task flag", task.getIsTask());
			assertFalse("check other meeting flag", task.getIsMeeting());

			// Test get isRecurring, default is false
			assertFalse("check get is recurring flag", task.getIsRecurring());

			// Test set isRecurring
			task.setIsRecurr(true);
			assertTrue("check set is recurring flag", task.getIsRecurring());

			// check startCal
			SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm");
			Date startCalDate = dateFormat.parse("2016-03-15 23:59");
			Calendar testCal = Calendar.getInstance();
			testCal.setTime(startCalDate);

			assertEquals("check start cal", testCal, task.getStartCal());

			// Test defaults for time
			TaskFile task2 = new TaskFile();
			task2.setName("taskWithoutTime");
			task2.setStartDate("2016-04-10");

			task2.setUpTaskFile();

			assertEquals("check default timing given", "23:59", task2.getStartTime());

			// Test defaults for date
			TaskFile task3 = new TaskFile();
			task3.setName("taskWithoutDate");
			task3.setStartTime("01:00");

			task3.setUpTaskFile();

			Date defaultDate = new Date();
			SimpleDateFormat dateOnlyFormat = new SimpleDateFormat("yyyy-MM-dd");
			String defaultDateString = dateOnlyFormat.format(defaultDate);
			assertEquals("check default date set as today", defaultDateString, task3.getStartDate());

		} catch (Exception e) {
			fail("No Exception should be thrown for valid cases");
		}
	}

	@Test
	public void testMeetingEndDateTimeEndCal() {
		try {
			task = new TaskFile("meeting task");

			task.setStartDate("2016-04-12");
			task.setStartTime("11:00");

			// Test get end date
			assertEquals("Check get end date", "", task.getEndDate());

			// Test set end date
			task.setEndDate("2016-04-13");
			assertEquals("Check set end date", "2016-04-13", task.getEndDate());

			task.setEndDate("2016-04-14");
			assertEquals("Check set end date2", "2016-04-14", task.getEndDate());

			// Test get end time
			assertEquals("Check get end time", "", task.getEndTime());

			// Test set end time
			task.setEndTime("12:00");
			assertEquals("Check set end time", "12:00", task.getEndTime());

			task.setEndTime("16:00");
			assertEquals("Check set end time", "16:00", task.getEndTime());

			task.setUpTaskFile();

			// Check meeting flag
			assertTrue("Check get meeting flag", task.getIsMeeting());
			assertFalse("Check other task flag", task.getIsTask());
			assertFalse("Check other deadline flag", task.getIsDeadline());

			// check endCal
			SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm");
			Date endCalDate = dateFormat.parse("2016-04-14 16:00");
			Calendar testCal = Calendar.getInstance();
			testCal.setTime(endCalDate);

			assertEquals("check end cal", testCal, task.getEndCal());

			// Test for default time
			TaskFile task2 = new TaskFile();
			task2.setName("taskWithoutTimings");
			task2.setStartDate("2016-04-11");
			task2.setEndDate("2016-04-12");

			task2.setUpTaskFile();

			assertEquals("check default time for start time", "23:59", task2.getStartTime());
			assertEquals("check default time for end time", "23:59", task2.getEndTime());

			// Test for default date
			TaskFile task3 = new TaskFile();
			task3.setName("taskWithoutDates");
			task3.setStartTime("12:00");
			task3.setEndTime("14:00");

			task3.setUpTaskFile();
			Date defaultDate = new Date();
			SimpleDateFormat dateOnlyFormat = new SimpleDateFormat("yyyy-MM-dd");
			String defaultDateString = dateOnlyFormat.format(defaultDate);

			assertEquals("check default date for start date", defaultDateString, task3.getStartDate());
			assertEquals("check defaultdate for end date", defaultDateString, task3.getEndDate());

		} catch (Exception e) {
			fail("No Exception should be thrown for valid cases");
		}
	}

	@Test
	public void testIncorrectTimeExceptionThrown() {
		try {
			task = new TaskFile();
			task.setName("task with invalid timing");
			task.setStartDate("2016-04-11");
			task.setStartTime("14:00");

			task.setEndDate("2016-04-11");
			task.setEndTime("12:00");

			task.setUpTaskFile();

			fail("Exception should be thrown when the end date time is before the start date time");
		} catch (Exception e) {
			assertEquals("Check exception class thrown", IncorrectTimeException.class, e.getClass());
			assertEquals("Check exception message", "The specified end time 2016-04-11 12:00 is before"
					+ " the start time 2016-04-11 14:00 for task: task with invalid timing", e.getMessage());
		}
	}
	
	@Test
	public void testOverridingMethods() {
		try {
		TaskFile task1 = new TaskFile("call mom", "2016-02-02", "12:00", "abc", false, false);
		TaskFile task2 = new TaskFile("call dad");
		TaskFile task3 = new TaskFile("call bro", "2016-03-02", "11:00", "2016-03-04", "10:00",
				"abc", false, false);
		
		TaskFile task4 = new TaskFile(task1);
		TaskFile task5 = new TaskFile("do homework");
		TaskFile task6 = new TaskFile("catch rat", "2016-02-03", "13:00", "details", false, false);
		TaskFile task7 = new TaskFile("eat lunch with John", "2016-03-04", "11:00", "2016-03-04", "13:00",
				"details", false, false);
		
		//Test equals
		assertTrue("Check TaskFile equals", task1.equals(task4));
		assertFalse("Check TaskFile equals", task1.equals(task3));
		
		
		//Test toString
		String task3String = "Task: call bro, Start Date: 2016-03-02, Start Time: 11:00, End Date: 2016-03-04, "
			+ "End Time: 10:00, Details: abc, Importance: false, IsRecurring: false, IsDone: false";
		assertEquals("Check TaskFileToString", task3String, task3.toString());
		
		
		//Test clone
		TaskFile taskClone = (TaskFile)task5.clone();
		assertTrue("Check clone", task5.equals(taskClone));
		
		//Test compareTo using collection sort
		ArrayList<TaskFile> listOfTaskFilesToSort = new ArrayList<TaskFile>();
		listOfTaskFilesToSort.add(task1);
		listOfTaskFilesToSort.add(task2);
		listOfTaskFilesToSort.add(task3);
		listOfTaskFilesToSort.add(task4);
		listOfTaskFilesToSort.add(task5);
		listOfTaskFilesToSort.add(task6);
		listOfTaskFilesToSort.add(task7);
		
		Collections.sort(listOfTaskFilesToSort);
		
		ArrayList<TaskFile> sortedList = new ArrayList<TaskFile>();
		sortedList.add(task2);
		sortedList.add(task5);
		sortedList.add(task4);
		sortedList.add(task1);
		sortedList.add(task6);
		sortedList.add(task3);
		sortedList.add(task7);
		
		assertEquals("Check collection sort with TaskFile compare to", sortedList, listOfTaskFilesToSort);
		
		
		ArrayList<TaskFile> sortedByName = new ArrayList<TaskFile>();
		sortedByName.add(task3);
		sortedByName.add(task2);
		sortedByName.add(task4);
		sortedByName.add(task1);
		sortedByName.add(task6);
		sortedByName.add(task5);
		sortedByName.add(task7);
		
		Collections.sort(listOfTaskFilesToSort, new NameComparator());
		
		assertEquals("Check collection sort with Name Comparator", sortedByName, listOfTaskFilesToSort);
		
		
		} catch (Exception e) {
			fail("Exception should not be thrown for valid cases");
		}
	}
}
```
###### \src\tnote\storage\DirectoryHandler.java
``` java
package tnote.storage;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import java.io.File;
import java.io.IOException;
import java.nio.file.DirectoryNotEmptyException;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.util.logging.Logger;

/**
 * This class manages the directory paths and files in the system.
 * 
 * Directories and files can be created or deleted. The files in one directory
 * can be copied to another directory as well.
 * 
 * @author A0124131B
 *
 */
public class DirectoryHandler {

	private static final String MESSAGE_DELETE_PARENT_DIR = "Deleting parent directory: ";
	private static final String MESSAGE_CLASS_CREATED = "DirectoryHandler created";
	private static final String MESSAGE_NEW_PARENT_DIRECTORY = "New parent directory: %s";
	private static final String MESSAGE_FILES_FOLDER_DELETE = "All files and folders in %s deleted";
	private static final String MESSAGE_DIRECTORY_DELETED = "Directory: %s successfully deleted";
	private static final String MESSAGE_FILE_DELETED = "%s file deleted";
	private static final String MESSAGE_FILE_EXISTS = "%s file exists";
	private static final String MESSAGE_DIRECTORY_EXISTS = "%s directory exists";
	private static final String MESSAGE_FILE_PATH = "File path: %s";
	private static final String MESSAGE_PARENT_PATH_GET = "%s parent path retrieved";

	private static final String ERROR_FILE_NOT_EXIST = "%s file does not exist";
	private static final String ERROR_CREATE_FILE = "Error creating %s";
	private static final String ERROR_COPYING_DIREC = "Error copying to %s";
	private static final String ERROR_CHANGING_NEW_DIRECTORY = "Error changing to new directory: %s";
	private static final String ERROR_CREATE_DIREC = "Could not create directory %s";
	private static final String ERROR_DELETE_FILE = "Error deleting %s";
	private static final String ERROR_DELETE_FAILED = "Failed to delete %s";
	private static final String ERROR_DIRECTORY_NOT_DELETED = "Directory: %s was not deleted";

	private static final String DEFAULT_FOLDER = "\\TNote";

	private static final Logger logger = Logger.getGlobal();

	private static DirectoryHandler instance;

	private Path parentPath;
	private File parentDirectory;

	/**
	 * Constructor for Directory Handler. Sets a parent path using the default
	 * directory
	 */
	private DirectoryHandler() {
		parentPath = FileSystems.getDefault().getPath(DEFAULT_FOLDER);
		this.parentDirectory = parentPath.toFile();
		logger.info(MESSAGE_CLASS_CREATED);
	}

	/**
	 * Method to get an instance of DirectoryHandler. If no instance exists, a
	 * new instance is created
	 * 
	 * @return DirectoryHandler the instance of DirectoryHandler
	 */
	protected static DirectoryHandler getInstance() {
		if (instance == null) {
			instance = new DirectoryHandler();
		}
		return instance;
	}

	/**
	 * Method to retrieve the parent directory file or path
	 * 
	 * @return File the object which points to the parent directory
	 */
	protected File getParentDirectory() {
		logger.info(String.format(MESSAGE_PARENT_PATH_GET, parentDirectory.getAbsolutePath()));
		return parentDirectory;
	}

	/*----------------------Create Files and Directories--------------------*/
	/**
	 * Method which creates a specified directory in the system
	 * 
	 * @param directory
	 *            File object containing the path to the directory to be created
	 * @return true if the directory is successfully created or if the directory
	 *         already exists
	 */
	protected boolean createDirectory(File directory) {
		assertNotNull(directory);

		if (!directory.exists()) {
			return directory.mkdirs();
		}

		logger.info(String.format(MESSAGE_DIRECTORY_EXISTS, directory.getAbsolutePath()));
		return true;
	}

	/**
	 * Method which creates a specified file in the system
	 * 
	 * @param fileToCreate
	 *            File object containing the path to the file to be created
	 * @return true if the file is successfully created, or if the file already
	 *         exists
	 * @throws IOException
	 *             Error when creating the file
	 */
	protected boolean createFile(File fileToCreate) throws IOException {
		try {
			assertNotNull(fileToCreate);

			if (!fileToCreate.exists()) {
				return fileToCreate.createNewFile();
			}

			logger.info(String.format(MESSAGE_FILE_EXISTS, fileToCreate.getAbsolutePath()));
			return true;

		} catch (IOException ioEx) {
			String errorMessage = String.format(ERROR_CREATE_FILE, fileToCreate.getAbsolutePath());

			logger.warning(errorMessage);
			throw new IOException(errorMessage, ioEx);
		}
	}

	/*--------------------------Delete files or directories-----------------------*/

	/**
	 * Method to delete the parent directory and all files within it
	 * @return true if parent directory is deleted.
	 * @throws IOException Error deleting parent directory
	 */
	protected boolean deleteMasterDirectory() throws IOException {
		logger.info(String.format(MESSAGE_DELETE_PARENT_DIR, parentDirectory.getAbsolutePath()));
		return deleteDirectory(parentDirectory);
	}

	/**
	 * Method to delete a child directory along with all files within it
	 * 
	 * @param directory
	 *            String of the child directory to delete
	 * @return true if the directory and all its files have been deleted
	 * @throws IOException
	 *             Error deleting the directory or any files within it
	 */
	protected boolean deleteChildDirectory(String directory) throws IOException {
		File directoryFile = appendParentDirectory(directory);
		return deleteDirectory(directoryFile);
	}

	/**
	 * Method to delete a directory and all files within it
	 * 
	 * @param directoryFile
	 *            File object containing the path to the directory to delete
	 * @return true if the directory and its files are successfully deleted
	 * @throws IOException
	 *             Error when deleting a file
	 */
	private boolean deleteDirectory(File directoryFile) throws IOException {
		if (deleteAllFilesAndFolders(directoryFile) && deleteFile(directoryFile)) {
			logger.info(String.format(MESSAGE_DIRECTORY_DELETED, directoryFile.getAbsolutePath()));
			return true;
		} else {
			logger.warning(String.format(ERROR_DIRECTORY_NOT_DELETED, directoryFile.getAbsolutePath()));
			return false;
		}
	}

	/**
	 * Method to delete all files within a specified child directory
	 * 
	 * @param directory
	 *            String of the child directory to clear
	 * @return true if all files within the directory has been deleted
	 * @throws IOException
	 *             Error deleting any files within the directory
	 */
	protected boolean clearChildDirectory(String directory) throws IOException {
		File directoryFile = appendParentDirectory(directory);
		assertTrue(directoryFile.isDirectory());
		return deleteAllFilesAndFolders(directoryFile);
	}

	/**
	 * Method recursively deletes a specified file, along with any files and
	 * folders within it
	 * 
	 * @param parentFile
	 *            File object containing the path of the file to delete
	 * @return true if deletion is successful
	 * @throws IOException
	 *             Error deleting any files or folders
	 */
	private boolean deleteAllFilesAndFolders(File parentFile) throws IOException {
		for (File file : parentFile.listFiles()) {
			if (file.isDirectory()) {
				if (!deleteAllFilesAndFolders(file)) {
					// If any file or folder cannot be deleted, return false.
					return false;
				}
				
				int numFilesInDirec = file.listFiles().length;
				assertEquals(0, numFilesInDirec);
			}

			if (!deleteFile(file)) {
				logger.warning(String.format(ERROR_DELETE_FAILED, file.getAbsolutePath()));
				return false;
			}
		}

		logger.info(String.format(MESSAGE_FILES_FOLDER_DELETE, parentFile.getAbsolutePath()));
		return true;
	}

	/**
	 * Method to delete a specified file from the system
	 * 
	 * @param fileToDelete
	 *            File object containing the path to the file to be deleted
	 * @return true if the file is successfully deleted
	 * @throws IOException
	 *             Error when deleting the file
	 */
	protected boolean deleteFile(File fileToDelete) throws IOException {
		try {
			Path pathToFile = fileToDelete.toPath();
			
			if (Files.deleteIfExists(pathToFile)) {
				logger.info(String.format(MESSAGE_FILE_DELETED, fileToDelete.getAbsolutePath()));
				return true;

			} else {
				assertFalse(fileToDelete.exists());
				logger.warning(String.format(ERROR_FILE_NOT_EXIST, fileToDelete.getAbsolutePath()));
				return false;
			}
			
		} catch (IOException ioEx) {
			String errorMessage = String.format(ERROR_DELETE_FILE, fileToDelete.getAbsolutePath());

			logger.warning(errorMessage);
			throw new IOException(errorMessage, ioEx);
		}
	}

	/*-------------------------Copying To New Directory------------------------------*/

	/**
	 * Method which sets a new parent directory, copying all files over to the
	 * new directory
	 * 
	 * @param newDirectoryString
	 *            String of the new directory
	 * @return true if the directory has been successfully changed
	 * @throws IOException
	 *             Error creating the directory, or error copying the files over
	 *             to the new directory
	 */
	protected boolean setNewDirectory(String newDirectoryString) throws IOException {
		File newDirectory = getNewDirectoryFile(newDirectoryString);

		if (!createDirectory(newDirectory)) {
			String errorMessage = String.format(ERROR_CREATE_DIREC, newDirectory.getAbsolutePath());

			logger.warning(errorMessage);
			throw new IOException(errorMessage);
		}
		
		if (copyFilesIntoNewDirectory(newDirectory, parentDirectory) && deleteMasterDirectory()) {
			parentDirectory = newDirectory;

			logger.info(String.format(MESSAGE_NEW_PARENT_DIRECTORY, parentDirectory.getAbsolutePath()));
			return true;
			
		} else {
			deleteDirectory(newDirectory);

			logger.warning(String.format(ERROR_CHANGING_NEW_DIRECTORY, newDirectory.getAbsolutePath()));
			return false;
		}
	}

	/**
	 * Method which recursively copies the files in one folder to another folder
	 * 
	 * @param newDirectory
	 *            New directory to copy files into
	 * @param oldDirectory
	 *            Old directory containing all the files
	 * @return true if all files have been successfully copied
	 * @throws DirectoryNotEmptyException
	 *             The new directory specified is not an empty directory
	 * @throws IOException
	 *             Error when copying files from the old directory to the new
	 *             directory
	 */
	private boolean copyFilesIntoNewDirectory(File newDirectory, File oldDirectory) throws IOException {
		try {
			for (File oldFile : oldDirectory.listFiles()) {
				File newFile = new File(newDirectory, oldFile.getName());

				if (oldFile.isDirectory()) {
					createDirectory(newFile);
					copyFilesIntoNewDirectory(newFile, oldFile);
				} else {
					Files.copy(oldFile.toPath(), newFile.toPath(), StandardCopyOption.REPLACE_EXISTING);
				}
			}

			logger.info(String.format("files copied from %s to %s", oldDirectory.getAbsolutePath(),
					newDirectory.getAbsolutePath()));
			return true;

		} catch (IOException ioEx) {
			String errorMessage = String.format(ERROR_COPYING_DIREC, newDirectory.getAbsolutePath());

			logger.warning(errorMessage);
			throw new IOException(errorMessage, ioEx);
		}
	}

	/*---------------------Appending Directories----------------------------------*/

	/**
	 * Method which add the parent directory as a root directory of the
	 * specified file name
	 * 
	 * @param fileName
	 *            the name of the file to exist inside the parent directory
	 * @return File the object which contains the full directory path to
	 *         the specified file name
	 */
	protected File appendParentDirectory(String fileName) {
		File fileWithParentDirectory = new File(parentDirectory, fileName);
		logger.info(String.format(MESSAGE_FILE_PATH, fileWithParentDirectory.getAbsolutePath()));
		return fileWithParentDirectory;
	}

	/**
	 * Method which adds a specified folder File as a root directory of the
	 * specified file name
	 * 
	 * @param folder
	 *            File object used as the root directory
	 * @param fileName
	 *            Name of the file to exist inside the specified folder
	 * @return File the object which contains the full directory path to
	 *         the specified file name
	 */
	protected File addDirectoryToFile(File folder, String fileName) {
		File fileWithFolder = new File(folder, fileName);
		logger.info(String.format(MESSAGE_FILE_PATH, fileWithFolder.getAbsolutePath()));
		return fileWithFolder;
	}

	/**
	 * Method which creates a File object of a specified directory String
	 * 
	 * @param newDirectoryString
	 *            the name of the new directory File object
	 * @return File the object which points to the new directory specified
	 */
	private File getNewDirectoryFile(String newDirectoryString) {
		File newParentDirectory = new File(newDirectoryString);
		logger.info(String.format(MESSAGE_FILE_PATH, newParentDirectory.getAbsolutePath()));
		return newParentDirectory;
	}
}
```
###### \src\tnote\storage\DirectoryHandlerTest.java
``` java
package tnote.storage;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;

import java.io.File;
import java.io.IOException;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.Test;

public class DirectoryHandlerTest {

	TNotesStorage storage;
	DirectoryHandler dirHandler;

	@AfterClass
	public static void tearDownAfterClass() throws Exception {
		TNotesStorage storage = TNotesStorage.getInstance();
		System.out.println(storage.deleteMasterDirectory());
	}

	@Before
	public void setUp() throws Exception {
		storage = TNotesStorage.getInstance();
		storage.setUpStorage();
		storage.clearFiles();
		dirHandler = DirectoryHandler.getInstance();
	}

	@After
	public void tearDown() throws Exception {
		System.out.println(storage.clearFiles());
	}

	@Test
	public void testAddAndDeleteChildDirectories() {
		try {
			// Test getParentDirectory
			File testParent = new File("C:\\TNote");
			assertEquals("check get parent directory", testParent.getAbsolutePath(),
					dirHandler.getParentDirectory().getAbsolutePath());

			// Test appendParentDirectory
			String testFolderName = "testFolder";
			File testFolder = new File("C:\\TNote\\testFolder");
			assertEquals("check append parent", testFolder.getAbsolutePath(),
					dirHandler.appendParentDirectory(testFolderName).getAbsolutePath());

			// Test createDirectory
			assertFalse("directory has not been created", testFolder.exists());
			assertTrue("create directory", dirHandler.createDirectory(testFolder));
			assertTrue("directory now created", testFolder.exists());

			// repeat create should still return true
			assertTrue("repeat create directory", dirHandler.createDirectory(testFolder));

			// Test addDirectoryToFile
			String testChildName = "testChild.txt";
			File testChild = new File("C:\\TNote\\testFolder\\testChild.txt");
			assertEquals("check add directory", testChild.getAbsolutePath(),
					dirHandler.addDirectoryToFile(testFolder, testChildName).getAbsolutePath());

			// Test createFile
			assertFalse("file not created", testChild.exists());
			assertTrue("create file", dirHandler.createFile(testChild));
			assertTrue("file now created", testChild.exists());

			// repeat create should still return true
			assertTrue("repeat create file", dirHandler.createFile(testChild));

			File testChild2 = new File("C:\\TNote\\testFolder\\testChild2.txt");
			File testChild3 = new File("C:\\TNote\\testFolder\\testChild3.txt");
			dirHandler.createFile(testChild2);
			dirHandler.createFile(testChild3);

			// Test delete file
			assertTrue("delete file", dirHandler.deleteFile(testChild));
			assertFalse("file no longer exists", testChild.exists());

			// repeated delete should return false
			assertFalse("repeated delete file", dirHandler.deleteFile(testChild));

			// Test clear child directory
			// check directory not empty
			int numberOfFilesInTest = testFolder.listFiles().length;
			assertNotEquals(0, numberOfFilesInTest);
			assertTrue("clear child directory", dirHandler.clearChildDirectory(testFolderName));
			numberOfFilesInTest = testFolder.listFiles().length;
			assertEquals(0, numberOfFilesInTest);

			dirHandler.createFile(testChild);
			dirHandler.createFile(testChild2);
			dirHandler.createFile(testChild3);

			// Test delete child directory
			assertTrue("delete child directory", dirHandler.deleteChildDirectory(testFolderName));
			assertFalse("directory deleted", testFolder.exists());
			assertFalse("Files in directories deleted as well", testChild2.exists());

			dirHandler.createDirectory(testFolder);
			dirHandler.createFile(testChild);
			dirHandler.createFile(testChild2);
			dirHandler.createFile(testChild3);

		} catch (Exception e) {
			fail("No exceptions should be thrown for valid cases");
		}
	}

	@Test
	public void testChangeAndDeleteMasterDirectory() {
		try {
		// Test change directory
		
		String testFolderName = "testFolder";
		File testFolder = new File("C:\\TNote\\testFolder");
		String testChildName = "testChild.txt";
		File testChild = new File("C:\\TNote\\testFolder\\testChild.txt");
		File testChild2 = new File("C:\\TNote\\testFolder\\testChild2.txt");
		
		dirHandler.createDirectory(testFolder);
		dirHandler.createFile(testChild);
		dirHandler.createFile(testChild2);
		
		
		File defaultOverview = new File("C:\\TNote\\overview");
		assertTrue("default folders exists", defaultOverview.exists());

		String newDirString = "C:\\TNoteTest";
		assertTrue("change directories", dirHandler.setNewDirectory(newDirString));
		assertFalse("directory moved", testFolder.exists());
		assertFalse("Files in directories moved as well", testChild.exists());
		assertFalse("default folders moved", defaultOverview.exists());

		testFolder = dirHandler.appendParentDirectory(testFolderName);
		testChild = dirHandler.addDirectoryToFile(testFolder, testChildName);
		defaultOverview = new File("C:/TNoteTest/overview");

		assertEquals("new folder path", "C:\\TNoteTest\\testFolder", testFolder.getAbsolutePath());
		assertEquals("new file path", "C:\\TNoteTest\\testFolder\\testChild.txt", testChild.getAbsolutePath());
		assertEquals("new directory path", newDirString, dirHandler.getParentDirectory().getAbsolutePath());
		assertTrue("new directory default folder", defaultOverview.exists());

		// Test delete Master directory
		assertTrue("delete master directory", dirHandler.deleteMasterDirectory());
		assertFalse("directory deleted", testFolder.exists());
		assertFalse("Files in directories deleted as well", testChild.exists());
		assertFalse("default folders deleted", defaultOverview.exists());

		MasterFileHandler mFHandler = MasterFileHandler.getInstance();
		mFHandler.setUpStorage();
		
		dirHandler.setNewDirectory("C:\\TNote");
		} catch (Exception e) {
			fail("No exceptions shuld be thrown for valid cases");
		}
	}
	
	@Test
	public void testIOExceptionFromChangeDir() {
		try {
			File existingFolder = new File("C:\\Windows");
			assertTrue(existingFolder.exists());
			dirHandler.setNewDirectory("C:\\Windows");
			
			fail("Exception should be thrown when copying into system folders");
		} catch (Exception e) {
			assertEquals("Check exception class",IOException.class, e.getClass());
			assertEquals("Check exception message", "Error copying to C:\\Windows", e.getMessage());
		}
		
	}

}
```
###### \src\tnote\storage\FileReadHandler.java
``` java
package tnote.storage;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Logger;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;

import tnote.object.TaskFile;

/**
 * This class handles reading of any files within the system.
 * 
 * Files are text files containing strings
 * 
 * Strings will be read using a Reader object, while objects will be serialized
 * using Gson
 * 
 * @author A0124131B
 *
 */
public class FileReadHandler {
	private static final String MESSAGE_FILE_SUCCESSFULLY_READ = "Successfully read from %s";
	private static final String MESSAGE_CLASS_CREATED = "FileReadHandler created";
	
	private static final String ERROR_FILE_DOES_NOT_EXIST = "%s does not exist";
	private static final String ERROR_READING_FILE = "Error reading %s";

	private static final Logger logger = Logger.getGlobal();
	
	private static FileReadHandler instance;

	private FileReader fReader;
	private BufferedReader bReader;
	private Gson gsonHelper;

	/**
	 * Constructor for FileReadHandler. Initializes the Gson object.
	 */
	private FileReadHandler() {
		gsonHelper = new Gson();
		logger.info(MESSAGE_CLASS_CREATED);
	}

	/**
	 * Gets an instance of FileReadHandler. If instance does not exist, a new
	 * instance is created
	 * 
	 * @return FileReadHandler the instance of FileReadHandler
	 */
	protected static FileReadHandler getInstance() {
		if (instance == null) {
			instance = new FileReadHandler();
		}
		return instance;
	}

	/**
	 * Method which reads from a text file which contains a list of Strings.
	 * 
	 * @param textFileToRead
	 *            the text file to read from
	 * @return ArrayList{@code<String>} the list which is read from the text file.
	 * @throws IOException
	 *             Error reading from the text file.
	 * @throws FileNotFoundException
	 *             the specified file does not exist.
	 */
	protected ArrayList<String> readListFile(File textFileToRead) throws IOException {
		try {
			fReader = new FileReader(textFileToRead);
			bReader = new BufferedReader(fReader);
			ArrayList<String> listOfNames = new ArrayList<String>();

			if (bReader.ready()) {
				String stringInFile = bReader.readLine();
				while (stringInFile != null) {
					listOfNames.add(stringInFile);
					stringInFile = bReader.readLine();
				}
			}

			bReader.close();

			logger.info(String.format(MESSAGE_FILE_SUCCESSFULLY_READ, textFileToRead.getAbsolutePath()));
			return listOfNames;
			
		} catch (FileNotFoundException fileNotFoundEx) {
			String errorMessage = String.format(ERROR_FILE_DOES_NOT_EXIST,
									textFileToRead.getAbsolutePath());

			logger.warning(errorMessage);
			throw new FileNotFoundException(errorMessage);
			
		} catch (IOException ioEx) {
			String errorMessage = String.format(ERROR_READING_FILE, textFileToRead.getAbsolutePath());

			logger.warning(errorMessage);
			throw new IOException(errorMessage, ioEx);
		}
	}

	/**
	 * Method which reads from a text file which contains a json String of a
	 * Map{@code<String, String>}.
	 * 
	 * @param textFileToRead
	 *            the text file to read from.
	 * @return Map{@code<String, String>} the map which is read from the text file.
	 * @throws IOException
	 *             Error reading from the text file.
	 * @throws FileNotFoundException
	 *             the file specified does not exist.
	 */
	protected Map<String, String> readFolderMapFile(File textFileToRead) throws IOException {
		try {
			fReader = new FileReader(textFileToRead);
			bReader = new BufferedReader(fReader);
			Map<String, String> mapFromFile = new HashMap<String, String>();

			if (bReader.ready()) {
				String mapString = bReader.readLine();

				if (mapString != null) {
					Type typeOfMap = new TypeToken<Map<String, String>>() {
					}.getType();
					mapFromFile = gsonHelper.fromJson(mapString, typeOfMap);
				}
			}

			bReader.close();
			fReader.close();

			logger.info(String.format(MESSAGE_FILE_SUCCESSFULLY_READ, textFileToRead.getAbsolutePath()));
			return mapFromFile;

		} catch (FileNotFoundException fileNotFoundEx) {
			String errorMessage = String.format(ERROR_FILE_DOES_NOT_EXIST,
									textFileToRead.getAbsolutePath());

			logger.warning(errorMessage);
			throw new FileNotFoundException(errorMessage);
			
		} catch (IOException ioEx) {
			String errorMessage = String.format(ERROR_READING_FILE, textFileToRead.getAbsolutePath());

			logger.warning(errorMessage);
			throw new IOException(errorMessage, ioEx);
		}
	}

	/**
	 * Method which reads from a text file containing a json String of a
	 * Map{@code<String, ArrayList<String>>}.
	 * 
	 * @param textFileToRead
	 *            the file to be read.
	 * @return Map{@code<String,ArrayList<String>>} the map which is read from the
	 *         file.
	 * @throws IOException
	 *             Error reading from the text file.
	 * @throws FileNotFoundException
	 *             the file specified does not exist.
	 */
	protected Map<String, ArrayList<String>> readDateMapFile(File textFileToRead) throws IOException {
		try {
			fReader = new FileReader(textFileToRead);
			bReader = new BufferedReader(fReader);
			Map<String, ArrayList<String>> mapFromFile = new HashMap<String, ArrayList<String>>();

			if (bReader.ready()) {
				String mapString = bReader.readLine();

				if (mapString != null) {
					Type typeOfMap = new TypeToken<Map<String, ArrayList<String>>>() {
					}.getType();
					mapFromFile = gsonHelper.fromJson(mapString, typeOfMap);
				}
			}

			bReader.close();
			fReader.close();

			logger.info(String.format(MESSAGE_FILE_SUCCESSFULLY_READ, textFileToRead.getAbsolutePath()));
			return mapFromFile;

		} catch (FileNotFoundException fileNotFoundEx) {
			String errorMessage = String.format(ERROR_FILE_DOES_NOT_EXIST, 
									textFileToRead.getAbsolutePath());

			logger.warning(errorMessage);
			throw new FileNotFoundException(errorMessage);
			
		} catch (IOException ioEx) {
			String errorMessage = String.format(ERROR_READING_FILE, textFileToRead.getAbsolutePath());

			logger.warning(errorMessage);
			throw new IOException(errorMessage, ioEx);
		}
	}

	/**
	 * Method to read from a text file containing a json String of a TaskFile
	 * object.
	 * 
	 * @param textFileToRead
	 *            the file to be read.
	 * @return TaskFile the TaskFile object read from the file.
	 * @throws IOException
	 *             Error reading from the text file.
	 * @throws FileNotFoundException
	 *             the file specified does not exist.
	 */
	protected TaskFile readTaskTextFile(File textFileToRead) throws IOException {
		try {
			fReader = new FileReader(textFileToRead);
			bReader = new BufferedReader(fReader);
			TaskFile extractedTask = new TaskFile();

			if (bReader.ready()) {
				String taskFileString = bReader.readLine();
				
				if (taskFileString != null) {
					extractedTask = gsonHelper.fromJson(taskFileString, TaskFile.class);
				}
			}
			
			bReader.close();
			fReader.close();
			
			logger.info(String.format(MESSAGE_FILE_SUCCESSFULLY_READ, textFileToRead.getAbsolutePath()));
			return extractedTask;
			
		} catch (FileNotFoundException fileNoFoundEx) {
			String errorMessage = String.format(ERROR_FILE_DOES_NOT_EXIST, 
									textFileToRead.getAbsolutePath());

			logger.warning(errorMessage);
			throw new FileNotFoundException(errorMessage);
			
		} catch (IOException ioEx) {
			String errorMessage = String.format(ERROR_READING_FILE, textFileToRead.getAbsolutePath());

			logger.warning(errorMessage);
			throw new IOException(errorMessage, ioEx);
		}
	}
}
```
###### \src\tnote\storage\FileReadHandlerTest.java
``` java
package tnote.storage;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.Test;

import tnote.object.TaskFile;

public class FileReadHandlerTest {
	TNotesStorage storage;
	FileReadHandler fRHandler;
	FileWriteHandler fWHandler;

	@AfterClass
	public static void tearDownAfterClass() throws Exception {
		TNotesStorage storage = TNotesStorage.getInstance();
		System.out.println(storage.deleteMasterDirectory());
	}

	@Before
	public void setUp() throws Exception {
		storage = TNotesStorage.getInstance();
		fRHandler = FileReadHandler.getInstance();
		fWHandler = FileWriteHandler.getInstance();
		storage.setUpStorage();
		storage.clearFiles();

	}

	@After
	public void tearDown() throws Exception {
		System.out.println(storage.clearFiles());
	}

	@Test
	public void testReadListFile() {
		File testListFile = new File("C:/TNote/overview/masterfile.txt");

		ArrayList<String> testList = new ArrayList<String>();

		testList.add("testString1");
		testList.add("testString2");

		try {
			fWHandler.writeToListFile(testListFile, testList);
			
			//Test valid read from list file
			assertEquals("Read from list file", testList, fRHandler.readListFile(testListFile));
			
		} catch (Exception e) {
			fail("No exception should be thrown for a valid read list");
		}
		
		//Test FileNotFoundException from readListFile
		try {
			File nonExistingFile = new File("C:/TNote/overview/nonexistent");
			fRHandler.readListFile(nonExistingFile);

			fail("Exception should be thrown when reading a list from a non existent file");

		} catch (Exception e) {
			assertEquals("Check exception class", FileNotFoundException.class, e.getClass());
			assertEquals("Check exception message", "C:\\TNote\\overview\\nonexistent does not exist", e.getMessage());
		}
	}

	@Test
	public void testReadFolderMap() {
		File testFolderFile = new File("C:/TNote/overview/filetofoldermapping.txt");

		Map<String, String> testMap = new HashMap<String, String>();
		testMap.put("testName1", "testFolder1");
		testMap.put("testName2", "testFolder2");

		try {
			fWHandler.writeToMonthMapFile(testFolderFile, testMap);
			
			//Test valid read from folder map
			assertEquals("Read from folder map file", testMap, fRHandler.readFolderMapFile(testFolderFile));
			
		} catch (Exception e) {
			fail("Exception should not be thrown for a valid read month map");
		}

		
		//Test FileNotFoundException from readFolderMapFile
		try {
			File nonExistingFile = new File("C:/TNote/overview/nonexistent");
			fRHandler.readFolderMapFile(nonExistingFile);
			
			fail("Exception should be thrown when reading a month map from a non existent file");
			
		} catch (Exception e) {
			assertEquals("Check exception class", FileNotFoundException.class, e.getClass());
			assertEquals("Check exceptio message", "C:\\TNote\\overview\\nonexistent does not exist", e.getMessage());
		}
	}

	@Test
	public void testReadDateMap() {
		File testDateFile = new File("C:/TNote/overview/recurringTaskStartDates.txt");

		Map<String, ArrayList<String>> testDateMap = new HashMap<String, ArrayList<String>>();

		ArrayList<String> testDates1 = new ArrayList<String>();
		testDates1.add("12-12-2015");
		testDates1.add("13-12-2016");

		ArrayList<String> testDates2 = new ArrayList<String>();
		testDates2.add("15-12-2015");
		testDates2.add("16-12-2016");

		testDateMap.put("recurTest1", testDates1);
		testDateMap.put("recurTest2", testDates2);

		try {
			fWHandler.writeToRecurMapFile(testDateFile, testDateMap);
			
			//Test valid read from recur date file
			assertEquals("Read from recur date file", testDateMap, fRHandler.readDateMapFile(testDateFile));
			
		} catch (Exception e) {
			fail("Exception should not be thrown for a valid read recur date map file");
		}

		//Test FileNotFoundException from readDateMapFile
		try {
			File nonExistingFile = new File("C:/TNote/overview/nonexistent");
			fRHandler.readDateMapFile(nonExistingFile);
			
			fail("Exception should be thrown when reading a date map from a non existent file");
			
		} catch (Exception e) {
			assertEquals("Check exception class", FileNotFoundException.class, e.getClass());
			assertEquals("Check exception message", "C:\\TNote\\overview\\nonexistent does not exist", e.getMessage());
		}
	}

	@Test
	public void testReadTaskFile() {
		File testTaskTextFile = new File("C:/TNote/overview/testTask.txt");
		try {

			TaskFile testTask = new TaskFile("test", "2016-4-10", "13:00", "2016-4-11", "11:00",
					"testDetails", true, false);
			fWHandler.writeTaskToTextFile(testTaskTextFile, testTask);

			//Test valid read from Task text file
			assertEquals("Read from Task Text File", testTask, fRHandler.readTaskTextFile(testTaskTextFile));
			
		} catch (Exception e) {
			fail("Exception should not be thrown on a valid read task file");
		}
		
		//Test FileNotFoundException from readTaskTextFile
		try {
			File nonExistingFile = new File("C:/TNote/overview/nonexistent");
			fRHandler.readTaskTextFile(nonExistingFile);
			
			fail("Exception should be thrown when reading a task file from a non existent file");
			
		} catch (Exception e) {
			assertEquals("Check exception class", FileNotFoundException.class, e.getClass());
			assertEquals("Check exception message", "C:\\TNote\\overview\\nonexistent does not exist", e.getMessage());
		}

	}
}
```
###### \src\tnote\storage\FileWriteHandler.java
``` java
package tnote.storage;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Map;
import java.util.logging.Logger;

import com.google.gson.Gson;

import tnote.object.TaskFile;

/**
 * This class provides methods to write to files within the system.
 * 
 * Only Strings are written to files. Objects are deserialized into json Strings
 * to be written into files.
 * 
 * @author A0124131B
 *
 */
public class FileWriteHandler {

	private static final String MESSAGE_NAME_APPENDED_SUCCESSFULLY = "%s appended to %s";
	private static final String MESSAGE_TASK_SAVED_SUCCESSFULLY = "%s is saved in text file %s";
	private static final String MESSAGE_FILE_UPDATED = "%s successfully updated";
	private static final String MESSAGE_FILE_CLEARED = "%s clear successfully";
	private static final String MESSAGE_CLASS_CREATED = "WriteHandler created";
	
	private static final String ERROR_CLEARING_FILE = "There is an error clearing the file %s";
	private static final String ERROR_WRITING_TO_FILE = "There is an error writing to %s";
	private static final String ERROR_SAVING_TASK = "There is an error saving %s as a text file";
	private static final String ERROR_SAVING_NAME_TO_FILE = "There is an error saving %s to %s";
	private static final String STRING_TO_CLEAR_FILES = "";

	private static final Logger logger = Logger.getGlobal();

	private static FileWriteHandler instance;

	private FileWriter fWriter;
	private BufferedWriter bWriter;
	private Gson gsonHelper;

	/**
	 * Constructor for FileWriteHandler. Initializes the Gson Object.
	 */
	private FileWriteHandler() {
		gsonHelper = new Gson();
		logger.info(MESSAGE_CLASS_CREATED);
	}

	/**
	 * Gets the instance of FileWriteHandler. If instance does not exist, a new
	 * instance is created.
	 * 
	 * @return FileWriteHandler the instance of FileWriteHandler.
	 */
	protected static FileWriteHandler getInstance() {
		if (instance == null) {
			instance = new FileWriteHandler();
		}
		return instance;
	}

	/**
	 * Method which appends a String to the end of a list in a specified text
	 * file.
	 * 
	 * @param textFile
	 *            text file containing the list.
	 * @param taskName
	 *            String to append to the list.
	 * @return true if the String is successfully appended to the text file.
	 * @throws IOException
	 *             Error writing to the file because the file is a directory, or
	 *             the file cannot be opened, or the file does not exist and
	 *             cannot be created.
	 */
	protected boolean writeNameToListFile(File textFile, String taskName) throws IOException {
		try {
			fWriter = new FileWriter(textFile, true);
			bWriter = new BufferedWriter(fWriter);

			bWriter.append(taskName);
			bWriter.newLine();

			bWriter.close();
			fWriter.close();

			logger.info(String.format(MESSAGE_NAME_APPENDED_SUCCESSFULLY, taskName,
						textFile.getAbsolutePath()));
			return true;

		} catch (IOException ioEx) {
			String errorMessage = String.format(ERROR_SAVING_NAME_TO_FILE, taskName,
									textFile.getAbsolutePath());

			logger.warning(errorMessage);
			throw new IOException(errorMessage, ioEx);
		}
	}

	/**
	 * Method which converts a TaskFile object into a json String and saves it
	 * into a text file.
	 * 
	 * @param textFile
	 *            the text file to open and write the json String to.
	 * @param task
	 *            the TaskFile object to write to the text file.
	 * @return true if the TaskFile object is successfully written into the text
	 *         file.
	 * @throws IOException
	 *             Error writing to the file because the file is a directory, or
	 *             the file cannot be opened, or the file does not exist and
	 *             cannot be created.
	 */
	protected boolean writeTaskToTextFile(File textFile, TaskFile task) throws IOException {
		try {
			fWriter = new FileWriter(textFile);
			bWriter = new BufferedWriter(fWriter);

			String taskFileString = gsonHelper.toJson(task);
			bWriter.write(taskFileString);
			
			bWriter.close();
			fWriter.close();

			logger.info(String.format(MESSAGE_TASK_SAVED_SUCCESSFULLY, task.getName(), 
						textFile.getAbsolutePath()));
			return true;
			
		} catch (IOException ioEx) {
			String errorMessage = String.format(ERROR_SAVING_TASK, task.getName());

			logger.warning(errorMessage);
			throw new IOException(errorMessage, ioEx);
		}
	}

	/**
	 * Method which converts a Map{@code<String, String>} into a json String and saves
	 * it into a text file.
	 * 
	 * @param textFile
	 *            the text file to open and write the json String to.
	 * @param map
	 *            the Map object to be written to the text file.
	 * @return true if the Map object is successfully written to the text file.
	 * @throws IOException
	 *             Error writing to the file because the file is a directory, or
	 *             the file cannot be opened, or the file does not exist and
	 *             cannot be created.
	 */
	protected boolean writeToMonthMapFile(File textFile, Map<String, String> map) throws IOException {
		try {
			fWriter = new FileWriter(textFile);
			bWriter = new BufferedWriter(fWriter);

			String mapString = gsonHelper.toJson(map);
			bWriter.write(mapString);

			bWriter.close();
			fWriter.close();

			logger.info(String.format(MESSAGE_FILE_UPDATED, textFile.getAbsolutePath()));
			return true;
			
		} catch (IOException ioEx) {
			String errorMessage = String.format(ERROR_WRITING_TO_FILE, textFile.getAbsolutePath());

			logger.warning(errorMessage);
			throw new IOException(errorMessage, ioEx);
		}
	}

	/**
	 * Method which converts a Map{@code<String, ArrayList<String>>} object into a json
	 * String and saves it into a text file.
	 * 
	 * @param textFile
	 *            the text file to open and write the json String to.
	 * @param map
	 *            the Map object to be written to the text file.
	 * @return true if the Map object is successfully written to the text file.
	 * @throws IOException
	 *             Error writing to the file because the file is a directory, or
	 *             the file cannot be opened, or the file does not exist and
	 *             cannot be created.
	 */
	protected boolean writeToRecurMapFile(File textFile, Map<String, ArrayList<String>> map) throws IOException {
		try {
			fWriter = new FileWriter(textFile);
			bWriter = new BufferedWriter(fWriter);

			String mapString = gsonHelper.toJson(map);
			bWriter.write(mapString);

			bWriter.close();
			fWriter.close();

			logger.info(String.format(MESSAGE_FILE_UPDATED, textFile.getAbsolutePath()));
			return true;
			
		} catch (IOException ioEx) {
			String errorMessage = String.format(ERROR_WRITING_TO_FILE, textFile.getAbsolutePath());

			logger.warning(errorMessage);
			throw new IOException(errorMessage, ioEx);
		}
	}

	/**
	 * Method which writes a list of Strings into a text file.
	 * 
	 * @param textFile
	 *            text file to be written to.
	 * @param listOfTaskNames
	 *            the list of Strings
	 * @return true if the list of Strings is successfully written to the text
	 *         file.
	 * @throws IOException
	 *             Error writing to the file because the file is a directory, or
	 *             the file cannot be opened, or the file does not exist and
	 *             cannot be created.
	 */
	protected boolean writeToListFile(File textFile, ArrayList<String> listOfTaskNames) throws IOException {
		try {
			fWriter = new FileWriter(textFile);
			bWriter = new BufferedWriter(fWriter);

			for (String taskName : listOfTaskNames) {
				bWriter.append(taskName);
				bWriter.newLine();
			}
			
			bWriter.close();
			fWriter.close();

			logger.info(String.format(MESSAGE_FILE_UPDATED, textFile.getAbsolutePath()));
			return true;
		} catch (IOException ioEx) {
			String errorMessage = String.format(ERROR_WRITING_TO_FILE, textFile.getAbsolutePath());

			logger.warning(errorMessage);
			throw new IOException(errorMessage, ioEx);
		}
	}

	/**
	 * Method to clear the text in a text file by writing an empty String into
	 * the file.
	 * 
	 * @param fileToClear
	 *            text file to clear
	 * @return true if file is successfully cleared.
	 * @throws IOException
	 *             Error writing to the file because the file is a directory, or
	 *             the file cannot be opened, or the file does not exist and
	 *             cannot be created.
	 */
	protected boolean clearFile(File fileToClear) throws IOException {
		try {
			fWriter = new FileWriter(fileToClear);
			bWriter = new BufferedWriter(fWriter);

			bWriter.write(STRING_TO_CLEAR_FILES);
			
			bWriter.close();
			fWriter.close();

			logger.info(String.format(MESSAGE_FILE_CLEARED, fileToClear.getAbsolutePath()));
			return true;
			
		} catch (IOException ioEx) {
			String errorMessage = String.format(ERROR_CLEARING_FILE, fileToClear.getAbsolutePath());

			logger.warning(errorMessage);
			throw new IOException(errorMessage, ioEx);
		}
	}

}
```
###### \src\tnote\storage\FileWriteHandlerTest.java
``` java
package tnote.storage;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.Test;

import tnote.object.TaskFile;

public class FileWriteHandlerTest {

	TNotesStorage storage;
	FileReadHandler fRHandler;
	FileWriteHandler fWHandler;

	@AfterClass
	public static void tearDownAfterClass() throws Exception {
		TNotesStorage storage = TNotesStorage.getInstance();
		System.out.println(storage.deleteMasterDirectory());
	}

	@Before
	public void setUp() throws Exception {
		storage = TNotesStorage.getInstance();
		fRHandler = FileReadHandler.getInstance();
		fWHandler = FileWriteHandler.getInstance();
		storage.setUpStorage();
		storage.clearFiles();

	}

	@After
	public void tearDown() throws Exception {
		System.out.println(storage.clearFiles());
	}

	@Test
	public void testWriteToListFileAndClearFile() {
		File testListFile = new File("C:/TNote/overview/masterfile.txt");
		ArrayList<String> testList = new ArrayList<String>();
		testList.add("testingA");
		testList.add("testingB");

		ArrayList<String> testList2 = new ArrayList<String>();
		testList2.add("overwrite1");
		testList2.add("overwrite2");
		testList2.add("overwrite3");
		

		try {
			
			//Test valid append String
			assertTrue("write to list file first String", fWHandler.writeNameToListFile(testListFile, "testingA"));
			assertTrue("write to list file second String", fWHandler.writeNameToListFile(testListFile, "testingB"));

			assertEquals("check what is written is correct for append list", testList,
					fRHandler.readListFile(testListFile));

			//Test valid write entire list
			assertTrue("write entire list to file", fWHandler.writeToListFile(testListFile, testList2));

			assertEquals("check if what is written is correct for write list", testList2,
					fRHandler.readListFile(testListFile));
			
			//Test valid clear file
			assertTrue("clear list", fWHandler.clearFile(testListFile));

			ArrayList<String> emptyAL = new ArrayList<String>();
			assertEquals("check if file is cleared", emptyAL, fRHandler.readListFile(testListFile));

		} catch (Exception e) {
			fail("Exception should not be thrown on a valid write to list or clear list");
		}
		
		File directoryFile = new File("C:/TNote/overview");
		
		//Test IOException from writeNameToListFile
		try {
			fWHandler.writeNameToListFile(directoryFile, "invalidFile");

			fail("Exception should be thrown when appending a String to a directory");

		} catch (Exception e) {
			assertEquals("check exception class", IOException.class, e.getClass());
			assertEquals("check exception message", "There is an error saving invalidFile to C:\\TNote\\overview",
					e.getMessage());
		}
		
		//Test IOException from writeToListFile
		try {
			fWHandler.writeToListFile(directoryFile, testList2);

			fail("Exception should be thrown when writing a list to a directory");
		} catch (Exception e) {
			assertEquals("check exception class", IOException.class, e.getClass());
			assertEquals("check exception message", "There is an error writing to C:\\TNote\\overview",
					e.getMessage());
		}
		
		//Test IOException from clearFile
		try {
			fWHandler.clearFile(directoryFile);

			fail("Exception should be thrown when trying to clear a directory file");
		} catch (Exception e) {
			assertEquals("check exception class", IOException.class, e.getClass());
			assertEquals("check exception message", "There is an error clearing the file C:\\TNote\\overview",
					e.getMessage());
		}

	}

	@Test
	public void testWriteTaskToTextFile() {
		File testTaskTextFile = new File("C:/TNote/overview/testTask.txt");
		try {

			TaskFile testTask = new TaskFile("test", "2016-4-10", "13:00", "2016-4-11",
					"11:00", "testDetails", true, false);
			
			//Test valid write Task to text file
			assertTrue("write TaskFile to txt", fWHandler.writeTaskToTextFile(testTaskTextFile, testTask));

			assertEquals("Check what is written is correct for Task to text file", testTask, 
					fRHandler.readTaskTextFile(testTaskTextFile));

		} catch (Exception e) {
			fail("Exception should not be thrown on a valid write task to text file");
		}
		
		File directoryFile = new File("C:/TNote/overview");
		
		//Test IOException from writeTaskToTextFile
		try {
			TaskFile testTask = new TaskFile("test", "2016-4-10", "13:00", "2016-4-11",
					"11:00", "testDetails", true, false);
			fWHandler.writeTaskToTextFile(directoryFile, testTask);

			fail("Exception should be thrown when writing a task file to a directory");

		} catch (Exception e) {
			assertEquals("check exception class", IOException.class, e.getClass());
			assertEquals("check exception message", "There is an error saving test as a text file",
					e.getMessage());
		}
	}

	@Test
	public void testWriteToMonthMapFile() {
		File testFolderFile = new File("C:/TNote/overview/filetofoldermapping.txt");

		Map<String, String> testMap = new HashMap<String, String>();
		testMap.put("testName1", "testFolder1");
		testMap.put("testName2", "testFolder2");

		try {
			//Test valid write to folder map
			assertTrue("write folder map", fWHandler.writeToMonthMapFile(testFolderFile, testMap));

			assertEquals("Check what was written is correct for write folder map", testMap,
					fRHandler.readFolderMapFile(testFolderFile));

		} catch (Exception e) {
			fail("Exception should not be thrown for a valid write folder map");
		}

		File directoryFile = new File("C:/TNote/overview");
		
		//Test IOException from writeToMonthMapFile
		try {
			fWHandler.writeToMonthMapFile(directoryFile, testMap);

			fail("Exception should be thrown when writing a folder map to a directory");

		} catch (Exception e) {
			assertEquals("check exception class", IOException.class, e.getClass());
			assertEquals("check exception message", "There is an error writing to C:\\TNote\\overview",
					e.getMessage());
		}
	}

	@Test
	public void testWriteToRecurMap() {
		File testDateFile = new File("C:/TNote/overview/recurringTaskStartDates.txt");

		Map<String, ArrayList<String>> testDateMap = new HashMap<String, ArrayList<String>>();

		ArrayList<String> testDates1 = new ArrayList<String>();
		testDates1.add("12-12-2015");
		testDates1.add("13-12-2016");

		ArrayList<String> testDates2 = new ArrayList<String>();
		testDates2.add("15-12-2015");
		testDates2.add("16-12-2016");

		testDateMap.put("recurTest1", testDates1);
		testDateMap.put("recurTest2", testDates2);

		try {
			//Test valid write to recur map
			assertTrue("write to recur map", fWHandler.writeToRecurMapFile(testDateFile, testDateMap));

			assertEquals("check what is written is correct for write recur map", testDateMap,
					fRHandler.readDateMapFile(testDateFile));

		} catch (Exception e) {
			fail("Exception should not be thrown for a valid write recur map");
		}

		File directoryFile = new File("C:/TNote/overview");
		
		//Test IOException from writeToRecurMapFile
		try {
			fWHandler.writeToRecurMapFile(directoryFile, testDateMap);

			fail("Exception should be thrown when writing a recur map to a directory");

		} catch (Exception e) {
			assertEquals("check exception class", IOException.class, e.getClass());
			assertEquals("check exception message", "There is an error writing to C:\\TNote\\overview",
					e.getMessage());
		}
	}
}
```
###### \src\tnote\storage\MasterFileHandler.java
``` java
package tnote.storage;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Map;
import java.util.logging.Logger;

/**
 * This class manages the master files necessary in TNote.
 * 
 * Paths to each master file are saved in this class. Each master file is a text
 * file stored in a common folder. Information can be saved or extracted from
 * each master file.
 * 
 * @author A0124131B
 *
 */
public class MasterFileHandler {

	
	private static final String MESSAGE_RECUR_FILE_READY = "Recur map file %s is empty and can be written to";
	private static final String MESSAGE_MONTH_FILE_READY = "Month file %s is empty and can be written to";
	private static final String MESSAGE_LIST_FILE_READY = "List File %s is empty and can be written to";
	private static final String MESSAGE_OVERVIEW_FILE_CREATED = "Overview file %s created";
	private static final String MESSAGE_OVERVIEW_FOLDER_CREATED = "Overview folder %s created";
	private static final String MESSAGE_MASTER_FILES_CREATED = "Master Files created";
	private static final String MESSAGE_CLASS_CREATED = "MasterFileHandler created";

	private static final String ERROR_CREATE = "%s cannot be created";
	private static final String ERROR_RECUR_FILE_WRITE = "Error writing to recur map file %s";
	private static final String ERROR_LIST_FILE_WRITE = "Error writing to list file %s";
	private static final String ERROR_MONTH_FILE_WRITE = "Error writing to Month file %s";
	private static final String ERROR_MASTER_DIR_NOT_DELETE_RE_SETUP = "Master Directory not deleted, reset storage";

	private static final String OVERVIEW_FILES_FOLDER_NAME = "overview";
	private static final String RECURRING_TASK_END_DATES_FILE_NAME = "recurringTaskEndDates.txt";
	private static final String RECURRING_TASK_START_DATES_FILE_NAME = "recurringTaskStartDates.txt";
	private static final String MASTER_FILE_NAME = "masterfile.txt";
	private static final String MAPPING_FILE_NAME = "fileToFolderMapping.txt";
	private static final String FLOATING_LIST_FILE_NAME = "floatingtasks.txt";

	private static final Logger logger = Logger.getGlobal();

	private static MasterFileHandler instance;

	private DirectoryHandler dirHandler;
	private FileWriteHandler fWHandler;
	private FileReadHandler fRHandler;
	private File masterFile;
	private File monthMapFile;
	private File floatingListFile;
	private File overviewFolder;
	private File recurStartMapFile;
	private File recurEndMapFile;

	/**
	 * Constructor for MasterFileHandler. Initializes the necessary
	 * dependencies.
	 */
	private MasterFileHandler() {
		dirHandler = DirectoryHandler.getInstance();
		fWHandler = FileWriteHandler.getInstance();
		fRHandler = FileReadHandler.getInstance();

		logger.info(MESSAGE_CLASS_CREATED);
	}

	/**
	 * Method to get an instance of MasterFileHandler. If no instance exists, a
	 * new instance is created.
	 * 
	 * @return MasterFileHandler the instance of MasterFileHandler
	 * @throws IOException
	 *             I/O Error when creating any master file
	 */
	protected static MasterFileHandler getInstance() throws IOException {
		if (instance == null) {
			instance = new MasterFileHandler();
		}

		instance.setUpStorage();
		return instance;
	}

	/*------------------- SetUp Methods -------------------------- */
	/**
	 * Method which creates all the master files in an overview folder
	 * 
	 * @throws IOException
	 *             I/O Error when creating any master file
	 */
	protected void setUpStorage() throws IOException {

		setUpOverviewFolder();

		setUpMasterFile();
		setUpFloatingListFile();
		setUpFolderMap();
		setUpRecurringMaps();

		logger.info(MESSAGE_MASTER_FILES_CREATED);
	}

	/**
	 * Method to create the overview folder directory
	 * 
	 * @throws IOException
	 *             I/O Error creating the overview folder
	 */
	private void setUpOverviewFolder() throws IOException {
		overviewFolder = createOverviewFolder(OVERVIEW_FILES_FOLDER_NAME);
	}

	/**
	 * Method to create the master file
	 * 
	 * @throws IOException
	 *             I/O Error creating the master file
	 */
	private void setUpMasterFile() throws IOException {
		masterFile = createAnOverviewFile(MASTER_FILE_NAME);
	}

	/**
	 * Method to create the floating list file
	 * 
	 * @throws IOException
	 *             I/O Error creating the floating list file
	 */
	private void setUpFloatingListFile() throws IOException {
		floatingListFile = createAnOverviewFile(FLOATING_LIST_FILE_NAME);
	}

	/**
	 * Method to create the date map files for recurring tasks
	 * 
	 * @throws IOException
	 *             I/O Error creating the date map files
	 */
	private void setUpRecurringMaps() throws IOException {
		setUpRecurStartDateMap();
		setUpRecurEndDateMap();
	}

	/**
	 * Method to create the folder map file
	 * 
	 * @throws IOException
	 *             I/O Error creating the folder map file
	 */
	private void setUpFolderMap() throws IOException {
		monthMapFile = createAnOverviewFile(MAPPING_FILE_NAME);
	}

	/**
	 * Method to create the recurring start date file
	 * 
	 * @throws IOException
	 *             I/O Error creating the recurring start date file
	 */
	private void setUpRecurStartDateMap() throws IOException {
		recurStartMapFile = createAnOverviewFile(RECURRING_TASK_START_DATES_FILE_NAME);
	}

	/**
	 * Method to create the recurring end date file
	 * 
	 * @throws IOException
	 *             I/O Error creating the recurring end date file
	 */
	private void setUpRecurEndDateMap() throws IOException {
		recurEndMapFile = createAnOverviewFile(RECURRING_TASK_END_DATES_FILE_NAME);
	}

	/*----------------------Create------------------------------ */
	/**
	 * Method which creates the overview folder inside of the parent directory
	 * 
	 * @param folderName
	 *            the name of the overview folder
	 * @return File the object which points to the overview folder
	 * @throws IOException
	 *             I/O Error when creating the folder
	 */
	private File createOverviewFolder(String folderName) throws IOException {
		File folderToCreate = dirHandler.appendParentDirectory(folderName);

		if (dirHandler.createDirectory(folderToCreate)) {
			logger.info(String.format(MESSAGE_OVERVIEW_FOLDER_CREATED, folderToCreate.getAbsolutePath()));
			return folderToCreate;

		} else {
			String errorMessage = String.format(ERROR_CREATE, folderToCreate.getAbsolutePath());

			logger.warning(errorMessage);
			throw new IOException(errorMessage);
		}
	}

	/**
	 * Method to create a file inside the overview folder
	 * 
	 * @param name
	 *            the name of the file to create
	 * @return File the object pointing to the file created
	 * @throws IOException
	 *             I/O Error when creating the file
	 */
	private File createAnOverviewFile(String name) throws IOException {
		File overviewFile = dirHandler.addDirectoryToFile(overviewFolder, name);

		if (dirHandler.createFile(overviewFile)) {
			logger.info(String.format(MESSAGE_OVERVIEW_FILE_CREATED, overviewFile.getAbsoluteFile()));
			return overviewFile;
			
		} else {
			String errorMessage = String.format(ERROR_CREATE, overviewFile.getAbsolutePath());

			logger.warning(errorMessage);
			throw new IOException(errorMessage);
		}
	}

	/*------------------------Delete or Clear -----------------------*/
	/**
	 * Method which clears all the information in each master file, along with
	 * all folders which were created
	 * 
	 * @return true if the master files have been emptied
	 * @throws IOException
	 *             I/O Error when deleting or creating the master files
	 */
	protected boolean clearMasterFile() throws IOException {
		if(dirHandler.deleteMasterDirectory()) {
			setUpStorage();
			return true;
		} else {
			//Master directory was not deleted, setUp storage to ensure master files still exists.
			logger.warning(ERROR_MASTER_DIR_NOT_DELETE_RE_SETUP);
			return false;
		}
	}

	/**
	 * Method to clear all information inside an overview file
	 * 
	 * @param fileToClear
	 *            File object pointing to the file to clear
	 * @return true if the file is cleared
	 * @throws IOException
	 *             I/O Error when clearing the file
	 */
	private boolean clearAnOverviewFile(File fileToClear) throws IOException {
		return fWHandler.clearFile(fileToClear);
	}

	/*---------------------------Write to files-----------------------*/
	/**
	 * Method to write a specified ArrayList{@code<String>} to the master file
	 * 
	 * @param listOfTasks
	 *            the list to be written to the master file
	 * @return true if the list is successfully written into the master file
	 * @throws IOException
	 *             I/O Error when writing to the master file
	 */
	protected boolean writeToMasterListFile(ArrayList<String> listOfTasks) throws IOException {
		return writeListToListFile(masterFile, listOfTasks);
	}

	/**
	 * Method to write a specified ArrayList{@code<String>} to the floating list
	 * file
	 * 
	 * @param listOfTasks
	 *            the list to be written to the floating list file
	 * @return true if the list is successfully written into the floating list
	 *         file
	 * @throws IOException
	 *             I/O Error when writing to the floating list file
	 */
	protected boolean writeToFloatingListFile(ArrayList<String> listOfTasks) throws IOException {
		return writeListToListFile(floatingListFile, listOfTasks);
	}

	/**
	 * Method to write an ArrayList{@code<String>} into a specified file
	 * 
	 * @param listFile
	 *            the file to write to
	 * @param listOfTasks
	 *            the list to be written to the file
	 * @return true if the list is successfully written to the file
	 * @throws IOException
	 *             I/O Error when writing to the file
	 */
	private boolean writeListToListFile(File listFile, ArrayList<String> listOfTasks) throws IOException {
		if (clearAnOverviewFile(listFile)) {
			logger.info(String.format(MESSAGE_LIST_FILE_READY, listFile.getAbsolutePath()));
			return fWHandler.writeToListFile(listFile, listOfTasks);
			
		} else {
			String errorMessage = String.format(ERROR_LIST_FILE_WRITE, listFile.getAbsolutePath());
			
			logger.warning(errorMessage);
			return false;
		}
	}

	/**
	 * Method to add a single task name to the master list file
	 * 
	 * @param taskName
	 *            name of the task to be added to the master list file
	 * @return true if the name is successfully added
	 * @throws IOException
	 *             I/O Error when writing to the master list file
	 */
	protected boolean appendTaskToMasterListFile(String taskName) throws IOException {
		return appendTaskToListFile(masterFile, taskName);
	}

	/**
	 * Method to add a single task name to the floating list file
	 * 
	 * @param taskName
	 *            name of the task to be added to the floating list file
	 * @return true if the name is successfully added
	 * @throws IOException
	 *             I/O Error when writing to the floating list file
	 */
	protected boolean appendTaskToFloatingListFile(String taskName) throws IOException {
		return appendTaskToListFile(floatingListFile, taskName);
	}

	/**
	 * Method to append a specified string into a file
	 * 
	 * @param listFile
	 *            the file to append to
	 * @param taskName
	 *            the String to be added into the file
	 * @return true if the String is successfully appended into the file
	 * @throws IOException
	 *             I/O Error when writing to the specified file
	 */
	private boolean appendTaskToListFile(File listFile, String taskName) throws IOException {
		return fWHandler.writeNameToListFile(listFile, taskName);
	}

	/**
	 * Method to write a Map{@code<String, String>} to the month map file
	 * 
	 * @param map
	 *            the map object to be written to the file
	 * @return true if the map object is successfully written to the file
	 * @throws IOException
	 *             I/O Error when writing to the month map file
	 */
	protected boolean writeToMonthMapFile(Map<String, String> map) throws IOException {
		if (clearAnOverviewFile(monthMapFile)) {
			logger.info(String.format(MESSAGE_MONTH_FILE_READY, monthMapFile.getAbsolutePath()));
			return fWHandler.writeToMonthMapFile(monthMapFile, map);
			
		} else {
			String errorMessage = String.format(ERROR_MONTH_FILE_WRITE, monthMapFile.getAbsolutePath());
			
			logger.warning(errorMessage);
			return false;
		}
	}

	/**
	 * Method to write a Map{@code<String, ArrayList<String>>} to the recurring
	 * start date file
	 * 
	 * @param map
	 *            the map object to be written to the file
	 * @return true if the map object is successfully written to the file
	 * @throws IOException
	 *             I/O Error when writing to the recurring start date file
	 */
	protected boolean writeToRecurringStartDateMap(Map<String, ArrayList<String>> map) throws IOException {
		return writeToRecurringMapFile(recurStartMapFile, map);
	}

	/**
	 * Method to write a Map{@code<String, ArrayList<String>>} to the recurring
	 * end date file
	 * 
	 * @param map
	 *            the map object to be written to the file
	 * @return true if the map object is successfully written to the file
	 * @throws IOException
	 *             I/O Error when writing to the recurring end date file
	 */
	protected boolean writeToRecurringEndDateMap(Map<String, ArrayList<String>> map) throws IOException {
		return writeToRecurringMapFile(recurEndMapFile, map);
	}

	/**
	 * Method which writes a Map{@code<String, ArrayList<String>>} to a
	 * specified file
	 * 
	 * @param mapFile
	 *            the file to write to
	 * @param map
	 *            the map object to be written to the file
	 * @return true if the map object is successfully written to the file
	 * @throws IOException
	 *             I/O Error when writing to the file
	 */
	private boolean writeToRecurringMapFile(File mapFile, Map<String, ArrayList<String>> map) throws IOException {
		if (clearAnOverviewFile(mapFile)) {
			logger.info(String.format(MESSAGE_RECUR_FILE_READY, mapFile.getAbsolutePath()));
			return fWHandler.writeToRecurMapFile(mapFile, map);
			
		} else {
			String errorMessage = String.format(ERROR_RECUR_FILE_WRITE, mapFile.getAbsolutePath());
			
			logger.warning(errorMessage);
			return false;
		}
	}

	/*----------------------------Read-----------------------------------*/
	/**
	 * Method to read from the master file
	 * 
	 * @return ArrayList{@code<String>} the list of tasks currently in the
	 *         system
	 * @throws IOException
	 *             I/O Error when reading from the master file
	 */
	protected ArrayList<String> readFromMasterFile() throws IOException {
		return readFromListFile(masterFile);
	}

	/**
	 * Method to read from the floating list file
	 * 
	 * @return ArrayList{@code<String>} the list of floating tasks currently in
	 *         the system
	 * @throws IOException
	 *             I/O Error when reading from the floating list file
	 */
	protected ArrayList<String> readFromFloatingFile() throws IOException {
		return readFromListFile(floatingListFile);
	}

	/**
	 * Method to read from a specified list file which contains a list of
	 * Strings
	 * 
	 * @param listFile
	 *            the file to be read
	 * @return ArrayList{@code<String>} the list of Strings read from the file
	 * @throws IOException
	 *             I/O Error when reading from the specified file
	 */
	private ArrayList<String> readFromListFile(File listFile) throws IOException {
		return fRHandler.readListFile(listFile);
	}

	/**
	 * Method to read a Map{@code<String, ArrayList<String>>} from a specified
	 * file
	 * 
	 * @param dateMapFile
	 *            the file to be read
	 * @return Map{@code<String, ArrayList<String>>} the map object read from
	 *         the file
	 * @throws IOException
	 *             I/O Error when reading from the specified file
	 */
	private Map<String, ArrayList<String>> readFromDateMapFile(File dateMapFile) throws IOException {
		return fRHandler.readDateMapFile(dateMapFile);
	}

	/**
	 * Method to read a Map{@code<String, ArrayList<String>>} from the recurring
	 * start date file
	 * 
	 * @return Map{@code<String, ArrayList<String>>} the recurring start date
	 *         map read from the file
	 * @throws IOException
	 *             I/O Error when reading from the recurring start date file
	 */
	protected Map<String, ArrayList<String>> readRecurStartDateMap() throws IOException {
		return readFromDateMapFile(recurStartMapFile);
	}

	/**
	 * Method to read a Map{@code<String, ArrayList<String>>} from the recurring
	 * end date file
	 * 
	 * @return Map{@code<String, ArrayList<String>>} the recurring end date map
	 *         read from the file
	 * @throws IOException
	 *             I/O Error when reading from the recurring end date file
	 */
	protected Map<String, ArrayList<String>> readRecurEndDateMap() throws IOException {
		return readFromDateMapFile(recurEndMapFile);
	}

	/**
	 * Method to read a Map{@code<String, String>} from the folder map file
	 * 
	 * @return Map{@code<String, String>} the folder map read from the file
	 * @throws IOException
	 *             I/O Error when reading from the folder map file
	 */
	protected Map<String, String> readFromFolderMap() throws IOException {
		return fRHandler.readFolderMapFile(monthMapFile);
	}
}
```
###### \src\tnote\storage\MasterFileHandlerTest.java
``` java
package tnote.storage;

import static org.junit.Assert.assertTrue;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.Test;

import tnote.object.TaskFile;

public class MasterFileHandlerTest {
	TNotesStorage storage;
	MasterFileHandler mFHandler;

	@AfterClass
	public static void tearDownAfterClass() throws Exception {
		TNotesStorage storage = TNotesStorage.getInstance();
		System.out.println(storage.deleteMasterDirectory());
	}

	@Before
	public void setUp() throws Exception {
		storage = TNotesStorage.getInstance();
		storage.setUpStorage();
		storage.clearFiles();
		mFHandler = MasterFileHandler.getInstance();
	}

	@After
	public void tearDown() throws Exception {
		System.out.println(storage.clearFiles());
	}

	@Test
	public void testWriteToMasterFiles() {
		try {

			FileReadHandler fRHandler = FileReadHandler.getInstance();
			File masterFile = new File("C:\\TNote\\overview\\masterfile.txt");
			File floatingFile = new File("C:\\TNote\\overview\\floatingtasks.txt");
			File folderMapFile = new File("C:\\TNote\\overview\\fileToFolderMapping.txt");
			File recurStartFile = new File("C:\\TNote\\overview\\recurringTaskStartDates.txt");
			File recurEndFile = new File("C:\\TNote\\overview\\recurringTaskEndDates.txt");

			ArrayList<String> testMaster = new ArrayList<String>();
			ArrayList<String> testFloating = new ArrayList<String>();

			testMaster.add("master1");
			testMaster.add("Master2");

			testFloating.add("floating1");
			testFloating.add("floating2");

			Map<String, String> testMonthMap = new HashMap<String, String>();
			Map<String, ArrayList<String>> testRecurStartMap = new HashMap<String, ArrayList<String>>();
			Map<String, ArrayList<String>> testRecurEndMap = new HashMap<String, ArrayList<String>>();

			testMonthMap.put("task1", "January");
			testMonthMap.put("task2", "February");

			ArrayList<String> startDates = new ArrayList<String>();
			startDates.add("3-2-2015");
			startDates.add("4-2-2015");

			ArrayList<String> startDates2 = new ArrayList<String>();
			startDates2.add("5-4-2016");
			startDates2.add("6-4-2016");

			testRecurStartMap.put("recur1", startDates);
			testRecurStartMap.put("recur2", startDates2);

			ArrayList<String> endDates = new ArrayList<String>();
			startDates.add("4-2-2015");
			startDates.add("5-2-2015");

			ArrayList<String> endDates2 = new ArrayList<String>();
			startDates2.add("6-4-2016");
			startDates2.add("7-4-2016");

			testRecurEndMap.put("recur1", endDates);
			testRecurEndMap.put("recur2", endDates2);

			// Test write to master list
			assertTrue("write to master list", mFHandler.writeToMasterListFile(testMaster));
			assertEquals("check what is written to master list", testMaster, fRHandler.readListFile(masterFile));

			// Test write to floating list
			assertTrue("write to floating list", mFHandler.writeToFloatingListFile(testFloating));
			assertEquals("check what is written to floating list", testFloating, fRHandler.readListFile(floatingFile));

			// Test append to master list
			assertTrue("append to master list", mFHandler.appendTaskToMasterListFile("master3"));

			testMaster.add("master3");
			assertEquals("check appended to master", testMaster, fRHandler.readListFile(masterFile));

			// Test append to floating list
			assertTrue("append to floating list", mFHandler.appendTaskToFloatingListFile("floating3"));

			testFloating.add("floating3");
			assertEquals("check appended to floating", testFloating, fRHandler.readListFile(floatingFile));

			// Test write to month map file
			assertTrue("write to month map", mFHandler.writeToMonthMapFile(testMonthMap));
			assertEquals("check what is written to folder map", testMonthMap,
					fRHandler.readFolderMapFile(folderMapFile));

			// Test write to recur start date file
			assertTrue("write to recur start date", mFHandler.writeToRecurringStartDateMap(testRecurStartMap));
			assertEquals("check what is written to recur start date file", testRecurStartMap,
					fRHandler.readDateMapFile(recurStartFile));

			// Test write to recur end date file
			assertTrue("write to recur end date", mFHandler.writeToRecurringEndDateMap(testRecurEndMap));
			assertEquals("check what is written to recur end date file", testRecurEndMap,
					fRHandler.readDateMapFile(recurEndFile));

		} catch (Exception e) {
			fail("No Exceptions should be thrown for valid cases");
		}
	}

	@Test
	public void testReadFromMasterFiles() {
		try {
			FileWriteHandler fWHandler = FileWriteHandler.getInstance();
			File masterFile = new File("C:\\TNote\\overview\\masterfile.txt");
			File floatingFile = new File("C:\\TNote\\overview\\floatingtasks.txt");
			File folderMapFile = new File("C:\\TNote\\overview\\fileToFolderMapping.txt");
			File recurStartFile = new File("C:\\TNote\\overview\\recurringTaskStartDates.txt");
			File recurEndFile = new File("C:\\TNote\\overview\\recurringTaskEndDates.txt");

			ArrayList<String> testMaster = new ArrayList<String>();
			ArrayList<String> testFloating = new ArrayList<String>();

			testMaster.add("master1");
			testMaster.add("Master2");

			testFloating.add("floating1");
			testFloating.add("floating2");

			Map<String, String> testMonthMap = new HashMap<String, String>();
			Map<String, ArrayList<String>> testRecurStartMap = new HashMap<String, ArrayList<String>>();
			Map<String, ArrayList<String>> testRecurEndMap = new HashMap<String, ArrayList<String>>();

			testMonthMap.put("task1", "January");
			testMonthMap.put("task2", "February");

			ArrayList<String> startDates = new ArrayList<String>();
			startDates.add("3-2-2015");
			startDates.add("4-2-2015");

			ArrayList<String> startDates2 = new ArrayList<String>();
			startDates2.add("5-4-2016");
			startDates2.add("6-4-2016");

			testRecurStartMap.put("recur1", startDates);
			testRecurStartMap.put("recur2", startDates2);

			ArrayList<String> endDates = new ArrayList<String>();
			startDates.add("4-2-2015");
			startDates.add("5-2-2015");

			ArrayList<String> endDates2 = new ArrayList<String>();
			startDates2.add("6-4-2016");
			startDates2.add("7-4-2016");

			testRecurEndMap.put("recur1", endDates);
			testRecurEndMap.put("recur2", endDates2);

			// Test read from master file
			fWHandler.writeToListFile(masterFile, testMaster);
			assertEquals("read from master", testMaster, mFHandler.readFromMasterFile());

			// Test read from floating file
			fWHandler.writeToListFile(floatingFile, testFloating);
			assertEquals("read from floating", testFloating, mFHandler.readFromFloatingFile());

			// Test read from folder map
			fWHandler.writeToMonthMapFile(folderMapFile, testMonthMap);
			assertEquals("read from month map", testMonthMap, mFHandler.readFromFolderMap());

			// Test read from recur start date file
			fWHandler.writeToRecurMapFile(recurStartFile, testRecurStartMap);
			assertEquals("read from recur start date file", testRecurStartMap, mFHandler.readRecurStartDateMap());

			// Test read from recur end date file
			fWHandler.writeToRecurMapFile(recurEndFile, testRecurEndMap);
			assertEquals("read from recur end date file", testRecurEndMap, mFHandler.readRecurEndDateMap());

		} catch (Exception e) {
			fail("No Exceptions should be thrown for valid cases");
		}
	}

	@Test
	public void testDeleteAndClear() {
		try {
			TaskFile testTask = new TaskFile("testing1");
			TaskFile testTask2 = new TaskFile("testing2");
			
			storage.addTask(testTask);
			storage.addTask(testTask2);
			
			ArrayList<String> testMaster = new ArrayList<String>();
			testMaster.add("testing1");
			testMaster.add("testing2");
			
			//Test clear master
			assertEquals("master added with tasks", testMaster, mFHandler.readFromMasterFile());
			
			assertTrue("clear master file",mFHandler.clearMasterFile());
			ArrayList<String> blankList = new ArrayList<String>();
			assertEquals("empty master file", blankList, mFHandler.readFromMasterFile());
			
		} catch (Exception e) {
			fail("No Exceptions should be thrown for valid cases");
		}

	}

}
```
###### \src\tnote\storage\TaskHandler.java
``` java
package tnote.storage;

import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.assertFalse;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.List;
import java.util.Map;
import java.util.logging.Logger;

import tnote.object.TaskFile;
import tnote.util.exceptions.IncorrectTimeException;

/**
 * This class manages the tasks within TNote. It allows for tasks to be added,
 * deleted and read. Tasks are saved inside folders, and each folder is named as
 * the month of the task's starting date.
 * 
 * @author A0124131B
 *
 */
public class TaskHandler {

	private static final String MESSAGE_TASK_FOUND = "%s is found";
	private static final String MESSAGE_ALL_OVERDUE_LIST = "overdue tasks: %s";
	private static final String MESSAGE_OVERDUE = "%s is overdue";
	private static final String MESSAGE_NOT_OVERDUE = "%s is not overdue";
	private static final String MESSAGE_TASK_NAME_VALID = "task name %s is valid";
	private static final String MESSAGE_MONTH_FOLDER_NAME = "%s is the month folder for %s";
	private static final String MESSAGE_MONTH_FOLDER_GET = "Month folder %s is retrieved for %s";
	private static final String MESSAGE_TASK_CREATED = "Task %s created";
	private static final String MESSAGE_TASK_FOLDER_CREATED = "Task folder %s created";

	private static final String ERROR_TASK_NAME_INVALID = "task name %s is invalid";
	private static final String ERROR_TASK_FOLDER_CREATE = "Error creating the directory folder %s";
	private static final String ERROR_TASK_CREATE = "Error creating task %s";
	private static final String ERROR_TASK_NOT_EXIST = "%s does not exist";

	private static final String FILE_TYPE_TXT_FILE = ".txt";
	private static final String RECURRING_TASK_MASTER_FOLDER = "recurring";
	private static final String FLOATING_TASK_FOLDER = "floating";
	private static final String FULL_MONTH_STRING = "MMMM";
	private static final String[] ILLEGAL_CHARACTERS = { "/", "\n", "\r", "\t", "\0", "\f", "`", "?", "*", "\\", "<",
														">", "|", "\"", ":" };

	private static final int MAXIMUM_FILE_PATH_LENGTH = 260;

	private static final Logger logger = Logger.getGlobal();

	private static TaskHandler instance;

	private DirectoryHandler dirHandler;
	private FileWriteHandler fWHandler;
	private FileReadHandler fRHandler;

	/**
	 * Constructor for TaskHandler class. Initializes the necessary class
	 * dependencies.
	 */
	private TaskHandler() {
		dirHandler = DirectoryHandler.getInstance();
		fWHandler = FileWriteHandler.getInstance();
		fRHandler = FileReadHandler.getInstance();

		logger.info("TaskHandler created");
	}

	/**
	 * Method to get instance of TaskHandler. If instance does not exist, a new
	 * instance is created.
	 * 
	 * @return TaskHandler the instance of TaskHandler.
	 */
	protected static TaskHandler getInstance() {
		if (instance == null) {
			instance = new TaskHandler();
		}
		return instance;
	}

	/*-------------------------------Create Task------------------------------------*/
	/**
	 * Method to create the text file in a specified directory to store a
	 * TaskFile object
	 * 
	 * @param directory
	 *            the directory string for the text file
	 * @param task
	 *            the TaskFile object to be stored
	 * @return true if the TaskFile object is successfully saved into a text
	 *         file
	 * @throws IOException
	 *             I/O Error encountered when creating the text file or writing
	 *             to the text file.
	 */
	protected boolean createTaskFile(String directory, TaskFile task) throws IOException {
		String errorMessage;
		File folder = dirHandler.appendParentDirectory(directory.trim());

		if (createTaskFolder(folder)) {
			logger.info(String.format(MESSAGE_TASK_FOLDER_CREATED, folder.getAbsolutePath()));
			String textFileName = getTextFileName(task.getName());
			File newTextFile = dirHandler.addDirectoryToFile(folder, textFileName);

			if (createTaskTextFile(newTextFile)) {
				logger.info(String.format(MESSAGE_TASK_CREATED, newTextFile.getAbsolutePath()));
				
				// if text file is created, begin writing to the text file
				return writeTaskToTextFile(task, newTextFile);

			} else {
				errorMessage = String.format(ERROR_TASK_CREATE, newTextFile.getAbsolutePath());

				logger.warning(errorMessage);
				throw new IOException(errorMessage);
			}
		} else {
			errorMessage = String.format(ERROR_TASK_FOLDER_CREATE, folder.getAbsolutePath());

			logger.warning(errorMessage);
			throw new IOException(errorMessage);
		}
	}

	/**
	 * Method which takes in a Task File to be written to a specified text file
	 * 
	 * @param task
	 *            the Task File object to be written to a text file
	 * @param newTextFile
	 *            the text file to write to
	 * @return true if the Task File is successfully written to the text file
	 * @throws IOException
	 *             I/O Error when writing to the text file
	 */
	private boolean writeTaskToTextFile(TaskFile task, File newTextFile) throws IOException {
		return fWHandler.writeTaskToTextFile(newTextFile, task);
	}

	/**
	 * Method to create the folder which a task file resides in
	 * 
	 * @param folder
	 *            the File object containing the folder path to create
	 * @return true if the folder is successfully created
	 */
	private boolean createTaskFolder(File folder) {
		return dirHandler.createDirectory(folder);
	}

	/**
	 * Method to create the text file for a Task File to be written to
	 * 
	 * @param task
	 *            the File object containing the path to the text file to create
	 * @return true if the text file is created
	 * @throws IOException
	 *             I/O Error when creating the text file
	 */
	private boolean createTaskTextFile(File task) throws IOException {
		return dirHandler.createFile(task);
	}
	
	/*-------------------------------------Delete Task-----------------------------------------*/
	/**
	 * Method to delete a text file associated with a TaskFile object
	 * 
	 * @param taskNameToDelete
	 *            the name of text file to delete
	 * @param folderMap
	 *            the Map containing the folders associated with each text file
	 * @return true if the text file is deleted successfully
	 * @throws IOException
	 *             I/O Error encountered when trying to delete the file.
	 */
	protected boolean deleteTaskTextFile(String taskNameToDelete, Map<String, String> folderMap) throws IOException {
		File fileToDelete = getTaskFilePath(taskNameToDelete, folderMap);
		return dirHandler.deleteFile(fileToDelete);
	}
	
	/*-------------------------------Get Task File --------------------------------*/
	
	/**
	 * Method which gets the appropriate folder name for the TaskFile object
	 * based on various attributes. If the task is a recurring task or a
	 * floating task, return a fixed folder name, else, return a folder name
	 * based on the starting month of the task
	 * 
	 * @param task
	 *            the TaskFile object to have a folder name extracted
	 * @return String the folder name of the Task File object
	 */
	protected String retrieveFolderName(TaskFile task) {
		String monthFolder;
		if (task.getIsTask()) {
			monthFolder = FLOATING_TASK_FOLDER;

		} else if (task.getIsRecurring()) {
			monthFolder = RECURRING_TASK_MASTER_FOLDER;
			
		} else {
			monthFolder = getTaskMonth(task);
		}

		logger.info(String.format(MESSAGE_MONTH_FOLDER_NAME, monthFolder, task.getName()));
		return monthFolder;
	}

	/**
	 * Method to create a month String from the starting date of the task (e.g.
	 * January, February)
	 * 
	 * @param task
	 *            the TaskFile to use to create the month String
	 * @return String the full month String associated with the task
	 */
	private String getTaskMonth(TaskFile task) {
		SimpleDateFormat monthStringFormat = new SimpleDateFormat(FULL_MONTH_STRING);
		
		Calendar taskDate = task.getStartCal();
		assertNotNull(taskDate);

		String monthFolder = monthStringFormat.format(taskDate.getTime());
		assertNotNull(monthFolder);
		assertFalse(monthFolder.isEmpty());

		logger.info(String.format(MESSAGE_MONTH_FOLDER_GET, monthFolder, task.getName()));

		return monthFolder;
	}
	
	/**
	 * Method to get the full file path for a specified task folder
	 * 
	 * @param folderName
	 *            the folder name inside our TNote directory
	 * @return File the file object with the full path to the specified folder.
	 */
	private File getFolderFile(String folderName) {
		return dirHandler.appendParentDirectory(folderName);
	}
	

	/**
	 * Method which adds a specified String as a child to a specified folder
	 * path
	 * 
	 * @param folder
	 *            the File object containing a folder path
	 * @param taskName
	 *            the String to be appended to the folder path
	 * @return File the File object containing a path to the taskName specified
	 */
	private File getFileDirectory(File folder, String taskName) {
		String textFileName = getTextFileName(taskName);
		return dirHandler.addDirectoryToFile(folder, textFileName);
	}

	/**
	 * Method to append .txt to the end of a taskName String. This allows the
	 * tasks to be created as text files in our system
	 * 
	 * @param taskName
	 *            the name of the task
	 * @return String the String taskName.txt
	 */
	private String getTextFileName(String taskName) {
		String textFileName = taskName + FILE_TYPE_TXT_FILE;
		return textFileName;
	}

	/**
	 * Method to retrieve a TaskFile object of a specified task name
	 * 
	 * @param taskName
	 *            the name of the TaskFile to retrieve
	 * @param folderMap
	 *            the Map{@code<String, String>} containing the folders
	 *            associated with each task
	 * @return TaskFile the TaskFile object representing the specified task name
	 * @throws IOException
	 *             I/O Error when reading from the text file
	 * @throws FileNotFoundException
	 *             the text file for the specified task cannot be found
	 * @throws ParseException
	 *             Error when setting the Calendar objects in the TaskFile
	 * @throws IncorrectTimeException
	 *             Error because the start and end time or dates in the TaskFile
	 *             is invalid
	 */
	protected TaskFile getTaskFileByName(String taskName, Map<String, String> folderMap)
			throws IOException, FileNotFoundException, ParseException, IncorrectTimeException {
		File fileToBeFound = getTaskFilePath(taskName, folderMap);

		TaskFile taskFile = readTaskTextFile(fileToBeFound);

		taskFile.setUpTaskFile();

		return taskFile;
	}

	/**
	 * Method to get the path to a specified task
	 * 
	 * @param taskName
	 *            the task name of a task
	 * @param folderMap
	 *            the Map{@code<String, String>} containing the folders
	 *            associated with each task
	 * @return File the File object containing the path to a task
	 * @throws FileNotFoundException
	 *             Error because the text file of the specified task cannot be
	 *             found
	 */
	private File getTaskFilePath(String taskName, Map<String, String> folderMap) throws FileNotFoundException {

		assertNotNull(taskName);
		String folderName = folderMap.get(taskName);

		if (folderName == null || checkInvalidFileName(folderName)) {
			String errorMessage = String.format(ERROR_TASK_NOT_EXIST, taskName);

			logger.warning(errorMessage);
			throw new FileNotFoundException(errorMessage);
		}

		File folder = getFolderFile(folderName);
		File fileToBeFound = getFileDirectory(folder, taskName);
		
		logger.info(String.format(MESSAGE_TASK_FOUND, fileToBeFound.getAbsolutePath()));
		return fileToBeFound;
	}
	
	/**
	 * Method to extract a Task File from a specified text file
	 * 
	 * @param textFileToBeRead
	 *            the text file to be read
	 * @return TaskFile the TaskFile object extracted from the text file
	 * @throws IOException
	 *             I/O Error reading the text file
	 */
	private TaskFile readTaskTextFile(File textFileToBeRead) throws IOException {
		return fRHandler.readTaskTextFile(textFileToBeRead);
	}
	
	/**
	 * Method to get all overdue tasks in the system. Tasks which do not get
	 * added into the list are either done, or the base object for a recurring
	 * task
	 * 
	 * @param masterList
	 *            the ArrayList{@code<String>} of all the tasks in the system
	 * @param folderMap
	 *            the Map{@code<String, String>} containing the folders for each
	 *            task
	 * @return ArrayList{@code<String>} the list of overdue tasks
	 * @throws IOException
	 *             I/O Error when reading from the text files
	 * @throws FileNotFoundException
	 *             a text file in the master list does not exist in the system
	 * @throws ParseException
	 *             Error when setting the Calendar objects for a TaskFile
	 * @throws IncorrectTimeException
	 *             Error because the start and end time or dates in a TaskFile
	 *             is invalid
	 */
	protected ArrayList<TaskFile> getOverdueTasks(ArrayList<String> masterList, Map<String, String> folderMap)
			throws IOException, FileNotFoundException, ParseException, IncorrectTimeException {

		Calendar currDateTime = Calendar.getInstance();
		ArrayList<TaskFile> listOfOverdueTasks = new ArrayList<TaskFile>();

		for (String taskName : masterList) {
			TaskFile task = getTaskFileByName(taskName, folderMap);
			
			if (task.getIsRecurring() || task.getIsDone()) {
				// Don't add as the task is done, or is the base file for a
				// recurring task
				logger.info(String.format(MESSAGE_NOT_OVERDUE, taskName));
				continue;
			}
			
			if (task.getIsMeeting()) {
				
				if (task.getEndCal().before(currDateTime)) {
					listOfOverdueTasks.add(task);
					logger.info(String.format(MESSAGE_OVERDUE, taskName));
					
				} else {
					logger.info(String.format(MESSAGE_NOT_OVERDUE, taskName));
				}
				
			} else if (task.getIsDeadline()) {
				
				if (task.getStartCal().before(currDateTime)) {
					listOfOverdueTasks.add(task);
					logger.info(String.format(MESSAGE_OVERDUE, taskName));
					
				} else {
					logger.info(String.format(MESSAGE_NOT_OVERDUE, taskName));
				}
				
			} else {
				assertTrue(task.getIsTask());
			}
		}

		logger.info(String.format(MESSAGE_ALL_OVERDUE_LIST, listOfOverdueTasks.toString()));
		return listOfOverdueTasks;
	}
	
	/**
	 * Method to check if the task name is valid. It checks against the
	 * requirements that most systems have for files created. If the name is
	 * empty, or above 260 characters, or contains illegal symbols, the name is
	 * considered invalid
	 * 
	 * @param taskName
	 *            the String to check against
	 * @return true if the name is invalid, false if it is valid
	 */
	protected boolean checkInvalidFileName(String taskName) {

		assertNotNull(taskName);
		if (taskName.isEmpty() || taskName.length() > MAXIMUM_FILE_PATH_LENGTH) {
			logger.warning(String.format(ERROR_TASK_NAME_INVALID, taskName));
			return true;
			
		} else {
			List<String> illegalFileCharacters = Arrays.asList(ILLEGAL_CHARACTERS);
			
			for (String illegalChar : illegalFileCharacters) {
				if (taskName.contains(illegalChar)) {
					logger.warning(String.format(ERROR_TASK_NAME_INVALID, taskName));
					return true;
				}
			}
			
			// The task name does not contain any illegal characters.
			logger.info(String.format(MESSAGE_TASK_NAME_VALID, taskName));
			return false;
		}
	}	
}
```
###### \src\tnote\storage\TaskHandlerTest.java
``` java
package tnote.storage;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.fail;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.Test;

import tnote.object.TaskFile;

public class TaskHandlerTest {
	TNotesStorage storage;
	TaskHandler tHandler;

	@Before
	public void setUp() throws Exception {
		storage = TNotesStorage.getInstance();
		storage.setUpStorage();
		storage.clearFiles();
		tHandler = TaskHandler.getInstance();
	}

	@After
	public void tearDown() throws Exception {
		System.out.println(storage.clearFiles());
	}

	@AfterClass
	public static void tearDownAfterClass() throws Exception {
		TNotesStorage storage = TNotesStorage.getInstance();
		System.out.println(storage.deleteMasterDirectory());
	}

	@Test
	public void testFileNameFolderNameAndCreateTask() {
		try {
			FileReadHandler fRHandler = FileReadHandler.getInstance();
			TaskFile testTaskJanuary = new TaskFile("testJan", "2016-1-10", "13:00", "2016-1-11", "11:00",
					"testDetails", true, false);

			TaskFile testTaskFebruary = new TaskFile("testFeb", "2016-2-10", "13:00", "2016-2-11", "11:00",
					"testDetails", false, false);

			TaskFile testTaskFloating = new TaskFile("testFloat");

			TaskFile testTaskRecur = new TaskFile("testRecur", "2016-4-10", "13:00", "2016-4-11", "11:00",
					"testDetails", false, true);

			// Test invalid name check
			assertFalse("valid name", tHandler.checkInvalidFileName("valid task name_1234"));
			assertTrue("invalid blank name", tHandler.checkInvalidFileName(""));
			assertTrue("invalid long name", tHandler.checkInvalidFileName(
					"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc"));
			assertTrue("invalid symbol name", tHandler.checkInvalidFileName("thisFI<LeIs?INVa\\/id:"));

			// Test retrieve folder name
			assertEquals("folder name january", "January", tHandler.retrieveFolderName(testTaskJanuary));
			assertEquals("folder name february", "February", tHandler.retrieveFolderName(testTaskFebruary));
			assertEquals("folder name floating", "floating", tHandler.retrieveFolderName(testTaskFloating));
			assertEquals("folder name recurring", "recurring", tHandler.retrieveFolderName(testTaskRecur));

			// Test create task
			assertTrue("jan task created", tHandler.createTaskFile("January", testTaskJanuary));
			File janFile = new File("C:\\TNote\\January\\testJan.txt");
			assertEquals("check jan task created properly", testTaskJanuary, fRHandler.readTaskTextFile(janFile));

			assertTrue("recur task created", tHandler.createTaskFile("recurring", testTaskRecur));
			File recurFile = new File("C:\\TNote\\recurring\\testRecur.txt");
			assertEquals("check recur task created properly", testTaskRecur, fRHandler.readTaskTextFile(recurFile));

			assertTrue("floating task created", tHandler.createTaskFile("floating", testTaskFloating));
			File floatFile = new File("C:\\TNote\\floating\\testFloat.txt");
			assertEquals("check float task created properly", testTaskFloating, fRHandler.readTaskTextFile(floatFile));

		} catch (Exception e) {
			fail("No Exception should be thrown for valid cases");
		}
	}

	@Test
	public void testGetDeleteTasks() {
		try {
			TaskFile testTaskJanuary = new TaskFile("testJan", "2016-1-10", "13:00", "2016-1-11", "11:00",
					"testDetails", true, false);

			TaskFile testTaskFebruary = new TaskFile("testFeb", "2016-2-10", "13:00", "2016-2-11", "11:00",
					"testDetails", false, false);
			testTaskFebruary.setIsDone(true);
			
			TaskFile testTaskMarch = new TaskFile("testMar", "2016-3-10", "13:00", "testDetails", false, false);
			
			TaskFile testTaskMay = new TaskFile("testMay", "2016-5-10", "13:00", "testDetails", false, false);
			
			TaskFile testTaskJune = new TaskFile("testJune", "2016-6-10", "13:00", "2016-6-11", "11:00",
					"testDetails", true, false);
			
			TaskFile testTaskFloating = new TaskFile("testFloat");
			TaskFile testTaskFloating2 = new TaskFile("testFloat2");

			TaskFile testTaskRecur = new TaskFile("testRecur", "2016-4-7", "13:00", "2016-4-8", "11:00",
					"testDetails", false, true);
			
			tHandler.createTaskFile("January", testTaskJanuary);
			tHandler.createTaskFile("February", testTaskFebruary);
			tHandler.createTaskFile("March", testTaskMarch);
			tHandler.createTaskFile("May", testTaskMay);
			tHandler.createTaskFile("June", testTaskJune);
			tHandler.createTaskFile("floating", testTaskFloating);
			tHandler.createTaskFile("floating", testTaskFloating2);
			tHandler.createTaskFile("recurring", testTaskRecur);
			
			Map<String, String> folderMapTest = new HashMap<String, String>();
			folderMapTest.put("testJan", "January");
			folderMapTest.put("testFeb", "February");
			folderMapTest.put("testMar", "March");
			folderMapTest.put("testMay", "May");
			folderMapTest.put("testJune", "June");
			folderMapTest.put("testFloat", "floating");
			folderMapTest.put("testFloat2", "floating");
			folderMapTest.put("testRecur", "recurring");
			
			ArrayList<String> dummyMaster = new ArrayList<String>();
			dummyMaster.add("testJan");
			dummyMaster.add("testFeb");
			dummyMaster.add("testMar");
			dummyMaster.add("testMay");
			dummyMaster.add("testJune");
			dummyMaster.add("testFloat");
			dummyMaster.add("testFloat2");
			dummyMaster.add("testRecur");
			
			//Test get overdue
			ArrayList<TaskFile> testOverdueList = new ArrayList<TaskFile> ();
			testOverdueList.add(testTaskJanuary);
			testOverdueList.add(testTaskMarch);			
			assertEquals("retrieve overdue list", testOverdueList, 
					tHandler.getOverdueTasks(dummyMaster, folderMapTest));
			
			//test delete task
			File janFile = new File("C:\\TNote\\January\\testJan.txt");
			assertTrue("january task exists at first", janFile.exists());
			assertTrue("delete jan task", tHandler.deleteTaskTextFile("testJan", folderMapTest));
			assertFalse("january task exists at first", janFile.exists());
			
			//test get task file by name
			assertEquals("get Feb task", testTaskFebruary, tHandler.getTaskFileByName("testFeb", folderMapTest));
			assertEquals("get floating task", testTaskFloating, 
					tHandler.getTaskFileByName("testFloat", folderMapTest));
			assertEquals("get recur task", testTaskRecur, tHandler.getTaskFileByName("testRecur", folderMapTest));
			
		} catch (Exception e) {
			fail("No Exception should be thrown for valid cases");
		}
	}
	
	@Test
	public void testNonExistentFolderName() {
		try {
		Map<String, String> folderMapTest = new HashMap<String, String>();
		tHandler.getTaskFileByName("non Existent", folderMapTest);
		} catch (Exception e) {
			assertEquals("Check exception class", FileNotFoundException.class, e.getClass());
			assertEquals("Check exception message", "non Existent does not exist", e.getMessage());
		}
	}

}
```
###### \src\tnote\storage\TNotesStorage.java
``` java
package tnote.storage;

import static org.junit.Assert.assertNotNull;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Logger;

import tnote.object.RecurringTaskFile;
import tnote.object.TaskFile;
import tnote.util.exceptions.IncorrectTimeException;
import tnote.util.exceptions.InvalidFileNameException;
import tnote.util.exceptions.TaskExistsException;
import tnote.util.log.TNoteLogger;

/**
 * This class manages how tasks are saved in T-Note.
 * 
 * It maintains a master list of all tasks saved, a list of folders in which
 * each task is stored, a list for tasks without timings (floating tasks), and a
 * list for recurring tasks.
 * 
 * It retrieves the necessary information about tasks and returns it to the
 * TNotesLogic class
 * 
 * Tasks can be saved or deleted, and tasks with similar names cannot be added.
 * 
 * Changing the directory of the saved location is supported as well.
 * 
 * @author A0124131B
 * 
 */
public class TNotesStorage {

	private static final String MESSAGE_DELETE_RECUR = "All instances of recurring task %s deleted";
	private static final String MESSAGE_RECUR_ADDED = "All recurring instances added for task %s";
	private static final String MESSAGE_RECUR_INSTANCE_READY = "Recurring instance %s set up";
	private static final String MESSAGE_CLASS_CREATED = "TNoteStorage setup complete";

	private static final String ERROR_TASK_NO_EXISTS = "%s does not exist";
	private static final String ERROR_DELETING_TASK = "Error deleting %s";
	private static final String ERROR_FAIL_ADD_BASE_RECUR = "Failed to add recurring task for %s";
	private static final String ERROR_FAIL_CREATE_WRITE_TASK = "Failed to create or write to text file for task %s";
	private static final String ERROR_TASK_REMOVED_BECAUSE = "Removed %s because of %s";
	private static final String ERROR_TASK_EXISTS_NO_PARAM = "Task already exists";
	private static final String ERROR_TASK_EXISTS_WITH_PARAM = "Task %s already exists";
	private static final String ERROR_FAIL_TO_ADD_TASK_TO_MASTERS = "Failed to add %s into master files";
	private static final String ERROR_INVALID_NAME = "Task name is invalid";

	private static final String RECUR_NAME_FORMAT = "%s_%s";

	private static final Logger logger = Logger.getGlobal();

	private static TNotesStorage instance;

	private MasterFileHandler mFileHandler;
	private TaskHandler taskHandler;
	private DirectoryHandler dirHandler;

	private ArrayList<String> masterList;
	private ArrayList<String> floatingList;

	private Map<String, String> folderMap;
	private Map<String, ArrayList<String>> recurStartDatMap;
	private Map<String, ArrayList<String>> recurEndDateMap;

	/**
	 * Private constructor for TNotesStorage. Initializes the necessary
	 * variables and class dependencies
	 * 
	 * @throws IOException
	 *             I/O Error when creating the master files
	 */
	private TNotesStorage() throws IOException {
		TNoteLogger.setUp();

		mFileHandler = MasterFileHandler.getInstance();
		taskHandler = TaskHandler.getInstance();
		dirHandler = DirectoryHandler.getInstance();

		masterList = new ArrayList<String>();
		floatingList = new ArrayList<String>();
		recurStartDatMap = new HashMap<String, ArrayList<String>>();
		recurEndDateMap = new HashMap<String, ArrayList<String>>();
		folderMap = new HashMap<String, String>();

		logger.info(MESSAGE_CLASS_CREATED);

	}

	/**
	 * Method to get an instance of TNotesStorage. If no instance exists, a new
	 * instance is created
	 * 
	 * @return TNotesStorage the instance of TNotesStorage
	 * @throws IOException
	 *             I/O error when creating the instance of TNotesStorage
	 */
	public static TNotesStorage getInstance() throws IOException {
		if (instance == null) {
			instance = new TNotesStorage();
		}
		return instance;
	}
	
	/**
	 * Method to set up all the necessary storage master files when needed
	 * @throws IOException I/O Error creating the master files
	 */
	public void setUpStorage() throws IOException {
		mFileHandler.setUpStorage();
	}
	
	/*---------------------------------Add Task-----------------------------------*/

	/**
	 * Method to add a specified TaskFile object into the system
	 * 
	 * @param task
	 *            the TaskFile object to add into the system
	 * @return true if the TaskFile object is successfully saved to the system
	 * @throws IOException
	 *             I/O Error when saving the TaskFile as a text file
	 * @throws TaskExistsException
	 *             Error when a task with the same name already exists
	 * @throws InvalidFileNameException
	 *             Error when the specified task will create a text file with an
	 *             invalid name
	 */
	public boolean addTask(TaskFile task) 
			throws IOException, TaskExistsException, InvalidFileNameException {
		try {
			String taskName = task.getName();

			if (taskHandler.checkInvalidFileName(taskName)) {
				throw new InvalidFileNameException(ERROR_INVALID_NAME, taskName);
			}

			masterList = readFromMasterFile();

			if (!checkIfTaskExists(taskName)) {
				masterList.add(taskName);

				folderMap = readFolderMap();
				String monthFolder = taskHandler.retrieveFolderName(task);

				if (addTaskToMasterFile(taskName) && addTaskToFolderMap(taskName, monthFolder)) {
					return createTaskFile(task, taskName, monthFolder);
				} else {

					logger.warning(String.format(ERROR_FAIL_TO_ADD_TASK_TO_MASTERS, taskName));
					removeTaskFromMasterFiles(taskName);
					return false;
				}

			} else {
				logger.warning(String.format(ERROR_TASK_EXISTS_WITH_PARAM, taskName));
				throw new TaskExistsException(ERROR_TASK_EXISTS_NO_PARAM, taskName);
			}
		} catch (IOException ioEx) {
			removeTaskFromMasterFiles(task.getName());
			logger.warning(String.format(ERROR_TASK_REMOVED_BECAUSE, task.getName(), ioEx.getMessage()));

			throw ioEx;
		}
	}

	/**
	 * Method which creates the text file associated with a TaskFile object
	 * 
	 * @param task
	 *            the TaskFile object to create a text file of
	 * @param taskName
	 *            the name of the task
	 * @param monthFolder
	 *            the folder which the text file should be saved in
	 * @return true if the text file is successfully created
	 * @throws IOException
	 *             I/O Error when creating the text file for the task
	 */
	private boolean createTaskFile(TaskFile task, String taskName, String monthFolder) throws IOException {

		if (taskHandler.createTaskFile(monthFolder, task)) {

			if (task.getIsTask()) {
				return addToFloatingTaskList(taskName);
			} else {
				return true;
			}

		} else {
			logger.warning(String.format(ERROR_FAIL_CREATE_WRITE_TASK, taskName));
			removeTaskFromMasterFiles(taskName);
			return false;
		}
	}

	/**
	 * Method to add a recurring task with a specified set of dates into the
	 * system
	 * 
	 * @param newRecurringTask
	 *            the Object containing all necessary information about the task
	 *            and the dates it recurs
	 * @return true if the task is successfully added to the system
	 * @throws IOException
	 *             I/O Error when create a text file associated with the task
	 * @throws ParseException
	 *             Error parsing the date and time for individual instances of
	 *             the task
	 * @throws IncorrectTimeException
	 *             Error because the end date and time of the task is before its
	 *             start date and time
	 * @throws InvalidFileNameException
	 *             Error when the task name specified will create a text file
	 *             with an invalid name
	 * @throws TaskExistsException
	 *             Error when a task with a similar name already exists in the
	 *             system
	 */
	public boolean addRecurringTask(RecurringTaskFile newRecurringTask)
			throws IOException, ParseException, IncorrectTimeException,
			InvalidFileNameException, TaskExistsException {

		String taskName = newRecurringTask.getName();
		ArrayList<String> recurringStartDates = newRecurringTask.getListOfRecurStartDates();
		ArrayList<String> recurringEndDates = newRecurringTask.getListOFRecurEndDates();

		if (addTask(newRecurringTask)) {

			int dateCount = 0;
			for (String startDate : recurringStartDates) {
				TaskFile task = newRecurringTask;
				task.setStartDate(startDate);

				if (newRecurringTask.getIsMeeting()) {
					String endDate = recurringEndDates.get(dateCount++);
					task.setEndDate(endDate);
				}

				task.setIsRecurr(false);
				task.setName(String.format(RECUR_NAME_FORMAT, taskName, startDate));
				task.setUpTaskFile();

				logger.info(String.format(MESSAGE_RECUR_INSTANCE_READY, task.getName()));
				addTask(task);
			}

			addToRecurStartDateMap(recurringStartDates, taskName);

			if (newRecurringTask.getIsMeeting()) {
				addToEndDateMap(recurringEndDates, taskName);
			}

			logger.info(String.format(MESSAGE_RECUR_ADDED, taskName));
			return true;
		}

		logger.warning(String.format(ERROR_FAIL_ADD_BASE_RECUR, taskName));
		return false;
	}

	/*------------------------------Delete Task-------------------------------------*/
	/**
	 * Method to delete a task with a specified task name
	 * 
	 * @param taskName
	 *            the name of the task to delete
	 * @return TaskFile the TaskFile object containing the information about the
	 *         deleted task
	 * @throws IOException
	 *             I/O Error when accessing the text file for the specified task
	 * @throws IncorrectTimeException
	 *             Error because the end date and time of the specified task is
	 *             before its start date and time
	 * @throws FileNotFoundException
	 *             Error when the specified task cannot be found in the system
	 * @throws ParseException
	 *             Error parsing the date and time of the specified task
	 * @throws InvalidFileNameException
	 *             Error when the specified task name contains invalid file
	 *             characters
	 */
	public TaskFile deleteTask(String taskName) 
			throws IOException, IncorrectTimeException, FileNotFoundException,
			ParseException, InvalidFileNameException {

		taskName = removeWhiteSpace(taskName);

		if (taskHandler.checkInvalidFileName(taskName)) {
			throw new InvalidFileNameException(ERROR_INVALID_NAME, taskName);
		}

		TaskFile taskToBeDeleted = getTaskFileByName(taskName);
		folderMap = readFolderMap();

		if (taskHandler.deleteTaskTextFile(taskName, folderMap)) {
			removeTaskFromMasterFiles(taskName);

			if (taskToBeDeleted.getIsTask()) {
				removeFromFloatingMasterFile(taskName);
			}

			return taskToBeDeleted;
		} else {
			throw new IOException(String.format(ERROR_DELETING_TASK, taskName));
		}
	}

	/**
	 * Method to delete all instances of a specified recurring task
	 * 
	 * @param taskName
	 *            the name of the recurring task to delete
	 * @return TaskFile the TaskFile object containing the information about the
	 *         deleted task
	 * @throws IOException
	 *             I/O Error when accessing the text file associated with the
	 *             specified task
	 * @throws IncorrectTimeException
	 *             Error because the end date and time of the specified task is
	 *             before its start date and time
	 * @throws FileNotFoundException
	 *             Error when the specified task cannot be found in the system
	 * @throws ParseException
	 *             Error parsing the date and time of the specified task
	 * @throws InvalidFileNameException
	 *             Error when the specified task name contains invalid file
	 *             characters
	 */
	public TaskFile deleteRecurringTask(String taskName)
			throws IOException, IncorrectTimeException,	FileNotFoundException,
			ParseException, InvalidFileNameException {

		taskName = removeWhiteSpace(taskName);

		if (taskHandler.checkInvalidFileName(taskName)) {
			throw new InvalidFileNameException(ERROR_INVALID_NAME, taskName);
		}

		recurStartDatMap = readRecurStartDateMap();
		recurEndDateMap = readRecurEndDateMap();

		TaskFile deletedTask = getTaskFileByName(taskName);
		String deleteRecurringTaskName = deletedTask.getName();

		ArrayList<String> startDates = recurStartDatMap.get(deleteRecurringTaskName);

		for (String dates : startDates) {
			String singleRecurTaskName = String.format(RECUR_NAME_FORMAT, deleteRecurringTaskName, dates);
			deleteTask(singleRecurTaskName);
		}

		removeFromRecurringStartDateMap(taskName);

		if (deletedTask.getIsMeeting()) {
			removeFromRecurringEndDateMap(taskName);
		}

		logger.info(String.format(MESSAGE_DELETE_RECUR, taskName));
		return deleteTask(taskName);

	}

	/**
	 * Method to clear all files in storage
	 * 
	 * @return true if all files have been cleared
	 * @throws IOException
	 *             I/O Error when deleting or clearing files in the system
	 */
	public boolean clearFiles() throws IOException {
		return mFileHandler.clearMasterFile();
	}

	/*------------------------------Directories------------------------------------*/

	/**
	 * Method to delete all files inside a specified directory in the system
	 * 
	 * @param directory
	 *            the name of the directory to delete all files
	 * @return true if the directory is deleted
	 * @throws IOException
	 *             I/O Error when deleting the directory
	 */
	public boolean clearDirectory(String directory) throws IOException {
		return dirHandler.clearChildDirectory(directory);
	}

	/**
	 * Method to delete all storage files and folders
	 * 
	 * @return true if all files and folders have been deleted
	 * @throws IOException
	 *             I/O Error when deleting files and folders
	 */
	public boolean deleteMasterDirectory() throws IOException {
		return dirHandler.deleteMasterDirectory();
	}

	/**
	 * Method to delete all files inside a specified directory in the system and
	 * the directory itself
	 * 
	 * @param directory
	 *            the name of the directory to be deleted
	 * @return true if the directory is deleted
	 * @throws IOException
	 *             I/O Error when deleting the directory
	 */
	public boolean deleteDirectory(String directory) throws IOException {
		return dirHandler.deleteChildDirectory(directory);
	}

	/**
	 * Method to change the directory of all storage files
	 * 
	 * @param newDirectory
	 *            the new directory to change to
	 * @return true if the directory has been successfully changed
	 * @throws IOException
	 *             I/O Error when changing directories
	 */
	public boolean setNewDirectory(String newDirectory) throws IOException {
		assertNotNull(newDirectory);

		newDirectory = removeWhiteSpace(newDirectory);
		if (dirHandler.setNewDirectory(newDirectory)) {
			mFileHandler.setUpStorage();
			return true;
		} else {
			return false;
		}

	}

	/**
	 * Method to retrieve the current parent directory String
	 * 
	 * @return String the current parent directory String
	 */
	public String getParentDirectory() {
		File parentDirectory = dirHandler.getParentDirectory();
		String parentDirectoryString = parentDirectory.getAbsolutePath();

		return parentDirectoryString;
	}

	/*--------------------------------Get Task--------------------------------------*/
	/**
	 * Method to retrieve a TaskFile object associated with a specified task
	 * name
	 * 
	 * @param taskName
	 *            the name of the TaskFile object to retrieve
	 * @return TaskFile the TaskFile object retrieved
	 * @throws IOException
	 *             I/O Error when reading the text file associated with the task
	 *             name
	 * @throws IncorrectTimeException
	 *             Error when the end date and time of the task is before the
	 *             start date and time
	 * @throws FileNotFoundException
	 *             Error when the specified task name cannot be found in the
	 *             system
	 * @throws ParseException
	 *             Error when parsing the date and time for the specified task
	 *             name
	 */
	public TaskFile getTaskFileByName(String taskName)
			throws IOException, IncorrectTimeException, FileNotFoundException, ParseException {

		taskName = removeWhiteSpace(taskName);
		masterList = readFromMasterFile();

		if (!checkIfTaskExists(taskName)) {
			String errorMessage = String.format(ERROR_TASK_NO_EXISTS, taskName);
			logger.warning(errorMessage);
			throw new FileNotFoundException(errorMessage);
		}

		folderMap = readFolderMap();

		TaskFile taskFile = taskHandler.getTaskFileByName(taskName, folderMap);

		return taskFile;

	}

	/**
	 * Method to retrieve all overdue tasks in the system
	 * 
	 * @return ArrayList{@code<String>} the list of TaskFile objects
	 *         representing the overdue tasks
	 * @throws IOException
	 *             I/O Error when reading the text files associated with the
	 *             TaskFiles
	 * @throws IncorrectTimeException
	 *             Error when a TaskFile object has a end date and time before
	 *             its start date and time
	 * @throws FileNotFoundException
	 *             Error when a task in the master list does not have an
	 *             associated text file
	 * @throws ParseException
	 *             Error when parsing the date and time for a task
	 */
	public ArrayList<TaskFile> retrieveOverdueTasks()
			throws IOException, IncorrectTimeException, FileNotFoundException, ParseException {
		masterList = readFromMasterFile();
		folderMap = readFolderMap();
		ArrayList<TaskFile> listOfOverdueTasks = taskHandler.getOverdueTasks(masterList, folderMap);

		return listOfOverdueTasks;
	}

	/* ------------------------Read From Files ------------------------------ */
	/**
	 * Method to get the list of tasks current saved in the system
	 * 
	 * @return ArrayList{@code<String>} the list of names of tasks saved in the
	 *         system
	 * @throws IOException
	 *             I/O Error when reading from the master list
	 */
	public ArrayList<String> readFromMasterFile() throws IOException {
		return mFileHandler.readFromMasterFile();
	}

	/**
	 * Method to get the list of floating tasks in the system
	 * 
	 * @return ArrayList{@code<String>} the list of names of floating tasks
	 *         saved in the system
	 * @throws IOException
	 *             I/O Error when reading from the floating list file
	 */
	public ArrayList<String> readFromFloatingFile() throws IOException {
		return mFileHandler.readFromFloatingFile();
	}

	/**
	 * Method to get the Map containing the list of start dates for each
	 * recurring task
	 * 
	 * @return Map{@code<String, ArrayList<String>>} the Map object containing
	 *         all the start dates associated with each recurring task
	 * @throws IOException
	 *             I/O Error when reading from the recurring start date text
	 *             file
	 */
	private Map<String, ArrayList<String>> readRecurStartDateMap() throws IOException {
		return mFileHandler.readRecurStartDateMap();
	}

	/**
	 * Method to get the Map containing the list of end dates for each recurring
	 * task
	 * 
	 * @return Map{@code<String, ArrayList<String>>} the Map object containing
	 *         all the end dates associated with each recurring task
	 * @throws IOException
	 *             I/O Error when reading from the recurring end date text file
	 */
	private Map<String, ArrayList<String>> readRecurEndDateMap() throws IOException {
		return mFileHandler.readRecurEndDateMap();
	}

	/**
	 * Method to get the Map containing the folder name for each task
	 * 
	 * @return Map{@code<String, String>} the Map object containing all the
	 *         folder names associated with each task
	 * @throws IOException
	 *             I/O Error when reading from the folder map file
	 */
	private Map<String, String> readFolderMap() throws IOException {
		return mFileHandler.readFromFolderMap();
	}

	/*----------------------Get date lists for recurring tasks----------------*/

	/**
	 * Method to retrieve all the start dates associated with a specified
	 * recurring task from the recurring tasks start date map
	 * 
	 * @param taskName
	 *            the name of the task to get all the starting dates of
	 * @return ArrayList{@code<String>} the list of start dates for the
	 *         specified task
	 */
	public ArrayList<String> getRecurTaskStartDateList(String taskName) {
		return recurStartDatMap.get(taskName);
	}

	/**
	 * Method to retrieve all the end dates associated with a specified
	 * recurring task from the recurring tasks end date map
	 * 
	 * @param taskName
	 *            the name of the task to get all the end dates of
	 * @return ArrayList{@code<String>} the list of end dates for the specified
	 *         task
	 */
	public ArrayList<String> getRecurTaskEndDateList(String taskName) {
		return recurEndDateMap.get(taskName);
	}

	/*-----------------------Adding to master files --------------------------*/

	/**
	 * Method to append a task name to the master file list
	 * 
	 * @param taskName
	 *            the name of the task to append to the master file
	 * @return true if the name has been successfully appended to the master
	 *         file
	 * @throws IOException
	 *             I/O Error when writing to the master file
	 */
	private boolean addTaskToMasterFile(String taskName) throws IOException {
		return mFileHandler.appendTaskToMasterListFile(taskName);
	}

	/**
	 * Method to add a specified task and folder pairing into the folder map
	 * file
	 * 
	 * @param taskName
	 *            the name of the task
	 * @param monthString
	 *            the name of the folder for the specified task
	 * @return true if the new entry has been successfully added to the folder
	 *         map file
	 * @throws IOException
	 *             I/O Error when writing to the folder map file
	 */
	private boolean addTaskToFolderMap(String taskName, String monthString) throws IOException {
		folderMap.put(taskName, monthString);
		return mFileHandler.writeToMonthMapFile(folderMap);
	}

	/**
	 * Method to append a task name to the floating file list
	 * 
	 * @param taskName
	 *            the name of the task to append to the floating list file
	 * @return true if the name has been successfully appended to the floating
	 *         list file
	 * @throws IOException
	 *             I/O Error when writing to the floating list file
	 */
	private boolean addToFloatingTaskList(String taskName) throws IOException {
		floatingList.add(taskName);
		return mFileHandler.appendTaskToFloatingListFile(taskName);
	}

	/**
	 * Method to add the name of a recurring task and its associated end dates
	 * into the recurring tasks end date map file
	 * 
	 * @param recurringEndDates
	 *            the list of end dates for the specified task
	 * @param taskName
	 *            the name of the task
	 * @throws IOException
	 *             I/O Error when writing to the recurring tasks end date map
	 *             file
	 */
	private void addToEndDateMap(ArrayList<String> recurringEndDates, String taskName) throws IOException {
		recurEndDateMap = readRecurEndDateMap();
		recurEndDateMap.put(taskName, recurringEndDates);
		mFileHandler.writeToRecurringEndDateMap(recurEndDateMap);
	}

	/**
	 * Method to add the name of a recurring task and its associated start dates
	 * into the recurring tasks start date map file
	 * 
	 * @param recurringStartDates
	 *            the list of start dates for the specified task
	 * @param taskName
	 *            the name of the task
	 * @throws IOException
	 *             I/O Error when writing to the recurring tasks start date map
	 *             file
	 */
	private void addToRecurStartDateMap(ArrayList<String> recurringStartDates, String taskName) 
			throws IOException {
		recurStartDatMap = readRecurStartDateMap();
		recurStartDatMap.put(taskName, recurringStartDates);
		mFileHandler.writeToRecurringStartDateMap(recurStartDatMap);
	}

	/*----------------------Deleting from master files--------------------------*/

	/**
	 * Method to remove a specified task name from the floating list file
	 * 
	 * @param taskName
	 *            the name of the task to remove from the floating list file
	 * @throws IOException
	 *             I/O Error when writing to the floating list file
	 */
	private void removeFromFloatingMasterFile(String taskName) throws IOException {
		floatingList = readFromFloatingFile();
		floatingList.remove(taskName);
		mFileHandler.writeToFloatingListFile(floatingList);
	}

	/**
	 * Metohd to remove a specified task name from the master list file and the
	 * folder map file
	 * 
	 * @param taskName
	 *            the name of a task to remove from both files
	 * @throws IOException
	 *             I/O Error writing to either file
	 */
	private void removeTaskFromMasterFiles(String taskName) throws IOException {
		masterList.remove(taskName);
		mFileHandler.writeToMasterListFile(masterList);
		folderMap.remove(taskName);
		mFileHandler.writeToMonthMapFile(folderMap);
	}

	/**
	 * Method to remove a specified task name from the recurring tasks end date
	 * map file
	 * 
	 * @param taskName
	 *            the name of the task to remove from the recurring tasks end
	 *            date map file
	 * @throws IOException
	 *             I/O Error writing to the recurring tasks end date map file
	 */
	private void removeFromRecurringEndDateMap(String taskName) throws IOException {
		recurEndDateMap.remove(taskName);
		mFileHandler.writeToRecurringEndDateMap(recurEndDateMap);
	}

	/**
	 * Method to remove a specified task name from the recurring tasks start
	 * date map file
	 * 
	 * @param taskName
	 *            the name of the task to remove from the recurring tasks start
	 *            date map file
	 * @throws IOException
	 *             I/O Eror writing to the recurring tasks start date map file
	 */
	private void removeFromRecurringStartDateMap(String taskName) throws IOException {
		recurStartDatMap.remove(taskName);
		mFileHandler.writeToRecurringStartDateMap(recurStartDatMap);
	}

	/*---------------------------------Misc------------------------------------------*/

	/**
	 * Method to remove any trailing whitespaces in a specified task name String
	 * 
	 * @param taskName
	 *            the String to remove any trailing whitespaces
	 * @return String the specified String without any trailing whitespaces
	 */
	private String removeWhiteSpace(String taskName) {
		return taskName.trim();
	}

	/**
	 * Method to check if a specified task name already exists in the system
	 * 
	 * @param taskName
	 *            the name of the task to check
	 * @return true if the task already exists in the system
	 */
	private boolean checkIfTaskExists(String taskName) {
		return masterList.contains(taskName);
	}

}
```
###### \src\tnote\storage\TNotesStorageTest.java
``` java
package tnote.storage;

import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.fail;
import static org.junit.Assert.assertNull;

import java.io.File;
import java.util.ArrayList;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.Test;

import tnote.object.RecurringTaskFile;
import tnote.object.TaskFile;
import tnote.util.exceptions.InvalidFileNameException;
import tnote.util.exceptions.TaskExistsException;

public class TNotesStorageTest {

	TNotesStorage storage;

	@Before
	public void setUp() throws Exception {

		storage = TNotesStorage.getInstance();
		storage.setUpStorage();
		storage.clearFiles();

	}

	@After
	public void tearDown() throws Exception {
		System.out.println(storage.clearFiles());
	}

	@AfterClass
	public static void tearDownClass() throws Exception {
		TNotesStorage storage = TNotesStorage.getInstance();
		System.out.println(storage.deleteMasterDirectory());
	}
	@Test
	public void testAdd() {
		try {
			TaskFile task1 = new TaskFile("call mom", "2016-02-02", "12:00", "abc", false, false);
			TaskFile task2 = new TaskFile("call dad");
			TaskFile task3 = new TaskFile("call bro", "2016-03-02", "11:00", "2016-03-04", "10:00",
					"abc", false, false);
			task3.setIsDone(true);
			
			//Test add
			assertTrue("adding task 1", storage.addTask(task1));
			assertTrue("adding task 2", storage.addTask(task2));
			
			FileReadHandler fRHandler = FileReadHandler.getInstance();
			File task1File = new File("C:\\TNote\\February\\call mom.txt");
			assertEquals("check if task added properly", task1, fRHandler.readTaskTextFile(task1File));
			
			File task2File = new File("C:\\TNote\\floating\\call dad.txt");
			assertEquals("check if task added properly", task2, fRHandler.readTaskTextFile(task2File));
		
			
			//test read from master file
			ArrayList<String> masterFileAL = new ArrayList<String>();
			masterFileAL.add("call mom");
			masterFileAL.add("call dad");
			assertEquals("read from master file", masterFileAL, storage.readFromMasterFile());

			
			//test getTaskFileByName
			assertEquals("read individual task files_1", task1, storage.getTaskFileByName("call mom"));
			assertEquals("read individual task files_2", task2, storage.getTaskFileByName("call dad"));
			
			
			//Test get overdue list
			storage.addTask(task3);
			ArrayList<TaskFile> overdueTasks = new ArrayList<TaskFile>();
			overdueTasks.add(task1);
			assertEquals("get overdue tasks", overdueTasks, storage.retrieveOverdueTasks());
			
			
			//Test read from floating list
			ArrayList<String> testFloatingList = new ArrayList<String>();
			TaskFile task4 = new TaskFile("floatTask again");
			storage.addTask(task4);
			
			testFloatingList.add("call dad");
			testFloatingList.add("floatTask again");
			
			assertEquals("get floating list", testFloatingList, storage.readFromFloatingFile());
			
			
			//Test delete
			assertEquals("delete deadline task", task1, storage.deleteTask("call mom"));
			assertFalse("deadline task deleted, does not exist", task1File.exists());
			
			assertEquals("delete floating task", task2, storage.deleteTask("call dad"));
			assertFalse("floating task deleted, does not exist", task2File.exists());
			
			//Test clear files
			File task3File = new File("C:\\TNote\\March\\call bro.txt");
			assertTrue("check for existing files", task3File.exists());
			
			assertTrue("clear all files", storage.clearFiles());
			assertFalse("check for existing files", task3File.exists());
			
			
		} catch (Exception e) {
			fail("No exception should be thrown for valid cases");
		}
	}

	@Test
	public void testRecurring() {

		try {

			TaskFile task1 = new TaskFile();
			task1.setName("walk dog");
			task1.setStartDate("2016-02-02");
			task1.setStartTime("12:00");
			task1.setDetails("abc");
			task1.setIsRecurr(true);
			task1.setUpTaskFile();
			
			TaskFile task2 = new TaskFile();
			task2.setName("eat dinner");
			task2.setStartDate("2016-02-03");
			task2.setStartTime("11:00");
			task2.setEndDate("2016-02-04");
			task2.setEndTime("13:00");
			task2.setIsRecurr(true);
			
			task2.setUpTaskFile();

			ArrayList<String> startDates = new ArrayList<String>();
			startDates.add("2016-02-02");
			startDates.add("2016-02-03");
			startDates.add("2016-02-04");
			
			
			ArrayList<String> startDates2 = new ArrayList<String>();
			startDates2.add("2016-02-03");
			startDates2.add("2016-02-04");
			startDates2.add("2016-02-05");
			startDates2.add("2016-02-06");
			
			ArrayList<String> endDates2 = new ArrayList<String>();
			endDates2.add("2016-02-04");
			endDates2.add("2016-02-05");
			endDates2.add("2016-02-06");
			endDates2.add("2016-02-07");
			
			RecurringTaskFile rTask1 = new RecurringTaskFile(task1);
			rTask1.addRecurringStartDate(startDates);
			
			
			RecurringTaskFile rTask2 = new RecurringTaskFile(task2);
			rTask2.addRecurringStartDate(startDates2);
			rTask2.addRecurringEndDate(endDates2);
			
			
			//Test add recur
			assertTrue(storage.addRecurringTask(rTask1));
			assertTrue(storage.addRecurringTask(rTask2));
			
			assertEquals("Check base recur object added", task1, storage.getTaskFileByName("walk dog"));
			
			TaskFile task2Instance = new TaskFile();
			task2Instance.setName("eat dinner_2016-02-04");
			task2Instance.setStartDate("2016-02-04");
			task2Instance.setStartTime("11:00");
			task2Instance.setEndDate("2016-02-05");
			task2Instance.setEndTime("13:00");
			task2Instance.setIsRecurr(false);
			
			task2Instance.setUpTaskFile();
			
			assertEquals("Check recur instance added", task2Instance, 
					storage.getTaskFileByName("eat dinner_2016-02-04"));
			File recurInstanceFile = new File("C:\\TNote\\February\\eat dinner_2016-02-04.txt");
			assertTrue("Check if instance text file exists", recurInstanceFile.exists());
			
			//Test get recur start date list
			assertEquals("check recur start date list", startDates, storage.getRecurTaskStartDateList("walk dog"));
			
			assertEquals("check recur start date list2", startDates2, 
					storage.getRecurTaskStartDateList("eat dinner"));
			
			//Test get recur end date list
			assertNull("get non existent end date list", storage.getRecurTaskEndDateList("walk dog"));
			assertEquals("check recur end date list2", endDates2, storage.getRecurTaskEndDateList("eat dinner"));
			
			//Test delete recur
			assertEquals("Check deleted recur base object", task2, storage.deleteRecurringTask("eat dinner"));
			assertFalse("Instance text file should be deleted", recurInstanceFile.exists());
			
		} catch (Exception e) {
			fail("No Exception should be thrown for valid cases");
		}
	}
	
	@Test
	public void testDirectoryMethods() {
		try {
		TaskFile task1 = new TaskFile("call mom", "2016-02-02", "12:00", "abc", false, false);
		TaskFile task2 = new TaskFile("call dad");
		TaskFile task3 = new TaskFile("call bro", "2016-03-02", "11:00", "2016-03-04", "10:00",
				"abc", false, false);
		storage.addTask(task1);
		storage.addTask(task2);
		storage.addTask(task3);
		
		//test get parent directory
		assertEquals("get parent directory string", "C:\\TNote", storage.getParentDirectory());
		
		//test clear files
		ArrayList<String> emptyList = new ArrayList<String>();
		assertNotEquals("check master list not empty", emptyList, storage.readFromMasterFile());
		
		assertTrue("clear all files", storage.clearFiles());
		assertEquals("check master list is empty", emptyList, storage.readFromMasterFile());
		
		storage.addTask(task1);
		storage.addTask(task2);
		storage.addTask(task3);
		
		//test clear directory
		File februaryFolder = new File("C:\\TNote\\February");
		assertTrue("check folder exists", februaryFolder.exists());
		assertNotEquals("check folder directory not empty", 0, februaryFolder.listFiles().length);
		
		assertTrue("check clear directory", storage.clearDirectory("February"));
		assertTrue("check folder not deleted", februaryFolder.exists());
		assertEquals("check folder directory empty", 0, februaryFolder.listFiles().length);
		
		//test delete directory
		File marFolder = new File("C:\\TNote\\March");
		assertTrue("check folder exists", marFolder.exists());
		assertNotEquals("check folder directory not empty", 0, marFolder.listFiles().length);
		
		assertTrue("check delete directory", storage.deleteDirectory("March"));
		assertFalse("folder no longer exists", marFolder.exists());
		
		//test delete master directory
		File defaultFolder = new File("C:\\TNote\\overview");
		assertTrue("check default folder exists", defaultFolder.exists());
		assertTrue("delete master directory", storage.deleteMasterDirectory());
		
		assertFalse("check default folder no longer exists", defaultFolder.exists());
		
		MasterFileHandler mFHandler = MasterFileHandler.getInstance();
		mFHandler.setUpStorage();
		
		//test set new directory
		storage.addTask(task1);
		storage.addTask(task2);
		storage.addTask(task3);
		assertTrue("check default folder exists", defaultFolder.exists());
		assertTrue(storage.setNewDirectory("C:\\newTNoteFolder"));
		
		assertFalse("check default folder does not exists anymore", defaultFolder.exists());
		defaultFolder = new File("C:\\newTNoteFolder\\overview");
		assertTrue("check default folder in new path exists", defaultFolder.exists());
		assertEquals("check if get task file still works", task1, storage.getTaskFileByName("call mom"));
		
		assertEquals("check get parent dirctory", "C:\\newTNoteFolder", storage.getParentDirectory());
		storage.setNewDirectory("C:\\TNote");
		
		} catch (Exception e) {
			fail("No Exceptions should be thrown for valid cases");
		}
	}
	
	@Test
	public void testAddTaskException() {
		try {
			TaskFile task2 = new TaskFile("call dad");
			storage.addTask(task2);
			//Add again to get TaskExistsException
			storage.addTask(task2);
			
			fail("Exception should be thrown when adding a task that already exists");
		} catch (Exception e) {
			assertEquals("Check exception class", TaskExistsException.class, e.getClass());
			assertEquals("Check error message", "Task already exists for task: call dad", e.getMessage());
		}
		
		try {
			TaskFile task3 = new TaskFile();
			storage.addTask(task3);
			fail("Empty task name should throw an exception");
		} catch (Exception e) {
			assertEquals("Check exception class", InvalidFileNameException.class, e.getClass());
			assertEquals("Check error message", "Task name is invalid for: ", e.getMessage());
		}
	}
	
	@Test
	public void testDeleteExceptions() {
		try {
			storage.deleteTask("");
			fail("Exception should be thrown when deleting a invalid string");
		} catch (Exception e) {
			assertEquals("Check exeption class", InvalidFileNameException.class, e.getClass());
			assertEquals("Check exception message", "Task name is invalid for: ", e.getMessage());
		}
		
		try {
			storage.deleteRecurringTask("");
			fail("Exception should be thrown when deleting a invalid string");
		} catch (Exception e) {
			assertEquals("Check exeption class", InvalidFileNameException.class, e.getClass());
			assertEquals("Check exception message", "Task name is invalid for: ", e.getMessage());
		}
	}

}
```
###### \src\tnote\util\exceptions\IncorrectTimeException.java
``` java
package tnote.util.exceptions;

/**
 * This class is a custom exception thrown when the ending date and time of a
 * task is before its starting date and time.
 * 
 * @author A0124131B
 *
 */
public class IncorrectTimeException extends Exception {

	private static final String ERROR_MESSAGE_FORMAT = "%s for task: %s";
	private static final long serialVersionUID = 7622927942739365055L;
	private String taskName;

	/**
	 * Basic constructor for IncorrectTimeException
	 */
	public IncorrectTimeException() {
		super();
	}

	/**
	 * Constructor with a message String and the name of the task which caused
	 * the exception
	 * 
	 * @param message
	 *            the message to be displayed
	 * @param taskName
	 *            the name of the task which caused the exception
	 */
	public IncorrectTimeException(String message, String taskName) {
		super(message);
		this.taskName = taskName;
	}

	/**
	 * Constructor with a message String, the name of the task which caused the
	 * exception and the stack trace to the cause of the exception
	 * 
	 * @param message
	 *            the message to be displayed
	 * @param taskName
	 *            the name of the task which caused the exception
	 * @param cause
	 *            the stack trace to the IncorrectTimeException
	 */
	public IncorrectTimeException(String message, String taskName, Throwable cause) {
		super(message, cause);
		this.taskName = taskName;
	}

	@Override
	public String toString() {
		return super.toString();
	}

	@Override
	public String getMessage() {
		return String.format(ERROR_MESSAGE_FORMAT, super.getMessage(), taskName);
		
	}
}
```
###### \src\tnote\util\exceptions\InvalidFileNameException.java
``` java
package tnote.util.exceptions;

/**
 * This class is a custom exception which is thrown when a task with an invalid
 * file name is attempted to be saved in the system
 * 
 * @author A0124131B
 *
 */
public class InvalidFileNameException extends Exception {

	private static final long serialVersionUID = -3104981170545272792L;
	private static final String ERROR_MESSAGE_FORMAT = "%s for: %s";
	private String taskName;

	/**
	 * Basic constructor for the InvalidFileNameException
	 */
	public InvalidFileNameException() {
		super();
	}

	/**
	 * Constructor with a message String and the name of the task which caused
	 * the exception
	 * 
	 * @param message
	 *            the message to be displayed
	 * @param taskName
	 *            the name of the task which caused the exception
	 */
	public InvalidFileNameException(String message, String taskName) {
		super(message);
		this.taskName = taskName;
	}

	/**
	 * 
	 * Constructor with a message String, the name of the task which caused the
	 * exception and the stack trace to the cause of the exception
	 * 
	 * @param message
	 *            the message to be displayed
	 * @param taskName
	 *            the name of the task which caused the exception
	 * @param cause
	 *            the stack trace to the InvalidFileNameException
	 */
	public InvalidFileNameException(String message, String taskName, Throwable cause) {
		super(message, cause);
		this.taskName = taskName;
	}

	@Override
	public String toString() {
		return super.toString();
	}

	@Override
	public String getMessage() {
		return String.format(ERROR_MESSAGE_FORMAT, super.getMessage(), taskName);
	}
}
```
###### \src\tnote\util\exceptions\TaskExistsException.java
``` java
package tnote.util.exceptions;

/**
 * This class is a custom exception which is thrown when the user tries to add a
 * task which already exists in the system
 * 
 * @author A0124131B
 *
 */
public class TaskExistsException extends Exception {

	private static final long serialVersionUID = 7796563144891762211L;
	private static final String ERROR_MESSAGE_FORMAT = "%s for task: %s";
	private String taskName;

	/**
	 * Basic constructor for TaskExistsException
	 */
	public TaskExistsException() {
		super();
	}

	/**
	 * Constructor with a message String and the task name of the task which
	 * caused the exception
	 * 
	 * @param message
	 *            the message to be displayed
	 * @param taskName
	 *            the name of the task which caused the exception
	 */
	public TaskExistsException(String message, String taskName) {
		super(message);
		this.taskName = taskName;
	}

	/**
	 * Constructor with a message String, the task name of the task which caused
	 * the exception and the stack trace to the cause of the exception
	 * 
	 * @param message
	 *            the message to be displayed
	 * @param taskName
	 *            the name of the task which caused the exception
	 * @param cause
	 *            the stack trace to the TaskExistsException
	 */
	public TaskExistsException(String message, String taskName, Throwable cause) {
		super(message, cause);
		this.taskName = taskName;
	}

	@Override
	public String toString() {
		return super.toString();
	}

	@Override
	public String getMessage() {
		return String.format(ERROR_MESSAGE_FORMAT, super.getMessage(), taskName);
	}

}
```
###### \src\tnote\util\exceptions\TimeClashException.java
``` java
package tnote.util.exceptions;

/**
 * This class is a custom exception thrown when there is a clash in timings
 * between an existing task in the system and a task the user wants to add
 * 
 * @author A0124131B
 *
 */
public class TimeClashException extends Exception {

	private static final long serialVersionUID = 8809288865672326368L;
	private static final String ERROR_MESSAGE_FORMAT = "%s between %s, %s";
	private String newTaskName;
	private String clashingTaskName;

	/**
	 * Basic constructor for TimeClashException
	 */
	public TimeClashException() {
		super();
	}

	/**
	 * Constructor for TimeClashException with a message String, and the names
	 * of the tasks which have a timing clashing
	 * 
	 * @param message
	 *            the message to be displayed
	 * @param newTaskName
	 *            one of the clashing tasks
	 * @param clashTaskName
	 *            the other clashing task
	 */
	public TimeClashException(String message, String newTaskName, String clashTaskName) {
		super(message);
		this.newTaskName = newTaskName;
		this.clashingTaskName = clashTaskName;
	}

	/**
	 * Constructor for TimeClashException with a message String, the names of
	 * the tasks which have a timing clashing and the stack trace to the cause
	 * of the Exception
	 * 
	 * @param message
	 *            the message to be displayed
	 * @param newTaskName
	 *            one of the clashing tasks
	 * @param clashTaskName
	 *            the other clashing task
	 * @param cause
	 *            the stack trace to the TimeClashException
	 */
	public TimeClashException(String message, String newTaskName, String clashTaskName, Throwable cause) {
		super(message, cause);
		this.newTaskName = newTaskName;
		this.clashingTaskName = clashTaskName;
	}

	@Override
	public String toString() {
		return super.toString();
	}

	@Override
	public String getMessage() {
		return String.format(ERROR_MESSAGE_FORMAT, super.getMessage(), newTaskName, clashingTaskName);
	}
}
```
###### \src\tnote\util\log\TNoteLogger.java
``` java
package tnote.util.log;

import java.io.IOException;
import java.util.logging.FileHandler;
import java.util.logging.LogManager;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;

/**
 * This class configures the global logger for TNote to use. It disables the
 * console handler and attaches a file handler
 * 
 * @author A0124131B
 *
 */
public class TNoteLogger {

	private static final String TNOTE_LOG_FILE = "TNoteLog.log";
	private static Logger logger;
	private static FileHandler fileTxt;
	private static SimpleFormatter formatterTxt;
	
	/**
	 * Static method which configures the global logger to allow for its use in TNotes
	 * @throws IOException I/O Error when opening the specified log file
	 */
	public static void setUp() throws IOException {
		LogManager.getLogManager().reset();
		fileTxt = new FileHandler(TNOTE_LOG_FILE, true);
		formatterTxt = new SimpleFormatter();
		logger = Logger.getGlobal();
		fileTxt.setFormatter(formatterTxt);
		logger.addHandler(fileTxt);
	}
}
```
